<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>react-性能优化2</title>
    <url>/2020/11/07/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%962/</url>
    <content><![CDATA[<p>react-hook 性能优化方案</p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>JS-高阶函数</title>
    <url>/2020/11/06/JS-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="/2020/11/06/JS-高阶函数/bg2.jpg" alt="高阶函数"><br>高阶函数以及多个高阶函数嵌套</p>
<a id="more"></a>
<p>高阶函数：以另一个函数作为参数的函数</p>
<p>例子：封装一个 map 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">arr.map((v,k)=&gt;&#123;</span><br><span class="line">    console.log(this.sss);//1</span><br><span class="line">    return v*2</span><br><span class="line">&#125;,&#123;sss:1&#125;)</span><br></pre></td></tr></table></figure>
<p>注意，<code>map</code>方法的第二个参数作为第一个函数的<code>this</code>对象，如果未传入，函数的 this 指向按照函数的类型，是否严格模式等情况讨论，<br>参见:JS-this 指向<br>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype._map=function(fun,context)&#123;</span><br><span class="line">    if(typeof fun !==&apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(fn+&quot;is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let len=this.length;</span><br><span class="line">    let temp=[]</span><br><span class="line">    for(let k=0;k&lt;len;k++)&#123;</span><br><span class="line">        temp.push(fun.call(context,this[k],k,this))</span><br><span class="line">    &#125;</span><br><span class="line">    return temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码组合</strong><br>高阶函数 widthLogin，判断用户状态<br>登录判断模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getLogin=function()&#123;</span><br><span class="line"> const getLogin=function()&#123;</span><br><span class="line">     var a=parseInt(Math.random()*10).toFixed(0);</span><br><span class="line">     if(a%2==0)&#123;</span><br><span class="line">         return &#123;login:false&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return&#123;</span><br><span class="line">         login:true</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const withLogin=function(basicFn)&#123;</span><br><span class="line">     const loginInfo=getLogin();</span><br><span class="line">     return basicFn.bind(null,loginInfo)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const withLogin=window.withLogin;</span><br><span class="line">const renderIndex=function(loginInfo)&#123;</span><br><span class="line">    //判断是否登录</span><br><span class="line">    if(loginInfo.login)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.renderIndex=withLogin(renderIndex)</span><br></pre></td></tr></table></figure>
<p>其他模块，处理方法相同，都是在外面包一层 withLogin<br>如果还需要一个高阶函数判断当前系统的运行环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    const env=&#123;</span><br><span class="line">        isMobile:false,</span><br><span class="line">        isAndroid:false,</span><br><span class="line">        isIOS:false,</span><br><span class="line">    &#125;</span><br><span class="line">    const ua=navigator.userAgent;</span><br><span class="line">    env.isMobile=&apos;ontouchstart&apos; in document;</span><br><span class="line">    env.isAndroid=!!ua.match(/android/);</span><br><span class="line">    env.isIOS=!!us.match(/iphone/);</span><br><span class="line"></span><br><span class="line">    const withEnvironment=function(basicFn)&#123;</span><br><span class="line">        return basicFn.bind(null,env);</span><br><span class="line">    &#125;</span><br><span class="line">    window.withEnvironment=withEnvironment;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>此时主页函数调用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.renderIndex = withLogin(withEnvironment(renderIndex));</span><br></pre></td></tr></table></figure>
<p><code>compose</code>方法从右至左，将第一个参数<code>renderIndex</code>作为第二个参数<code>withEnvironment</code>的参数，并将运行结果作为第一个参数的参数，并且最后返回一个新的函数，这个函数拥有两个高阶函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br></pre></td></tr></table></figure>
<p>实现方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">     let last = args.length - 1;</span><br><span class="line">     tag = false;</span><br><span class="line">     if (typeof args[last] === &apos;function&apos;) &#123;</span><br><span class="line">         tag = true</span><br><span class="line">     &#125;</span><br><span class="line">     if (last &gt; 1) &#123;</span><br><span class="line">         let param = args.pop(args[last]);</span><br><span class="line">         last--;</span><br><span class="line">         let newParam = args[last].call(args[last], param)</span><br><span class="line">         args.pop(args[last])</span><br><span class="line"></span><br><span class="line">         args.push(newParam);</span><br><span class="line">         console.log(newParam);</span><br><span class="line">         return compose(...args);</span><br><span class="line">     &#125; else if (last === 1) &#123;</span><br><span class="line">         if (!tag) &#123;</span><br><span class="line">             return args[0].bind(null, args[1])</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             return args[0].call(null, args[1])</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn1 = function (a) &#123;</span><br><span class="line">        return a + 100</span><br><span class="line">    &#125;</span><br><span class="line">    var fn2 = function (a) &#123;</span><br><span class="line">        return a + 10</span><br><span class="line">    &#125;</span><br><span class="line">    var fn3 = function (a) &#123;</span><br><span class="line">        return a + 20</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var bar = compose(fn1, fn2, fn3, 10);</span><br><span class="line">    console.log(bar());</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    // 30</span><br><span class="line">    // 40</span><br><span class="line">    // 140</span><br></pre></td></tr></table></figure>
<p>上一个函数的运算结果作为下一个函数的参数，这种逻辑与<code>reduce</code>相似。<br>利用<code>reduce</code>实现<code>compose</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">  return args.reduceRight((pre, cur, i) =&gt; &#123;</span><br><span class="line">    console.log(pre, cur, i)</span><br><span class="line">    return cur(pre)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助科里化封装得更加灵活</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">window.renderIndex = compose(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure>
<p>利用<code>lodash.js</code>中是的<code>flowRight</code>来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES6 模块化语法，引入flowRight函数</span><br><span class="line">import flowRight from &apos;lodash/flowRight&apos;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// ES6模块化语法 对外暴露接口</span><br><span class="line">export default flowRight(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure>
<p>参考<br><a href="https://www.yuque.com/coreadvance/kagkke/bnk7g4" target="_blank" rel="noopener">高阶函数</a><br><a href="https://www.yuque.com/coreadvance/kagkke/zn7kz1" target="_blank" rel="noopener">代码组合</a></p>
]]></content>
  </entry>
  <entry>
    <title>JS-科里化</title>
    <url>/2020/11/06/JS-%E7%A7%91%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<p><img src="/2020/11/06/JS-科里化/bg1.jpg" alt="科里化"><br>科里化的简单应用</p>
<a id="more"></a>
<p>科里化是将一个函数所需要的多个参数分开传入函数中，每次调用会返回一个新函数，用于处理剩余参数。<br>所以将一个函数科里化的过程就是收集函数参数的过程，递归搜集参数，收集完成后，在最深层计算结果并返回。</p>
<h2 id="科里化通用式"><a href="#科里化通用式" class="headerlink" title="科里化通用式"></a>科里化通用式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createCurry(fn,restLen,args)&#123;</span><br><span class="line">    restLen=restLen||fn.length;</span><br><span class="line">    args=args||[];</span><br><span class="line">    const wrapper=function()&#123;</span><br><span class="line">        let _args=[].slice.call(arguments);</span><br><span class="line">        [].push.call(args,_args);</span><br><span class="line">        if(restLen&gt;_args.length)&#123;</span><br><span class="line">            restLen-=_args.length;</span><br><span class="line">            return wrapper(fn,restLen,args)</span><br><span class="line">        &#125;</span><br><span class="line">        return fn.apply(fn,args)</span><br><span class="line">    &#125;</span><br><span class="line">    return wrapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>验证手机号码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function checkPhone(phoneNumber)&#123;</span><br><span class="line">    return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运用科里化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function check(reg,targetString)&#123;</span><br><span class="line">    return reg.test(targetString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _check = createCurry(check);</span><br><span class="line"></span><br><span class="line">var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);</span><br><span class="line">var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkPhone(&apos;183888888&apos;);</span><br><span class="line">checkEmail(&apos;xxxxx@test.com&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li><p>函数不定参数，解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let args=[1,2,3,4]</span><br><span class="line">add.apply(null,args)</span><br><span class="line">add(...args)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数隐式转换<br>当函数参与运算时，会默认调用 toString 方法，获取返回值，参与运算。<br>默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a+1 //&quot;function a()&#123;&#125;1&quot;</span><br></pre></td></tr></table></figure>
<p>重写 toString 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a.toString=function()&#123;return 10&#125;</span><br><span class="line">a+1 //11</span><br><span class="line">a+&apos;1&apos; //&apos;11&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>add</code>函数<br>实现一个 add 方法，使计算结果能够满足如下预期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">    let _args=[].slice.call(arguments);</span><br><span class="line">    const adder=function()&#123;</span><br><span class="line">        const _adder=function()&#123;</span><br><span class="line">            _args.push(...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">     _adder.toString=function()&#123;</span><br><span class="line">         return _args.reduce((a,b)=&gt;&#123;</span><br><span class="line">             return a+b</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     return _adder</span><br><span class="line">    &#125;</span><br><span class="line">    return adder(..._args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<br><a href="https://www.yuque.com/coreadvance/kagkke/iz3cdu" target="_blank" rel="noopener">科里化</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云部署</title>
    <url>/2020/10/28/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>总结一下阿里云服务器部署 web 项目遇到的问题<br>因为只是要求 web 项目可以运行起来，总体很简单，卡在 FTP 上传文件上，先入为主，之前一直使用 FileZilla 部署，连接失败一直以为是这次的服务器配置有问题，没想到软件运行环境的问题。利用 win10 虚拟机安装了 FileZilla，测试正常。</p>
<a id="more"></a>
<h2 id="云服务器-ECS"><a href="#云服务器-ECS" class="headerlink" title="云服务器 ECS"></a>云服务器 ECS</h2><ul>
<li><p><strong>如何选择服务器配置</strong><br>本次为了熟悉部署步骤，使用的是 ECS 的体验版一个月（1vCPU 2GB）。<br><a href="https://help.aliyun.com/document_detail/58291.html?spm=a2c4g.11186623.2.20.240a5b73L2bPBY" target="_blank" rel="noopener">ECS 选型最佳实践</a><br>简单的企业官网选择 2 核 4G 或 2 核 8G 就可以，不确定选什么样的，可以先配最低的，后面再升级。</p>
</li>
<li><p><strong>创建实例</strong><br>购买之后，会默认生成一个实例，我是根据默认实例操作的，如果购买的配置较高，可以新建多个实例</p>
</li>
<li><p><strong>操作系统选择</strong><br>根据要配置的运行环境选择不同操作系统，后面可以修改。</p>
</li>
<li><p><strong>连接 ECS 实例</strong><br>Workbench 远程连接<br>使用 Linux 用户名密码连接，用户名默认 root，密码忘记了可以重置，如果要重新选择系统也要重置密码。<br><img src="/2020/10/28/阿里云部署/1.png" alt="重置密码"></p>
</li>
<li><p><strong>运行环境配置</strong><br><a href="https://help.aliyun.com/document_detail/57160.html?spm=a2c4g.11186623.6.1178.240a5b73L2bPBY" target="_blank" rel="noopener">自助建站方式汇总</a><br>比较熟悉的是 Node 环境，所有我配的是<a href="https://help.aliyun.com/document_detail/50775.html?spm=a2c4g.11186623.2.23.1d8679249RKC9e#concept-50775-zh" target="_blank" rel="noopener">部署 Node.js 环境（CentOS 7）</a><br>第一种方法 NVM 安装有问题，我采用第二种方法。</p>
<ol>
<li><p>下载安装包<br>提供的链接比较老，可以去 node 官网找最新的响应版本。<br>node 中文网-》下载-》阿里云镜像-》最新 linux64-》复制链接-》替换<br><code>wget https://npm.taobao.org/mirrors/node/v14.14.0/node-v14.14.0-linux-x64.tar.gz</code></p>
</li>
<li><p>解压<br><code>tar xvf node-v14.14.0-linux-x64.tar.gz</code></p>
</li>
<li><p>创建软链接，您就可以在任意目录下直接使用 node 和 npm 命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
<p>其中<code>/root</code>是文件下载或解压的所在路径，默认在<code>/root</code>下</p>
</li>
<li><p>查看版本</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>如果需要将该软件安装到其他目录（例如：/opt/node/）下，请进行如下操作：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/node/</span><br><span class="line">mv /root/node-v14.14.0-linux-x64/* /opt/node/</span><br><span class="line">rm -f /usr/local/bin/node</span><br><span class="line">rm -f /usr/local/bin/npm</span><br><span class="line">ln -s /opt/node/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /opt/node/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>安装 pm2<br>为了自动重启 Node 项目。<br><code>npm install pm2 -g</code><br>还可使用<br><code>wget -qO- https://getpm2.com/install.sh | bash</code><br>启动项目<br><code>pm2 start /var/ftp/test/index</code><br>启动 n 个进程，名字命名为 name。<br><code>pm2 start app.js -i [n] --name [name]</code><br>自启动（watch 的文件发生变化就会自启动）<br><code>pm2 start app.js --watch</code></li>
</ol>
</li>
<li><p><strong>上传项目到 ECS</strong><br>这个问题纠结了好几天，怎么配置我的 FileZilla 都不行，chrome 也没有上传按钮。最后在 win10 虚拟机上安装了一个 FileZilla，拖拽上传打包后的项目+nodeserver 就行了</p>
</li>
<li><p><strong>启动项目</strong><br><code>pm2 start /var/ftp/test/index</code><br>根据服务器启动的端口，配置安全组，我的服务是 8080 端口<br><img src="/2020/10/28/阿里云部署/2.png" alt="安全组"></p>
</li>
</ul>
<p>———撒花！撒花！完成了不知道能不能部署一个真的项目——–</p>
<h2 id="域名申请和绑定"><a href="#域名申请和绑定" class="headerlink" title="域名申请和绑定"></a>域名申请和绑定</h2><h2 id="公司邮箱"><a href="#公司邮箱" class="headerlink" title="公司邮箱"></a>公司邮箱</h2>]]></content>
  </entry>
  <entry>
    <title>GET和POST区别</title>
    <url>/2020/08/20/GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>GET 和 POST 核心机制与区别</p>
<a id="more"></a>
<h2 id="场景一：浏览器的-GET-和-POST"><a href="#场景一：浏览器的-GET-和-POST" class="headerlink" title="场景一：浏览器的 GET 和 POST"></a>场景一：浏览器的 GET 和 POST</h2><p>这里特指浏览器中非<code>Ajax</code>的<code>Http</code>请求，即<code>HTTP</code>协议中的<code>GET/POST</code>，浏览器用<code>GET</code>请求来获取一个<code>html</code>页面、图片、<code>css</code>、<code>js</code> 等资源，用<code>POST</code>请求提交一个<code>&lt;form&gt;</code>表单，并得到一个结果。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取资源，反复读取不会对访问的数据有副作用，没有副作用被称为‘幂等’。<br>因为 GET 是读取数据，就可以对 GET 请求的数据做缓存，缓存可以做到浏览器本身（彻底避免浏览器发请求），也可以做到代理上，或者 server 端。</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>在页面里<code>&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; &gt;</code>标签会定义一个表单，点击其中的<code>submit</code>元素会发出一个<code>POST</code>请求让服务器做一件事。这件事往往是有副作用的，不幂等的。<br>不幂等就意味着不能随意多次执行，因此也不能缓存。</p>
<p><code>GET</code>和<code>POST</code>携带的数据格式也是有区别的，浏览器发出<code>GET</code>请求时分为两种情况，第一种用户自己在浏览器的地址栏输入，第二种点击<code>html</code>的<code>a</code>标签触发了<code>href</code>中的<code>url</code>。其实并不是<code>GET</code>只能用<code>url</code>,而是浏览器直接发出的<code>GET</code>只能由一个<code>url</code>触发。所以如果<code>GET</code>上要在<code>url</code>之外带一些参数就要依靠<code>querystring</code>。<br>浏览器的<code>POST</code>请求都来自表单提交，表单的数据被浏览器编码到 HTTP 请求的 body 里。两种编码方式：<code>application/x-www-form-urlencoded</code>用来传输简单数据，例如：”key1=value1&amp;key2=value2”,<code>multipart/form-data</code>用来传输文件。<br>浏览器在<code>POST</code>表单数据时，也可以带上参数，直接写在<code>action</code>的<code>url</code>里。<br>一般说“<code>GET</code>请求没有<code>body</code>，只有<code>url</code>，请求数据放在<code>url</code>的<code>querystring</code>中；<code>POST</code>请求的数据在<code>body</code>中“。但这种情况仅限于浏览器发请求的场景。</p>
<h2 id="接口中的-GET-和-POST"><a href="#接口中的-GET-和-POST" class="headerlink" title="接口中的 GET 和 POST"></a>接口中的 GET 和 POST</h2><p>这里指通过浏览器的<code>Ajax api</code>，或者<code>iOS/Android</code>的<code>App</code>的<code>http client</code>，<code>java</code> 的<code>commons-httpclient/okhttp</code>或者是<code>curl</code>，<code>postman</code>之类的工具发出来的<code>GET</code>和<code>POST</code>请求。此时 GET/POST 不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种 RPC 协议使用）。<br>REST 接口规范、风格，约定了<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>，这 4 个接口获取、创建、替换、删除，<code>REST</code>最佳实践还推荐在请求体使用<code>JSON</code>格式。<br><code>JSON</code>相对于<code>x-www-form-urlencoded</code>的优势在于: 1. 嵌套结构 2. 可以支持更丰富的数据类型。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>因为 POST 用 body 传输数据，而 GET 用 url 传输，更容易看到，所以 GET 更不安全。但是从攻击角度，无论是 GET 还是 POST 都不够安全，因为 HTTP 本身时明文协议，每个 HTTP 请求和返回的每个 byte 都会在网络上明文传输，不论是 url,header 或 body。<br>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是 https</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>URL 编码<br>utf-8 编码<br>body 编码</p>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
  </entry>
  <entry>
    <title>ES10</title>
    <url>/2020/08/19/ES10/</url>
    <content><![CDATA[<p>ES2019</p>
<a id="more"></a>
<h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat()/flatMap()"></a><code>Array.prototype.flat()/flatMap()</code></h2><p><code>flat()</code>根据传入参数，深度递归遍历数组，并将所有元素与遍历的子数组中的元素合并为一个新数组返回。<br><code>flatMap()</code>与<code>map()</code>方法的深度为 1 的<code>flat()</code>几乎相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4]</span><br><span class="line">let arr2 = arr1.map(x =&gt; [x * 2]) // [[2], [4], [6], [8]]</span><br><span class="line">let arr3 = arr2.flatMap(x =&gt; x) // [2, 4, 6, 8]</span><br><span class="line">let arr4 = arr2.flatMap(x =&gt; [x]) // [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure>
<h2 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()"></a><code>String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()</code></h2><p>在 ES5 中，可以通过 trim()来去掉字符首尾的空格。<br>ES10 之后可以使用<code>trimStart()/trimLeft()</code>去掉开头的空格。<br><code>trimEnd()/trimRight()</code>去掉结尾的空格。<br>不过这里有一点要注意的是，<code>trimStart()</code>跟 <code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟 <code>trimRight()</code>只是别名。</p>
<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a><code>Object.fromEntries()</code></h2><p>把键值对列表转换为一个对象，是<code>Object.entries()</code>的反函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const entries = new Map([</span><br><span class="line">    [&apos;foo&apos;, &apos;bar&apos;],</span><br><span class="line">    [&apos;baz&apos;, 42]</span><br><span class="line">])</span><br><span class="line">const obj = Object.fromEntries(entries)</span><br><span class="line">console.log(obj) //&#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a><code>Symbol.prototype.description</code></h2><p>只读属性，返回<code>Symbol</code>对象的可选描述的字符串。与<code>Symbol.prototype.toString()</code>不同的是，它不会包含<code>Symbol</code>的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Symbol(&apos;desc&apos;).toString()); // &quot;Symbol(desc)&quot;</span><br><span class="line">console.log(Symbol(&apos;desc&apos;).description); // &quot;desc&quot;</span><br><span class="line">console.log(Symbol(&apos;&apos;).description); // &quot;&quot;</span><br><span class="line">console.log(Symbol().description); // undefined</span><br><span class="line">console.log(Symbol.iterator.toString()); // &quot;Symbol(Symbol.iterator)&quot;</span><br><span class="line">console.log(Symbol.iterator.description); // &quot;Symbol.iterator&quot;</span><br></pre></td></tr></table></figure>
<h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a><code>String.prototype.matchAll</code></h2><p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var regexp = /t(e)(st(\d?))/g</span><br><span class="line">var str = &apos;test1test2&apos;;</span><br><span class="line">console.log(str.match(regexp)); // [&apos;test1&apos;, &apos;test2&apos;]</span><br><span class="line">console.log(str.matchAll(regexp)); // RegExpStringIterator &#123;&#125;</span><br><span class="line">console.log([...str.matchAll(regexp)])</span><br><span class="line">// [[&apos;test1&apos;, &apos;e&apos;, &apos;st1&apos;, &apos;1&apos;, index: 0, input: &apos;test1test2&apos;, length: 4], [&apos;test2&apos;, &apos;e&apos;, &apos;st2&apos;, &apos;2&apos;, index: 5, input: &apos;test1test2&apos;, length: 4]]</span><br></pre></td></tr></table></figure>
<h2 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString()返回注释与空格"></a><code>Function.prototype.toString()</code>返回注释与空格</h2><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从 ES10 开始会保留这些空格，如果是原生函数则返回你控制台看到的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum.toString())</span><br><span class="line">// &quot;function sum(a, b) &#123;</span><br><span class="line">//         return a + b;</span><br><span class="line">//  &#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><code>try-catch</code></h2><p>以往版本中，<code>try-catch</code>里的<code>catch</code>后面必须带异常参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES10之前</span><br><span class="line">try &#123;</span><br><span class="line">// tryCode</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">// catchCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在 ES10 之后，这个参数却不是必须的，如果用不到，我们可以不用传。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(&apos;Foobar&apos;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    console.error(&apos;Bar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><p>内置对象，提供一种方法表示大于 2^53-1 的整数。<code>BigInt</code>可以表示任意大的整数。<br>定义<code>BigInt</code>：<code>10n</code>或<code>BigInt()</code><br>以下操作符可以和<code>BigInt</code>一起使用：<code>+</code>,<code>-</code>,<code>*</code>,<code>**</code>,<code>%</code>。除<code>&gt;&gt;&gt;</code>(无符号右移)之外的位操作符也可以支持。因为<code>BigInt</code>都是有符号的，<code>&gt;&gt;&gt;</code>（无符号右移）不能用于<code>BigInt</code>。<code>BigInt</code>不支持单目 (+) 运算符。<br><code>/</code>操作符对于整数的运算也没问题。可是因为这些变量是<code>BigInt</code>而不是<code>BigDecimal</code>，该操作符结果会向零取整，也就是说不会返回小数部分。<br><code>BigInt</code>和<code>Number</code>不是严格相等的，但是宽松相等的。</p>
<p>所以在<code>BigInt</code>出来以后，JS 的原始类型便增加到了 7 个，如下：</p>
<ul>
<li><code>Boolean</code></li>
<li><code>Null</code></li>
<li><code>Undefined</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li><code>Symbol (ES6)</code></li>
<li><code>BigInt (ES10)</code></li>
</ul>
<h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a><code>globalThis</code></h2><p>包含类似于全局对象<code>this</code>值，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">globalThis === this // true</span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import()"></a><code>import()</code></h2><p>静态的<code>import</code>语句用于导入由另一个模块导出的绑定。无论是否声明了严格模式，导入的模块都运行在严格模式下。<br>在浏览器中，<code>import</code>语句只能在声明了<code>type=&#39;module&#39;</code>的<code>script</code>的标签中使用。<br>但是在 ES10 之后，我们有动态<code>import()</code>，它不需要依赖<code>type=&quot;module&quot;</code>的<code>script</code>标签。</p>
<h2 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Counter extends HTMLElement &#123;</span><br><span class="line">    #xValue = 0</span><br><span class="line"></span><br><span class="line">    get #x() &#123;</span><br><span class="line">        return #xValue</span><br><span class="line">    &#125;</span><br><span class="line">    set #x(value) &#123;</span><br><span class="line">        this.#xValue = value</span><br><span class="line">        window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #clicked() &#123;</span><br><span class="line">        this.#x++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.onclick = this.#clicked.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">            this.#render()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #render() &#123;</span><br><span class="line">        this.textContent = this.#x.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.customElements.define(&apos;num-counter&apos;, Counter)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
  </entry>
  <entry>
    <title>ES8</title>
    <url>/2020/08/18/ES8/</url>
    <content><![CDATA[<p>ES2017</p>
<a id="more"></a>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h2><p><a href="https://dorisfeng.github.io/2020/06/22/JS-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a></p>
<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a><code>Object.values()</code></h2><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a><code>Object.entries()</code></h2><h2 id="padStart-len-s"><a href="#padStart-len-s" class="headerlink" title="padStart(len,s)"></a><code>padStart(len,s)</code></h2><p>用另一个字符串从开始位置填充当前字符串，使产生的字符串达到给定长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let last4 = ID.slice(-4)</span><br><span class="line">let new_ID = last4.padStart(ID.length, &apos;*&apos;);</span><br><span class="line">console.log(new_ID);//**************3529</span><br></pre></td></tr></table></figure>
<h2 id="padEnd-len-s"><a href="#padEnd-len-s" class="headerlink" title="padEnd(len,s)"></a><code>padEnd(len,s)</code></h2><p>在末尾填充，规则跟<code>padStart</code>的一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let first3 = ID.slice(0, 3)</span><br><span class="line">let new_ID = first3.padEnd(ID.length, &apos;*&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="函数参数逗号结尾"><a href="#函数参数逗号结尾" class="headerlink" title="函数参数逗号结尾"></a>函数参数逗号结尾</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 参数定义</span><br><span class="line">function f(p) &#123;&#125;</span><br><span class="line">function f(p,) &#123;&#125;</span><br><span class="line"></span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有参数就只有逗号会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 带有尾后逗号的数组解构</span><br><span class="line">[a, b,] = [1, 2]</span><br><span class="line"></span><br><span class="line">// 带有尾后逗号的对象解构</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 42,</span><br><span class="line">  q: true,</span><br><span class="line">&#125;</span><br><span class="line">var &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure>
<p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var [a, ...b,] = [1, 2, 3] // SyntaxError: rest element may not have a trailing comma</span><br></pre></td></tr></table></figure>
<h2 id="ShareArrayBuffer"><a href="#ShareArrayBuffer" class="headerlink" title="ShareArrayBuffer"></a><code>ShareArrayBuffer</code></h2><p>因安全性问题，暂时在 Chrome 和 FireFox 中被禁用。<br>用来表示一个通用的、固定长度的原始二进制缓冲区，类似 ArrayBuffer 对象。它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，ShareArrayBuffer 不能被分离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sab=new SharedArrayBuffer(1024);</span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure>
<h2 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a><code>Atomics</code>对象</h2><p>对<code>ShareArrayBuffer</code>对象进行原子操作。</p>
<ul>
<li><code>Atomics.add()</code>，将指定位置上的数组元素与给定的值相加并返回该元素更新前的值。</li>
<li><code>Atomics.compareExchange()</code>，如果数组中指定的元素与给定的值相等，将其更新为新的值，并返回该元素更新前的值。</li>
<li><code>Atomics.exchange()</code>，将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</li>
<li><code>Atomics.load()</code>，返回数组中指定元素的值</li>
<li><code>Atomics.or()</code>，将指定位置上的数组元素与给定的值相或，并返回该元素更新前的值。</li>
<li><code>Atomics.store()</code>，将数组中指定的元素设置为给定的值，返回该值。</li>
<li><code>Atomics.sub()</code>，将指定位置上的数组元素与给定的值相减，并返回该元素更新前的值。</li>
<li><code>Atomics.xor()</code>，将指定位置上的数组元素与给定的值相异或，并返回该元素更新前的值。</li>
<li><code>Atomics.wait()</code>，检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</li>
<li><code>Atomics.wake()</code>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</li>
<li><code>Atomics.isLockFree(size)</code>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</li>
</ul>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>获取一个对象的所有自身属性的描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">    property1: 42</span><br><span class="line">&#125;</span><br><span class="line">const descriptors1 = Object.getOwnPropertyDescriptors(object1);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
  </entry>
  <entry>
    <title>ES7</title>
    <url>/2020/08/18/ES7/</url>
    <content><![CDATA[<p>ES2016</p>
<a id="more"></a>
<h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a><code>Array.prototype.includes()</code></h2><p>用来判断一个数组是否包含指定值，如果包含返回 true，否则返回 false。</p>
<h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a><code>幂运算符**</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2**10; //1024</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><code>模板字符串</code></h2><ul>
<li><code>Unicode</code>字符以<code>\u</code>开头，例如<code>\u00A9</code>,”©”</li>
<li><code>Unicode</code>码位用<code>\u{}</code>表示，例如<code>\u{2F804}</code>,’你’</li>
<li>十六进制以<code>\x</code>开头，例如<code>\xA9</code>,”©”</li>
<li>八进制以<code>\</code>和数字开头，例如<code>\251</code></li>
</ul>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
  </entry>
  <entry>
    <title>IE兼容性问题</title>
    <url>/2020/08/13/IE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>html5-canvas动画</title>
    <url>/2020/07/29/html5-canvas%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>canvas 动画</p>
<a id="more"></a>
<h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><ol>
<li><strong>清空 canvas</strong><br>除非接下来要画的内容会完全充满<code>canvas</code>(例如背景图)，否则你需要清空所有。最简单使用<code>clearRect</code>方法。</li>
<li><strong>保存 canvas 状态</strong><br>如果你改变一些会改变 canvas 状态的设置，又要在每画一帧之时都是原始状态的话，需要先保存一下。</li>
<li><strong>绘制动画图形 animated shapes</strong><br>重绘动画帧</li>
<li><strong>恢复 canvas 状态</strong><br>如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</li>
</ol>
<h2 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h2><ul>
<li><code>setInterval(fun,delay)</code><br>延迟 delay 毫秒后执行函数</li>
<li><code>setTimeout(func,delay)</code><br>间隔 delay 毫秒执行函数</li>
<li><code>requestAnimationFrame(callback)</code><br>告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function init() &#123;</span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let ctx = document.getElementById(&apos;my_canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">    ctx.save()</span><br><span class="line">    ctx.clearRect(0, 0, 400, 400);</span><br><span class="line"></span><br><span class="line">    //每个间隔弧度</span><br><span class="line">    let angle = 2 * Math.PI / 60;</span><br><span class="line"></span><br><span class="line">    function drawBorder() &#123;</span><br><span class="line">        ctx.save(); //1</span><br><span class="line">        ctx.strokeStyle = &apos;#3D5F9D&apos;;</span><br><span class="line">        ctx.lineWidth = 6;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(200, 200, 150, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSplit() &#123;</span><br><span class="line">        ctx.save()</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        //分隔</span><br><span class="line">        for (let i = 1; i &lt;= 60; i++) &#123;</span><br><span class="line">            ctx.rotate(angle);</span><br><span class="line">            ctx.lineCap = &apos;round&apos;;</span><br><span class="line">            ctx.strokeStyle = &apos;#000&apos;;</span><br><span class="line">            ctx.lineWidth = 4;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            if (i % 5) &#123;</span><br><span class="line">                ctx.moveTo(0, -127);</span><br><span class="line">                ctx.lineTo(0, -130);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.moveTo(0, -120);</span><br><span class="line">                ctx.lineTo(0, -132);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.stroke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawHour(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //时针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 7;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -90)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawMinute(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //分针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 4;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -125)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSecond(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //秒针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 3;</span><br><span class="line">        ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -112);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, -120, 7, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    //中心</span><br><span class="line">    function drawCenter() &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.fillStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, 0, 5, 0, 2 * Math.PI);</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算角度</span><br><span class="line">    let date = new Date();</span><br><span class="line">    let hour = date.getHours() % 12;</span><br><span class="line">    let minutes = date.getMinutes();</span><br><span class="line">    let seconds = date.getSeconds();</span><br><span class="line">    let second_ag = seconds * angle;</span><br><span class="line">    let minute_ag = (minutes * angle + second_ag / 60) * 5;</span><br><span class="line">    let hour_ag = (hour * angle + minute_ag / 60) * 5;</span><br><span class="line">    drawBorder()</span><br><span class="line">    drawSplit()</span><br><span class="line">    drawHour(hour_ag)</span><br><span class="line">    drawMinute(minute_ag)</span><br><span class="line">    drawSecond(second_ag)</span><br><span class="line">    drawCenter()</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/29/html5-canvas动画/_posts/html5-canvas动画/img1.png" alt="时钟"></p>
<h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><p>有兴趣的时候来补充</p>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
  </entry>
  <entry>
    <title>html5-canvas基础</title>
    <url>/2020/07/23/html5-canvas%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>canvas 用法</p>
<a id="more"></a>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;my_canvas&quot; width=&quot;500px&quot; height=&quot;500px&quot; &gt;</span><br><span class="line">    您的浏览器不支持canvas，请升级您的浏览器！</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>canvas</code>为替换内容，如果浏览器不支持<code>canvas</code>，就会显示元素内部的内容</li>
<li><code>width</code>、<code>height</code>都是可选属性，用于定义<code>canvas</code>的宽高。默认宽高为<code>300px*150px</code>。</li>
<li><code>id</code>属性用于绘制时，找到该画布。</li>
</ol>
<h3 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h3><p><code>canvas</code>元素的<code>getContext()</code>方法可以获取渲染上下文和绘功能，参数’2d’表示开启 2D 绘图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let my_canvas=document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">let ctx=canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure>
<p>检查 JS 的支持性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(my_canvas.getContext)&#123;</span><br><span class="line">    let ctx=my_canvas.getContext(&apos;2d&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //不支持canvas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p><strong>矩形</strong></p>
<ul>
<li><code>fillRect(x,y,width,height)</code> 绘制填充矩形</li>
<li><code>strokeRect(x,y,width,height)</code> 绘制描边矩形</li>
<li><code>clearRect(x,y,width,height)</code> 清除指定矩形区域，让清除部分完全透明<br><code>x,y</code>指画布上所绘制矩形的左上角（相对于画布的左上角（0，0））<br><code>width,height</code>设置矩形的尺寸</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(10, 10, 100, 100);</span><br><span class="line">    ctx.clearRect(20, 20, 80, 80);</span><br><span class="line">    ctx.strokeRect(40, 40, 40, 40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img1.png" alt="矩形"></p>
<p><strong>路径/直线</strong></p>
<ul>
<li><code>beginPath()</code> 开始一条新路径</li>
<li><code>closePath()</code> 闭合路径，会自动将起点和终点连接起来，如果不需要连接，可以不使用。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</li>
<li><code>stroke()</code> 绘制图形轮廓</li>
<li><code>fill()</code> 填充路径内容区域的生成的实心图形</li>
<li><code>moveTo()</code> 将笔触移动到指定的坐标<code>(x,y)</code>上</li>
<li><code>lineTo()</code> 绘制一条从当前位置到坐标<code>(x,y)</code>上的直线</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(20, 20);</span><br><span class="line">    ctx.lineTo(100, 20);</span><br><span class="line">    ctx.lineTo(100, 100);</span><br><span class="line">    ctx.closePath()</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(150, 20);</span><br><span class="line">    ctx.lineTo(230, 20)</span><br><span class="line">    ctx.lineTo(230, 100)</span><br><span class="line">    ctx.fill()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img2.png" alt="三角形"></p>
<p><strong>圆弧</strong></p>
<ul>
<li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code><br>画一个以<code>(x,y)</code>为圆心，以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认顺时针）来生成。</p>
<ul>
<li><code>startAngle</code>以及<code>endAngle</code>参数用弧度定义了开始以及结束的弧度，都是以<code>x</code>轴为基准。<br>单位是弧度不是角度，<code>弧度=(Math.PI/180)*角度</code></li>
<li><code>anticlockwise</code>为<code>true</code>是逆时针，否则为顺时针</li>
</ul>
</li>
<li><p><code>arcTo(x1,y1,x2,y2,radius)</code><br>从坐标<code>(x1,y1)</code>到坐标<code>(x2,y2)</code>以半径 radius 画一段圆弧，再以直线连接两个控制点。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    let endAngle = (Math.PI / 180) * 360;</span><br><span class="line">    ctx.arc(30, 30, 20, 0, endAngle);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.closePath();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(60, 20); // 创建开始点</span><br><span class="line">    ctx.lineTo(100, 20); // 创建水平线</span><br><span class="line">    ctx.arcTo(150, 20, 150, 70, 50); // 创建弧</span><br><span class="line">    ctx.lineTo(150, 100); // 创建垂直线</span><br><span class="line">    ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img3.png" alt="圆弧"></p>
<p><strong>贝塞尔曲线</strong></p>
<ul>
<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code><br>二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点</li>
<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code><br>三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点一，<code>x,y</code>为结束点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 25);</span><br><span class="line">    ctx.quadraticCurveTo(25, 25, 25, 62.5);</span><br><span class="line">    ctx.quadraticCurveTo(20, 130, 75, 130);</span><br><span class="line">    ctx.quadraticCurveTo(75, 160, 65, 160)</span><br><span class="line">    ctx.quadraticCurveTo(80, 160, 100, 130)</span><br><span class="line">    ctx.quadraticCurveTo(160, 130, 150, 62.5)</span><br><span class="line">    ctx.quadraticCurveTo(150, 20, 75, 25)</span><br><span class="line">    ctx.stroke()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img4.png" alt="二次贝塞尔"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 40);</span><br><span class="line">    ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);</span><br><span class="line">    ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5)</span><br><span class="line">    ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);</span><br><span class="line">    ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);</span><br><span class="line">    ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);</span><br><span class="line">    ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img5.png" alt="三次贝塞尔"></p>
<h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3><p>返回一个初始化的 Path2D 对象，参数可以是一个路径或 SVG path 数据的字符串，就是创建参数的副本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Path2D();</span><br><span class="line">new Path2D(path); //克隆Path对象</span><br><span class="line">new Path2D(svg);  //从svg建立Path对象</span><br></pre></td></tr></table></figure>
<p><code>path2D.addPath(path[,transform])</code>也可以给对象添加新路径或变化矩阵。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let rectangle = new Path2D()</span><br><span class="line">    rectangle.rect(10, 10, 50, 50)</span><br><span class="line"></span><br><span class="line">    let circle = new Path2D()</span><br><span class="line">    circle.moveTo(125, 35);</span><br><span class="line">    circle.arc(100, 35, 25, 0, 2 * Math.PI)</span><br><span class="line">    ctx.stroke(rectangle);</span><br><span class="line">    ctx.fill(circle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img6.png" alt="Path2D"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</span><br><span class="line">    ctx.stroke(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img7.png" alt="Path2D1"></p>
<h3 id="样式和颜色"><a href="#样式和颜色" class="headerlink" title="样式和颜色"></a>样式和颜色</h3><ul>
<li><p>填充颜色<br><code>fillStyle=color</code>，设置图形的填充颜色</p>
</li>
<li><p>轮廓颜色<br><code>strokeStyle=color</code>，设置图形轮廓的颜色<br>默认填充颜色和轮廓颜色都是黑色（<code>&#39;#000&#39;</code>/<code>&#39;black&#39;</code>/<code>rgba(0,0,0,1)</code>）的。<code>color</code>可以是颜色值，渐变对象或图案对象。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;,0)`;</span><br><span class="line">            ctx.fillRect(j * 25, i * 25, 25, 25)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img8.png" alt="fillStyle"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.strokeStyle = `rgb(0,$&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;)`;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.arc(12.5 + j * 25, 12.5 + i * 25, 10, 0, 2 * Math.PI, true);</span><br><span class="line">            ctx.stroke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img9.png" alt="strokeStyle"></p>
<ul>
<li>透明度<br><code>globalAlpha=transparent</code><br>设置整个<code>canvas</code>里所有图形的透明度，范围是 0.0(完全透明)到 1.0(完全不透明)。<br>同样可以设置<code>strokeStyle</code>或<code>fillStyle</code>的值为透明度（<code>rgba</code>）的颜色</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">  // 画背景</span><br><span class="line">  ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">  ctx.fillRect(0,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#6C0&apos;;</span><br><span class="line">  ctx.fillRect(75,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#09F&apos;;</span><br><span class="line">  ctx.fillRect(0,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#F30&apos;;</span><br><span class="line">  ctx.fillRect(75,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#FFF&apos;;</span><br><span class="line"></span><br><span class="line">  // 设置透明度值</span><br><span class="line">  ctx.globalAlpha = 0.2;</span><br><span class="line"></span><br><span class="line">  // 画半透明圆</span><br><span class="line">  for (var i=0;i&lt;7;i++)&#123;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(75,75,10+10*i,0,Math.PI*2,true);</span><br><span class="line">      ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img11.png" alt="globalAlpha"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    //背景</span><br><span class="line">    ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">    ctx.fillRect(0, 0, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#6C0&quot;;</span><br><span class="line">    ctx.fillRect(0, 50, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;;</span><br><span class="line">    ctx.fillRect(0, 100, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#F30&quot;;</span><br><span class="line">    ctx.fillRect(0, 150, 220, 50);</span><br><span class="line">    ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line"></span><br><span class="line">    //画透明度圆</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgba(255,255,255,$&#123;i*0.1&#125;)`;</span><br><span class="line">            ctx.fillRect(10 + i * 20, j * 50, 20, 50)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img10.png" alt="rgba"></p>
<ul>
<li><p>线型 line styles</p>
<ul>
<li><p><code>lineWidth=value</code>，设置线条宽度，默认为 1.0，必须为正数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(5 + i * 15, 5);</span><br><span class="line">        ctx.lineWidth = i + 1;</span><br><span class="line">        ctx.lineTo(5 + i * 15, 100);</span><br><span class="line">        ctx.stroke()</span><br><span class="line">        ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img12.png" alt="线宽"></p>
</li>
<li><p><code>lineCap=type</code>，设置线条末端样式</p>
<ul>
<li><code>butt</code>：默认，方头与辅助线齐平</li>
<li><code>round</code>：圆头，半径为宽度的一半</li>
<li><code>square</code>：方头，端点处加上了等宽且高度为一半线宽的方块。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      let lineCap = [&apos;butt&apos;, &apos;round&apos;, &apos;square&apos;];</span><br><span class="line">      //辅助线</span><br><span class="line">      ctx.strokeStyle = &apos;#09f&apos;;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.moveTo(10, 10);</span><br><span class="line">      ctx.lineTo(140, 10);</span><br><span class="line">      ctx.moveTo(10, 140);</span><br><span class="line">      ctx.lineTo(140, 140);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      //线条</span><br><span class="line">      ctx.strokeStyle = &apos;black&apos;;</span><br><span class="line">      for (let i = 0; i &lt; lineCap.length; i++) &#123;</span><br><span class="line">          ctx.lineWidth = 15;</span><br><span class="line">          ctx.lineCap = lineCap[i];</span><br><span class="line">          ctx.beginPath();</span><br><span class="line">          ctx.moveTo(30 + 40 * i, 10);</span><br><span class="line">          ctx.lineTo(30 + 40 * i, 140);</span><br><span class="line">          ctx.stroke();</span><br><span class="line">          ctx.closePath()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img13.png" alt="线头"></p>
<ul>
<li><code>lineJoin=type</code>，设定线条与线条间结合处的样式<ul>
<li><code>round</code>，</li>
<li><code>bevel</code>，</li>
<li><code>miter</code>，默认</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let lineJoin = [&apos;round&apos;, &apos;bevel&apos;, &apos;miter&apos;];</span><br><span class="line">    for (let i = 0; i &lt; lineJoin.length; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.lineWidth = 15;</span><br><span class="line">        ctx.lineJoin = lineJoin[i];</span><br><span class="line">        ctx.moveTo(20, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(70, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(120, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(170, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(220, 20 + i * 50);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.closePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img14.png" alt="交接处"></p>
<ul>
<li><code>miterLimit=value</code>，限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li>
<li><code>getLineDash()</code>，返回一个包含当前虚线的样式，长度为非负偶数的数组。</li>
<li><code>setLineDash(segments)</code>，设置当前虚线样式。</li>
<li><code>lineDashOffset=value</code>，设置虚线样式的起始偏移量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var offset = 0;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let my_canvas = document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">    if (my_canvas.getContext) &#123;</span><br><span class="line">        let ctx = my_canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        ctx.clearRect(0, 0, my_canvas.width, my_canvas.height);</span><br><span class="line">        ctx.setLineDash([4, 2]); //实线长度，空线长度</span><br><span class="line">        ctx.lineDashOffset = -offset;</span><br><span class="line">        ctx.strokeRect(10, 10, 100, 100);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //不支持canvas</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function march() &#123;</span><br><span class="line">    offset++;</span><br><span class="line">    if (offset &gt; 16) &#123;</span><br><span class="line">        offset = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">    setTimeout(march, 50);</span><br><span class="line">&#125;</span><br><span class="line">march();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img15.png" alt="蚂蚁线"></p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ul>
<li><code>createLinearGradient(x1, y1, x2, y2)</code><br>渐变起点（x1,y1）终点（x2,y2);</li>
<li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code><br>定义两个圆：一个是小圆，是外面大圆的反光，以（x1,y1）为圆点，r1 为圆心，另一个以（x2,y2）为圆心，r2 为半径。</li>
<li><code>gradient.addColorStop(position, color)</code><br>给创建的渐变对象<code>gradient</code>上色，<br><code>position</code>：渐变颜色的所在位置，[0.0, 1.0]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let linegrad = ctx.createLinearGradient(0, 0, 0, 150);</span><br><span class="line">    linegrad.addColorStop(0, &apos;#00ABEB&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#fff&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#26C000&apos;);</span><br><span class="line">    linegrad.addColorStop(1, &apos;#fff&apos;);</span><br><span class="line">    let linegrad1 = ctx.createLinearGradient(0, 50, 0, 95);</span><br><span class="line">    linegrad1.addColorStop(0.5, &apos;#000&apos;);</span><br><span class="line">    linegrad1.addColorStop(1, &quot;rgba(0,0,0,0)&quot;)</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = linegrad;</span><br><span class="line">    ctx.strokeStyle = linegrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.strokeRect(50, 50, 50, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一是背景渐变，<br>第二种渐变不是从 0.0 开始的，所以 0-0.5 都是黑色的。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img16.png" alt="线性渐变色"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let radgrad = ctx.createRadialGradient(45, 55, 10, 52, 50, 30);</span><br><span class="line">    radgrad.addColorStop(0, &apos;#47d30C&apos;);</span><br><span class="line">    radgrad.addColorStop(0.9, &apos;#019F62&apos;);</span><br><span class="line">    radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);</span><br><span class="line"></span><br><span class="line">    let radgrad1 = ctx.createRadialGradient(95, 15, 15, 102, 20, 40);</span><br><span class="line">    radgrad1.addColorStop(0, &apos;#00C9FF&apos;)</span><br><span class="line">    radgrad1.addColorStop(0.8, &apos;#00B5E2&apos;)</span><br><span class="line">    radgrad1.addColorStop(1, &apos;rgba(0,201,255,0)&apos;);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img17.png" alt="镜像渐变色"></p>
<h3 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h3><ul>
<li><code>createPattern(image,type)</code><ul>
<li><code>image</code>：是一个<code>image</code>对象的引用，或另一个<code>canvas</code>对象。</li>
<li><code>type</code>：<code>repeat</code>，<code>repeat-x</code>,<code>repeat-y</code>,<code>no-repeat</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        //创建图案</span><br><span class="line">        let ptrn = ctx.createPattern(img, &apos;repeat&apos;);</span><br><span class="line">        ctx.fillStyle = ptrn;</span><br><span class="line">        ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img18.png" alt="图片"></p>
<h3 id="阴影-shadows"><a href="#阴影-shadows" class="headerlink" title="阴影 shadows"></a>阴影 shadows</h3><ul>
<li><code>shadowOffsetX=float</code></li>
<li><code>shadowOffsetY=float</code><br><code>shadowOffsetX</code> 和 <code>shadowOffsetY</code> 用来设定阴影在<code>X</code>和 <code>Y</code>轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li>
<li><code>shadowBlur=float</code><br>用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li>
<li><p><code>shadowColor=color</code><br>阴影颜色，默认是全透明的黑色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.shadowOffsetX = 2;</span><br><span class="line">    ctx.shadowOffsetY = 2;</span><br><span class="line">    ctx.shadowBlur = 2;</span><br><span class="line">    ctx.shadowColor = &quot;rgba(255,0,0,0.5)&quot;;</span><br><span class="line"></span><br><span class="line">    ctx.font = &apos;20px times New Roman&apos;;</span><br><span class="line">    ctx.fillStyle = &quot;black&quot;;</span><br><span class="line">    ctx.fillText(&apos;Sample String&apos;, 5, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/23/html5-canvas基础/img19.png" alt="文字阴影"></p>
<h3 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h3><p>用<code>fill</code>,<code>clip</code>,<code>isPointinPath</code>填充，可以使用以下填充规则：</p>
<ul>
<li><code>nonzero</code>：non-zero winding rule,默认值</li>
<li><code>evenodd</code>：even-odd winding rule，颜色间隔出现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(50, 50, 50, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 30, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 10, 0, Math.PI * 2);</span><br><span class="line">    ctx.fill(&apos;evenodd&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img20.png" alt="填充规则"></p>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul>
<li><code>fillText(text,x,y[,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选。</li>
<li><p><code>strokeText(text, x, y [,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.font = &apos;48px serif&apos;</span><br><span class="line">    ctx.fillText(&apos;fillText&apos;, 10, 50);</span><br><span class="line">    ctx.strokeText(&apos;strokeText&apos;, 10, 90)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img21.png" alt="文本"></p>
<p><strong>文本样式</strong></p>
<ul>
<li><code>font=value</code><br>与 css 属性相同，默认<code>10px sans-serif</code></li>
<li><p><code>textAlign=value</code> , 文本对齐方式</p>
<ul>
<li><code>start</code>默认</li>
<li><code>end</code></li>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>center</code></li>
</ul>
</li>
<li><p><code>textBaseline=value</code>，基线对齐选项</p>
<ul>
<li><code>top</code></li>
<li><code>hanging</code></li>
<li><code>middle</code></li>
<li><code>alphabetic</code>默认</li>
<li><code>ideographic</code></li>
<li><code>bottom</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">      ctx.font = &apos;28px serif&apos;</span><br><span class="line">      ctx.moveTo(0, 40);</span><br><span class="line">      ctx.lineTo(650, 40);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      ctx.textBaseline = &apos;top&apos;</span><br><span class="line">      ctx.fillText(&apos;top&apos;, 10, 40);</span><br><span class="line">      ctx.textBaseline = &apos;middle&apos;</span><br><span class="line">      ctx.fillText(&apos;middle&apos;, 60, 40)</span><br><span class="line">      ctx.textBaseline = &apos;hanging&apos;</span><br><span class="line">      ctx.fillText(&apos;hanging&apos;, 160, 40)</span><br><span class="line">      ctx.textBaseline = &apos;alphabetic&apos;</span><br><span class="line">      ctx.fillText(&apos;alphabetic&apos;, 270, 40)</span><br><span class="line">      ctx.textBaseline = &apos;ideographic&apos;</span><br><span class="line">      ctx.fillText(&apos;ideographic&apos;, 410, 40)</span><br><span class="line">      ctx.textBaseline = &apos;bottom&apos;</span><br><span class="line">      ctx.fillText(&apos;bottom&apos;, 560, 40)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img22.png" alt="基线"></p>
<ul>
<li><p><code>direction=value</code>,文本方向</p>
<ul>
<li><code>ltr</code></li>
<li><code>rtl</code></li>
<li><code>inherit</code> 默认</li>
</ul>
</li>
<li><p>预测量文本宽度</p>
</li>
</ul>
<p><code>measureText()</code><br>返回有个<code>TextMwtrics</code>对象的宽度、所在像素</p>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><h4 id="获取图像源"><a href="#获取图像源" class="headerlink" title="获取图像源"></a>获取图像源</h4><ul>
<li><p>获得需要绘制的图片</p>
<ul>
<li><code>HTMLImageElement</code><br>由<code>Image()</code>函数构造出来的元素，或者<code>&lt;img&gt;</code>元素</li>
<li><code>HTMLVideoElement</code><br><code>&lt;video&gt;&lt;/video&gt;</code>元素，从视频中抓取当前帧作为一个图像</li>
<li><code>HTMLCanvasElement</code><br>使用另外一个<code>&lt;canvas&gt;&lt;/canvas&gt;</code>元素作为图片源</li>
<li><code>ImageBitmap</code><br>高性能位图，可以低延迟的绘制。，它可以从上述的所有源以及其它几种源中生成。</li>
</ul>
</li>
<li><p>使用相同页面内的图片</p>
<p>获取当前页面的图片引用：</p>
<ul>
<li><code>document.images</code>集合</li>
<li><code>document.getElementsByTagName()</code></li>
<li><code>document.getElementById()</code></li>
</ul>
</li>
<li><p>使用其他域名下的图片</p>
<p>如果图片允许跨域访问，可以正常渲染<code>canvas</code>，如果图片不允许跨域访问，会污染当前<code>canvas</code>.</p>
</li>
<li><p>使用其他 canvas 元素</p>
<p>获取 canvas 元素</p>
<ul>
<li><code>document.getElementsByTagName()</code></li>
<li><code>document.getElementById()</code></li>
</ul>
</li>
<li><p>由零开始创建图像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.onload=function()&#123;</span><br><span class="line">    //执行drawImage语句</span><br><span class="line">&#125;</span><br><span class="line">img.src=&apos;img.png&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>data.url</code>方式嵌入图像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img.src = &apos;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用视频帧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getMyVideo() &#123;</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">    return document.getElementById(&apos;myvideo&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><ul>
<li><p><code>drawImage(image,x,y)</code></p>
<ul>
<li><code>image</code>就是用上面的方法获取的图片源，SVG 图像必须在 <code>&lt;svg&gt;</code> 根指定元素的宽度和高度。</li>
<li><code>x</code>,<code>y</code>，绘制图片左上角在画布中的起始坐标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(30, 96);</span><br><span class="line">        ctx.lineTo(70, 66);</span><br><span class="line">        ctx.lineTo(102, 76);</span><br><span class="line">        ctx.lineTo(170, 15);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>drawImage(image,x,y,width,height)</code>;<br><code>width</code>和<code>height</code>用来控制当前<code>canvas</code>画入时应该缩放的大小</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                ctx.drawImage(img, j * 100, i * 80, 100, 80);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)</code><br>第一个参数同上还是图片源，<br>后面 8 个参数，前四个参数定义图像源的切片位置和大小，后四个定义切片的目标显示的位置和大小。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img23.jpg" alt="切片"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 300, 100, 1000, 1100, 10, 10, 200, 200)</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染 frame</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Draw frame</span><br><span class="line">  ctx.drawImage(document.getElementById(&apos;frame&apos;),0,0);</span><br></pre></td></tr></table></figure>
<ul>
<li>控制图像的缩放行为<br><code>mozImageSmoothingEnabled</code>,默认为<code>true</code>，为<code>false</code>时图像不会平滑的缩放。<br><code>ctx.mozImageSmoothingEnabled = false;</code></li>
</ul>
<h3 id="变形-Transformation"><a href="#变形-Transformation" class="headerlink" title="变形 Transformation"></a>变形 Transformation</h3><h4 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h4><ul>
<li><strong><code>save()</code></strong> 保存画布的现在的状态</li>
<li><strong><code>restore()</code></strong><br>恢复<code>canvas</code>状态。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 500, 500);</span><br><span class="line">    ctx.save(); //存储黑色矩形</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;</span><br><span class="line">    ctx.fillRect(50, 50, 400, 400)</span><br><span class="line"></span><br><span class="line">    ctx.save(); //存储蓝色矩形</span><br><span class="line">    ctx.fillStyle = &apos;white&apos;;</span><br><span class="line">    ctx.globalAlpha = 0.5;</span><br><span class="line">    ctx.fillRect(100, 100, 300, 300)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复蓝色矩形</span><br><span class="line">    ctx.fillRect(150, 150, 200, 200)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复黑色矩形</span><br><span class="line">    ctx.fillRect(200, 200, 100, 100)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img24.png" alt="保存状态"></p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul>
<li><strong><code>translate(x, y)</code></strong><br><code>x</code>为左右偏移量，<code>y</code>为上下偏移量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;51*i&#125;,$&#123;255-51*i&#125;,255)`;</span><br><span class="line">            ctx.translate(10 + j * 50, 10 + i * 50);</span><br><span class="line">            ctx.fillRect(0, 0, 25, 25);</span><br><span class="line">            ctx.restore()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img25.png" alt="移动"></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li><strong><code>rotate(angle)</code></strong><br>角度<code>（angle）</code>是顺时针方向，以弧度为单位。<br>旋转的中心始终是<code>canvas</code>的原点<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img26.png" alt="旋转"></li>
</ul>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><strong><code>scale(x,y)</code></strong><br><code>x</code>为水平缩放，<code>y</code>为垂直缩放<br><code>x,y</code>都是实数，比 1 小会缩小图形，比 1 大会放大图片，默认为 1。<br>画布初始情况下， 是以左上角坐标为原点的第一象限。如果为负实数， <code>scale(-1,1)</code>以<code>y</code>轴作为对称轴镜像反转,<code>scale(1,-1)</code>以<code>x</code>轴作为对称轴镜像反转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    // //放大</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.scale(10, 3);</span><br><span class="line">    ctx.fillRect(1, 10, 10, 10);</span><br><span class="line">    ctx.restore();</span><br><span class="line"></span><br><span class="line">    // //镜像</span><br><span class="line">    ctx.scale(-1, 1);</span><br><span class="line">    ctx.font = &apos;48px serif&apos;;</span><br><span class="line">    ctx.fillText(&apos;MDN&apos;, -135, 120)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img27.png" alt="缩放"></p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><ul>
<li><p><strong><code>transform(a,b,c,d,e,f)</code></strong><br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：$\left[ \begin{array}{ccc} a &amp; c &amp; e \ b &amp; d &amp; f \ 0 &amp; 0 &amp; 1 \end{array} \right]$</p>
<ul>
<li><code>a(m11)</code>: 水平方向的缩放</li>
<li><code>b(m12)</code>: 水平方向的倾斜偏移</li>
<li><code>c(m21)</code>: 竖直方向的倾斜偏移</li>
<li><code>d(m22)</code>: 竖直方向的缩放</li>
<li><code>e(m31)</code>: 水平方向的移动</li>
<li><code>f(m32)</code>: 竖直方向的移动</li>
</ul>
</li>
<li><p><strong><code>setTransform(a,b,c,d,e,f)</code></strong><br>将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。该方法是取消了当前变形,然后设置为指定的变形,一步完成。</p>
</li>
<li><strong><code>resetTransform()</code></strong><br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<code>ctx.setTransform(1, 0, 0, 1, 0, 0)</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let sin = Math.sin(Math.PI / 6);</span><br><span class="line">    let cos = Math.cos(Math.PI / 6);</span><br><span class="line">    ctx.translate(100, 100);</span><br><span class="line">    let c = 0;</span><br><span class="line">    for (let i = 0; i &lt;= 12; i++) &#123;</span><br><span class="line">        c = Math.floor(255 / 12 * i);</span><br><span class="line">        ctx.fillStyle = `rgb($&#123;c&#125;,$&#123;c&#125;,$&#123;c&#125;)`;</span><br><span class="line">        ctx.fillRect(0, 0, 100, 10);</span><br><span class="line">        ctx.transform(cos, sin, -sin, cos, 0, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.setTransform(-1, 0, 0, 1, 100, 100);</span><br><span class="line">    ctx.fillStyle = &apos;rgba(255,128,255,.5)&apos;;</span><br><span class="line">    ctx.fillRect(0, 50, 100, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img28.png" alt="转换"></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>globalCompositeOperation=type</code><br>设定新绘制图形与原图形的遮盖方式。<br>目标画布-已有，新图像</p>
<ul>
<li><code>source-over</code>：默认，在现有画布上下文之上绘制新图形。</li>
<li><code>source-in</code>：新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。</li>
<li><code>source-out</code>： 在不与现有画布内容重叠的地方绘制新图形，重叠部分是透明的。</li>
<li><code>source-atop</code>： 新图形只在与现有画布内容重叠的地方绘制，原有画布非重叠部分不变。</li>
<li><code>destination-over</code>： 在现有的画布内容后面绘制新的图形。</li>
<li><code>destination-in</code>： 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。</li>
<li><code>destination-out</code>：现有内容保持在新图形不重叠的地方，其他地方透明。</li>
<li><code>destination-atop</code>：现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。</li>
<li><code>lighter</code>：两个重叠图形的颜色是通过颜色值相加来确定的。</li>
<li><code>copy</code>：只显示新图形。</li>
<li><code>xor</code>：图像中，那些重叠和正常绘制之外的其他地方是透明的。</li>
<li><code>multiply</code>：将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。</li>
<li><code>screen</code>：像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。</li>
<li><code>overlay</code>：<code>multiply</code>和<code>screen</code>的结合，原本暗的地方更暗，原本亮的地方更亮。</li>
<li><code>darken</code>：保留两个图层中最暗的像素。</li>
<li><code>lighten</code>：保留两个图层中最亮的像素。</li>
<li><code>color-dodge</code>：将底层除以顶层的反置。</li>
<li><code>color-burn</code>：将反置的底层除以顶层，然后将结果反过来。</li>
<li><code>hard-light</code>：屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。</li>
<li><code>soft-light</code>：用顶层减去底层或者相反来得到一个正值。</li>
<li><code>difference</code>：一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。</li>
<li><code>exclusion</code>：和 difference 相似，但对比度较低。<br>…</li>
</ul>
<h3 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h3><p><code>clip()</code>将当前正在构建的路径转换为当前的裁剪路径。<br>默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.translate(75, 75);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(0, 0, 60, 0, Math.PI * 2, true);</span><br><span class="line">    ctx.clip();</span><br><span class="line">    //画圆形背景</span><br><span class="line">    let lingrad = ctx.createLinearGradient(0, -75, 0, 75);</span><br><span class="line">    lingrad.addColorStop(0, &quot;#232256&quot;);</span><br><span class="line">    lingrad.addColorStop(1, &quot;#143778&quot;);</span><br><span class="line">    ctx.fillStyle = lingrad;</span><br><span class="line">    ctx.fillRect(-75, -75, 150, 150);</span><br><span class="line">    //画星星</span><br><span class="line">    for (let j = 1; j &lt; 50; j++) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line">        ctx.translate(75 - Math.floor(Math.random() * 150), 75 - Math.floor(Math.random() * 150));</span><br><span class="line">        drawStar(ctx, Math.floor(Math.random() * 4) + 2);</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawStar(ctx, r) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(r, 0);</span><br><span class="line">        for (let i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            ctx.rotate(Math.PI / 5);</span><br><span class="line">            if (i % 2 === 0) &#123;</span><br><span class="line">                ctx.lineTo((r / 0.525731) * 0.200811, 0)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.lineTo(r, 0)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.closePath();</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img29.png" alt="星星"></p>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
  </entry>
  <entry>
    <title>html5-音视频处理</title>
    <url>/2020/07/23/html5-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>html5 音视频标签使用</p>
<a id="more"></a>
<h3 id="音视频处理"><a href="#音视频处理" class="headerlink" title="音视频处理"></a>音视频处理</h3><ul>
<li><p>video</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">  &lt;source src=&apos;foo.ogg&apos; type=&apos;video/ogg&apos; /&gt;</span><br><span class="line">  &lt;source src=&apos;foo.mp4&apos; type=&apos;video/mp4&apos; /&gt;</span><br><span class="line">  浏览器不支持视频播放</span><br><span class="line">&lt;/video&gt;</span><br><span class="line">&lt;audio controls&gt;</span><br><span class="line">  &lt;source src=&quot;3.mp3&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.wav&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.ogg&quot;&gt;</span><br><span class="line">  浏览器不支持音频播放</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
<p>属性：</p>
<ul>
<li>width:宽度</li>
<li>height:高度</li>
<li>controls：播放控件</li>
<li>autoplay：视频加载完成后马上播放</li>
<li>loop：循环播放</li>
<li>muted：表示视频静音输出</li>
<li>poster：视频海报，用于在用户播放或跳帧之前展示，如果属性未指定，第一帧可用之前什么都不展示，之后第一帧就作为海报。</li>
<li>preload：预加载，<ul>
<li>none 不加载</li>
<li>auto (默认)自动（尽快加载完毕）</li>
<li>metadata 只加载除视频之外的信息（宽高）</li>
</ul>
</li>
</ul>
</li>
<li><p>audio<br>操作 DOM 方法</p>
<ul>
<li>play 开始播放</li>
<li>pause 暂停播放</li>
<li>error 媒体播放出错错误时触发</li>
<li>canPlayType(type)：查看浏览器是否支持这种文件格式的媒体文件。</li>
</ul>
</li>
</ul>
<p>操作 DOM 属性</p>
<ul>
<li>paused 是否处于暂停或者未播放状态</li>
<li>ended 是否已经结束播放</li>
<li>duration 返回媒体时长，秒为单位</li>
<li>currentTime 获取或设置媒体播放位置</li>
</ul>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
  </entry>
  <entry>
    <title>html5-语义化标签</title>
    <url>/2020/07/23/html5-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>html 语义化标签<br><a id="more"></a></p>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>元素分类：</p>
<ul>
<li><p>块级元素</p>
<ul>
<li>独占一行</li>
<li>可以设置宽高</li>
<li>不设置宽度时，继承父元素宽度</li>
<li><p>不设置高度时，就是本身内容的高度</p>
<p>常用：<code>div</code>,<code>p</code>,<code>h1...h6</code>,<code>ul</code>,<code>ol</code>,<code>dl</code>,<code>form</code>,<code>section</code>,<code>nav</code>,<code>aside</code><br>转换成块级元素：<code>display:block</code></p>
</li>
</ul>
</li>
<li><p>行内块元素</p>
<ul>
<li>和其他行内元素和行内块元素在一行</li>
<li><p>元素的 width，height，padding，margin 可以设置</p>
<p>常用：<code>img</code>,<code>input</code>,<br>转换成行内块元素：<code>display:inline-block</code>，<code>float:left/right</code>，<code>position:absolute/fixed</code></p>
</li>
</ul>
</li>
<li><p>行内元素</p>
<ul>
<li>和其他行内元素和行内块元素在一行</li>
<li>元素的宽度就是他包含的文字和图片的宽度，不可改变。</li>
<li>元素高度 height 设置无效，可以设置 line-height</li>
<li>margin,padding 的上下对布局无效，左右可以。</li>
<li><p>内联元素只能包含文本、内联元素、行内块元素</p>
<p>常用：<code>span</code>,<code>a</code>,<code>br</code>,<code>em</code>,<code>strong</code><br>转换成行内元素：<code>display:inline</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="重学前端——语义化标签"><a href="#重学前端——语义化标签" class="headerlink" title="重学前端——语义化标签"></a>重学前端——语义化标签</h3><ul>
<li><p>缩写 abbr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分隔线<br>hr - 表示故事走向的转变或话题的转变<br>border - 纯粹的视觉效果</p>
</li>
<li><p>注释<br>p 标签+class=’note’</p>
</li>
<li><p>加粗<br>strong 表示文本十分重要<br>em 表示强调，可以嵌套，越多层级 表示更大程度的强调</p>
</li>
<li><p>引用</p>
</li>
<li>blockquote 表示段落级引述内容，</li>
<li>q 表示行内的引述内容</li>
<li>cite 表示引述的作品名</li>
<li><p>时间 time</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;time datetime=&apos;2019-01-25&apos;&gt;25 Jan 2019&lt;/time&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文章中的图像<br>figure 用于表示与主文章相关的图像、照片等流内容<br>figcaption 照片图片的描述文字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">    &lt;img src=&apos;http://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E6%96%B0%E9%B2%9C%E4%BA%8B&amp;tn=SE_PclogoS_8whnvm25&amp;sa=ire_dl_gh_logo&amp;rsv_dl=igh_logo_pcs&apos;&gt;</span><br><span class="line">    &lt;figcaption&gt;百度logo&lt;/figcaption&gt;</span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 ghh<br>dfn 标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The &lt;dfn&gt;Internet&lt;/dfn&gt; is balalalal</span><br></pre></td></tr></table></figure>
</li>
<li><p>固定格式</p>
<p>samp 计算机输出<br>pre 格式不根据浏览变化<br>code 代码段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">    &lt;code&gt;&gt;</span><br><span class="line">        &amp;lt;html&amp;gt;</span><br><span class="line">            &amp;lt;head&amp;gt;</span><br><span class="line">            &amp;lt;/head&amp;gt;</span><br><span class="line">            &amp;lt;body&amp;gt;</span><br><span class="line">            &amp;lt;/body&amp;gt;</span><br><span class="line">        &amp;lt;/html&amp;gt;</span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
  </entry>
  <entry>
    <title>html5-表单元素</title>
    <url>/2020/07/23/html5-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>新增表单元素<br>兼容性存在问题，并且不同浏览器样式不同</p>
<a id="more"></a>
<h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><h3 id="新增输入类型"><a href="#新增输入类型" class="headerlink" title="新增输入类型"></a>新增输入类型</h3><p><strong><code>Input</code> 类型</strong></p>
<ul>
<li>email：电子邮件</li>
<li><p>tel：电话号码</p>
</li>
<li><p>url：网页的 url(需要 <code>http(s)://</code>)</p>
</li>
<li>search：搜索</li>
<li>range：数值控件。特定范围内的数值选择器</li>
<li>number：数字</li>
<li>date：日期，选取年、月、日</li>
<li>month：选取月、年</li>
<li>week：选取周和年</li>
<li>time：选取时间（小时和分钟）</li>
<li>datetime：选取时间、日、月、年（UTC 时间）</li>
<li>datetime-local：选取时间、日、月、年（本地时间）</li>
</ul>
<p>其中 range 和 number 还可以配合下面属性使用</p>
<ul>
<li>min：允许最小值</li>
<li>max：允许最大值</li>
<li>step：步数</li>
<li>value：默认值</li>
</ul>
<h3 id="新增表单元素"><a href="#新增表单元素" class="headerlink" title="新增表单元素"></a>新增表单元素</h3><ul>
<li><p>datalist<br>选择列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;url_list&quot;&gt;</span><br><span class="line">    &lt;option label=&quot;W3School&quot; value=&quot;http://www.W3School.com.cn&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>keygen<br>提供一种验证用户的可靠方法。<br>密钥对生成器，提价表单时，生成一个私钥和一个公钥。<br>私钥（private key）存储于客户端，公钥（public key）被发送到服务器，公钥用于之后验证用户的客户端证书。<br>目前浏览器不支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">  Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt;</span><br><span class="line">  Encryption: &lt;keygen name=&quot;security&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>output<br>用于不同类型的输出</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;output id=&apos;result&apos; onforminput=&apos;resCalc()&apos;&gt;&lt;/output&gt;</span><br></pre></td></tr></table></figure>
<h3 id="表单验证属性"><a href="#表单验证属性" class="headerlink" title="表单验证属性"></a>表单验证属性</h3><ol>
<li><p>pattern<br>属性确保值与正则表达式匹配<br>用于验证文本、链接、电话，邮件，密码等形式的输入元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">   &lt;label for=&quot;name&quot;&gt; Name: &lt;input type=&quot;text&quot; id=&quot;name&quot;</span><br><span class="line">     name=&quot;name&quot; pattern=&quot;^.* .*$&quot; /&gt;</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>确保用户输入两个名称，用空格分隔</p>
</li>
<li><p>min,max<br>适用范围、数字、日期、月、周、时间、本地时间等类型的输入元素</p>
</li>
</ol>
<ul>
<li>用于验范围或数字是否大于等于或小于等于设定值</li>
<li>用于验时间是否早于或晚于设定值</li>
</ul>
<ol start="3">
<li>required<br>是否必填</li>
<li>formnovalidate<br>禁用原生验证</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;email&quot;&gt; Email: &lt;input type=&quot;email&quot;</span><br><span class="line">        placeholder=&quot;user@mydomain.com&quot; required pattern=&quot;.*@mydomain.com$&quot;</span><br><span class="line">        id=&quot;email&quot; name=&quot;email&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;input type=&quot;submit&quot;</span><br><span class="line">      value=&quot;Save&quot; formnovalidate /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html5</category>
      </categories>
  </entry>
  <entry>
    <title>LESS</title>
    <url>/2020/07/21/LESS/</url>
    <content><![CDATA[<p>一些 less 的用法</p>
<a id="more"></a>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@link-color:#428bca;</span><br><span class="line">@link-color-hover:darken(@link-color, 10%);</span><br><span class="line">a&#123;</span><br><span class="line">    color:@link-color</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        color:@link-color-hover</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅可以使用变量存储属性值，还可以使用变量存储公用的 URL、选择器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.@(selector)&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    @&#123;property&#125;:#000;</span><br><span class="line">    background:url(&quot;@&#123;bgImg/test.png&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@selector:box;</span><br><span class="line">@bigImg:&quot;../img&quot;;</span><br><span class="line">@property:color</span><br></pre></td></tr></table></figure>
<h2 id="混合（Mixins）"><a href="#混合（Mixins）" class="headerlink" title="混合（Mixins）"></a>混合（<code>Mixins</code>）</h2><p><strong>1. 基本使用</strong><br>混合可以将一个定义好的<code>class A</code>轻松的引入到另一个<code>class B</code>中，从而简单实现<code>class B</code>继承 <code>class A</code>中的所有属性。我们还可以带参数地调用，就像使用函数一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是将<code>public</code>设定的样式属性复制一份到实际样式中。如果想要在编译完成后不输出<code>public</code>样式的结果，写法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//less</span><br><span class="line">.public()&#123;//-&gt;在选择器后面加上()就可以不编译这个样式了</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public; //如果public有子孙元素的样式，同样也会被复制过来</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. extend</strong><br>上面的方法是把<code>public</code>样式复制一遍，编译后的<code>CSS</code>还是会很大，可以使用<code>extend</code>避免这一点<br><strong>和原来的选择器共用一套样式，但要保证原来的选择器不加括号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    &amp;:extend(.public);</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public, nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><p>LESS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">    .navigation&#123;</span><br><span class="line">        font-size:12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .logo&#123;</span><br><span class="line">        width:300px;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            text-decoration:none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的 CSS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">&#125;</span><br><span class="line">#header .navigation&#123;</span><br><span class="line">    font-size:12px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo&#123;</span><br><span class="line">    width:300px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo:hover&#123;</span><br><span class="line">    text-decoration:none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数和运算"><a href="#函数和运算" class="headerlink" title="函数和运算"></a>函数和运算</h2><p>运算提供了加、减、乘、除操作。可以对属性值和颜色做运算，实现属性值之间的复杂关系。<br>任何数字、颜色或者变量都可以参与运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@base: 5%;</span><br><span class="line">@filter: @base * 2; //10%</span><br><span class="line">@other: @base + @filter; //15%</span><br><span class="line">color: #888/4; //#222</span><br><span class="line">@base-color:#111;</span><br><span class="line">background-color: @base-color+#111;//#222</span><br><span class="line">height: 100%/2 + @filter;//60%</span><br></pre></td></tr></table></figure>
<p>颜色运算函数，颜色会被转化为<code>HSL</code>色彩空间，然后在通道级别操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lighten(@color, 10%); //变亮10%</span><br><span class="line">darken(@color, 10%); //变暗10%</span><br></pre></td></tr></table></figure>
<p>数学函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">round(1.67); //2</span><br><span class="line">ceil(2.3);//3</span><br><span class="line">floor(2.6); //2</span><br></pre></td></tr></table></figure>
<h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><p>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@var:red;</span><br><span class="line">#page&#123;</span><br><span class="line">    @var:white;</span><br><span class="line">    #header&#123;</span><br><span class="line">        color:@var; //white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#footer&#123;</span><br><span class="line">    color:@var; //red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>响应式布局</title>
    <url>/2020/07/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>一个页面适配多种设备和多个屏幕</p>
<a id="more"></a>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p><code>viewport</code>，浏览器中用于呈现网页的区域，视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下。<br>手机端与<code>PC</code>端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。<code>iOS</code>, <code>Android</code> 基本都将这个视口分辨率设置为 980px。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&apos;viewport&apos; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>width=device-width</code>：视口为设备宽度，手机厂商设置或默认 980px</li>
<li><code>initial-scale=1.0</code>：初始化的视口大小为 1.0 倍</li>
<li><code>maxmum-scale=1.0</code>：最大的倍数是 1.0 倍</li>
<li><code>user-scalable=no</code>：不允许缩放视口</li>
</ul>
<h2 id="手机浏览器内核"><a href="#手机浏览器内核" class="headerlink" title="手机浏览器内核"></a>手机浏览器内核</h2><ul>
<li>微软 <code>Trident</code></li>
<li>火狐 <code>Gecko</code></li>
<li>开源内核 <code>Webkit</code></li>
<li>Opera <code>Presto</code><br>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器兼容前缀</span><br><span class="line">-ms-</span><br><span class="line">-moz-</span><br><span class="line">-o-</span><br><span class="line">-webkit-</span><br></pre></td></tr></table></figure>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>针对特定的设备或条件为网页应用特定的 css 样式。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>媒体查询外面写的第一条规则是基本的样式，适用于任何设备，然后为不同的视口，不同能力的设备，添加不同效果。<br>需要配合视口使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: grey;</span><br><span class="line"> &#125;</span><br><span class="line">@media screen and (min-width:1200px)&#123; //宽度大于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: pink;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> @media screen and (min-width:700px) and (max-width:1200px)&#123; //宽度大于700像素小于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:700px)&#123;//宽度小于700像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>screen</code>表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号匹配可能性。</p>
<h2 id="rem-响应式布局"><a href="#rem-响应式布局" class="headerlink" title="rem 响应式布局"></a>rem 响应式布局</h2><p>rem:当前页面中元素的<code>REM</code>单位的样式值都是针对于<code>HTML</code>元素的<code>font-size</code>的值进行动态计算的。<br>em:表示当前父元素的字号的倍数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;div style=&apos;font-size:10px&apos;&gt;</span><br><span class="line">    &lt;span&gt;box1&lt;/span&gt;</span><br><span class="line">    &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">        &lt;span&gt;box2&lt;/span&gt;</span><br><span class="line">        &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">            &lt;span&gt;box3&lt;/span&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">                    &lt;span&gt;box4&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/20/响应式布局/img1.png" alt="em"></p>
<p><code>rem</code> 可以和媒体查询配合实现响应式布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (min-width: 320px) &#123;</span><br><span class="line">    html &#123;font-size: 14px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 360px) &#123;</span><br><span class="line">    html &#123;font-size: 16px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 400px) &#123;</span><br><span class="line">    html &#123;font-size: 18px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>分比布局也叫作流式布局、弹性盒布局。<br>使用百分比设置<code>width</code>，<code>height</code>，<code>padding</code>，<code>margin</code></p>
<h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>如果移动端和 PC 端公用一套代码，建议使用流式布局。<br><strong>如何做一个 REM 响应式布局</strong></p>
<ol>
<li>从 <code>UI</code> 设计师拿到<code>PSD</code>设计稿,然后在样式中给 HTML 设定一个<code>font-size</code>的值，我们一般都设置一个方便后面计算的值，例如：<code>100px</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px; //1rem=100px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>首先按照设计稿的尺寸来写样式，把得到的像素值除以<code>100</code>计算出对应的<code>REM</code>值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">margin:0 0.2rem;</span><br><span class="line">height:3rem;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据当前屏幕宽度和设计稿的宽度来计算出<code>font-size</code>的值。<br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个<code>font-size</code>的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其<code>font-size</code>应该设置为多少。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">375/640*100-&gt;font-size=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure>
<p>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的<code>font-size</code>值应该是多少，如果<code>font-size</code>的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小。可以通过以下这段代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//html部分</span><br><span class="line">&lt;section id=&quot;main&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">//js部分</span><br><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    var oMain=document.getElementById(main&quot;)；</span><br><span class="line">    if(winW&gt;desW)&#123;</span><br><span class="line">        oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">        oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>布局</category>
      </categories>
  </entry>
  <entry>
    <title>CORS-预检请求</title>
    <url>/2020/07/17/CORS-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>CORS 的预检请求<br>CORS 跨域的前后端配置<br>简单请求和非简单请求</p>
<a id="more"></a>
<h2 id="CORS-预检请求"><a href="#CORS-预检请求" class="headerlink" title="CORS 预检请求"></a>CORS 预检请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p><strong>条件(同时满足)</strong><br>请求方法：HEAD,GET,POST<br>请求头：Accept,Accept-Language,Content-Language,Last-Event-ID,Content-Type:只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
<p><strong>验证过程</strong><br>客户端发送简单请求，会在请求头增加一个 Origin 头信息，指定该请求发送方的域，提交给服务器用于判断是否接受该跨域请求。<br>两种情况下服务器会接受该跨域:</p>
<ol>
<li><code>Access-Control-Allow-Origin:*</code><br>如果服务器同意该跨域访问，正常返回数据，并在响应头中携带添加<code>Access-Control-Allow-Origin</code> 头信息。</li>
<li><code>Access-Control-Allow-Origin</code>设置的允许跨域的地址中包含请求的<code>Origin</code>。</li>
</ol>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>不满足上面简单请求规则的请求都是非简单请求。比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。<br><strong>避免多次请求，axios 的 post 封装为简单请求</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import QS from &quot;qs&quot;;</span><br><span class="line">export function post(url: string, data: any) &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    url,</span><br><span class="line">    data: QS.stringify(data),</span><br><span class="line">    headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后端通过 app.use(bodyParser())将 req.body 解析为对象</p>
<h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>当浏览器检测到需要发送一个非简单的跨域请求时，浏览器会拦截该请求，发送一个预检请求到服务器，旨在询问服务器是否同意这个非简单的跨域请求，服务器通过返回指定内容表示是否同意。</p>
<ul>
<li><p>成功的预检请求响应<br><img src="/2020/07/17/CORS-预检请求/img4.jpg" alt="跨域请求成功3"></p>
<ul>
<li>Access-Control-Allow-Credentials:是否携带 cookie</li>
<li>Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支 持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li>
<li>Access-Control-Allow-Headers<br>如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</li>
</ul>
</li>
</ul>
<p>预检通过<br>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p>
<h3 id="完整的复杂请求例子"><a href="#完整的复杂请求例子" class="headerlink" title="完整的复杂请求例子"></a>完整的复杂请求例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">document.cookie = &apos;name=xiamen&apos; // cookie不能跨域</span><br><span class="line">xhr.withCredentials = true // 前端设置是否带cookie</span><br><span class="line">xhr.open(&apos;PUT&apos;, &apos;http://localhost:4000/getData&apos;, true)</span><br><span class="line">xhr.setRequestHeader(&apos;name&apos;, &apos;xiamen&apos;)</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(xhr.response)</span><br><span class="line">      //得到响应头，后台需设置Access-Control-Expose-Headers</span><br><span class="line">      console.log(xhr.getResponseHeader(&apos;name&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let express = require(&apos;express&apos;)</span><br><span class="line">let app = express()</span><br><span class="line">let whitList = [&apos;http://localhost:3000&apos;] //设置白名单</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  let &#123;origin&#125; = req.headers;</span><br><span class="line">  if (whitList.includes(origin)) &#123;</span><br><span class="line">    // 设置哪个源可以访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, origin)</span><br><span class="line">    // 允许携带哪个头访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;)</span><br><span class="line">    // 允许哪个方法访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class="line">    // 允许携带cookie</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true)</span><br><span class="line">    // 预检的存活时间</span><br><span class="line">    res.setHeader(&apos;Access-Control-Max-Age&apos;, 6)</span><br><span class="line">    // 允许返回的头</span><br><span class="line">    res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;)</span><br><span class="line">    if (req.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">      res.end() // OPTIONS请求不做任何处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(&apos;/getData&apos;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.setHeader(&apos;name&apos;, &apos;jw&apos;) //返回一个响应头，后台需设置</span><br><span class="line">  res.end(&apos;我不爱你&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&apos;/getData&apos;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&apos;我不爱你&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(4000)</span><br></pre></td></tr></table></figure>
<p>cookie 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path：指定 cookie 影响到的路径</span><br><span class="line">expires: 指定时间格式</span><br><span class="line">maxAge：指定 cookie 什么时候过期</span><br><span class="line">secure：当 secure 值为 true 时，在 HTTPS 中才有效；反之，cookie 在 HTTP 中是有效。</span><br><span class="line">httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。设置为true可以避免被 xss 攻击拿到 cookie</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
  </entry>
  <entry>
    <title>跨域解决方案</title>
    <url>/2020/07/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>什么是跨域，以及有哪几种跨域方式<br><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">参考</a></p>
<a id="more"></a>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>浏览器同源策略，是浏览器最核心和最基本的安全功能，如果缺少同源策略，浏览器很容易受到<code>XSS</code>、<code>CSRF</code>等攻击。<br>同源：协议相同，域名相同，端口相同<br>即便是两个不同的域名指向同一 IP 地址，也是非同源的。<br><img src="/2020/07/17/跨域解决方案/img5.png" alt="同源"><br><strong>同源策略限制内容有：</strong></p>
<ul>
<li><code>Cookie</code>,<code>LocalStorage</code>,<code>indexDB</code> 等存储性内容</li>
<li><code>DOM</code>节点</li>
<li><code>AJAX</code>请求</li>
</ul>
<p><strong>允许跨域加载资源的三个标签：</strong></p>
<ul>
<li><code>&lt;img src=XXX/&gt;</code></li>
<li><code>&lt;link href=XXX/&gt;</code></li>
<li><code>&lt;script src=XXX/&gt;</code></li>
</ul>
<h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。</strong> 不同域之间相互请求资源，就算作“跨域”。</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th>是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http://www.a.com/a.js</code> <code>http://www.a.com/b.js</code></td>
<td>同一域名下</td>
<td>允许</td>
</tr>
<tr>
<td><code>http://www.a.com/lab/a.js</code> <code>http://www.a.com/script/b.js</code></td>
<td>同一域名，不同文件夹</td>
<td>允许</td>
</tr>
<tr>
<td><code>http://www.a.com:8000/a.js</code> <code>http://www.a.com/b.js</code></td>
<td>同一域名，不同端口</td>
<td>不允许</td>
</tr>
<tr>
<td><code>http://www.a.com/a.js</code> <code>https://www.a.com/b.js</code></td>
<td>同一域名，不同协议</td>
<td>不允许</td>
</tr>
<tr>
<td><code>http://www.a.com/a.js</code> <code>http://10.11.12/b.js</code></td>
<td>域名和域名对应的 IP</td>
<td>不允许</td>
</tr>
<tr>
<td><code>http://www.a.com/a.js</code> <code>http://script.a.com/b.js</code></td>
<td>一级域名相同，二级域名不同</td>
<td>不允许</td>
</tr>
<tr>
<td><code>http://www.a.com/a.js</code> <code>http://a.com/b.js</code></td>
<td>一级域名相同，二级域名不同</td>
<td>不允许（cookie 也不会允许访问）</td>
</tr>
<tr>
<td><code>http://www.a.com/a.js</code> <code>http://www.b.com/b.js</code></td>
<td>不同主域名</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p><strong>特别说明</strong></p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的。</li>
<li>在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。</li>
</ul>
<p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</strong><br>通过表单的方式可以发起跨域请求，为什么<code>Ajax</code>就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，<code>Ajax</code>可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 <code>CSRF</code>，因为请求毕竟是发出去了。</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。然后在 <code>src</code>中函数会立即执行。因此需要服务器的支持才可以。</p>
<h4 id="JSONP-和-AJAX-对比"><a href="#JSONP-和-AJAX-对比" class="headerlink" title="JSONP 和 AJAX 对比"></a>JSONP 和 AJAX 对比</h4><p>都是客户端向服务器端发送请求，从服务端获取数据。<br>AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优：兼容性好，可以用于解决主流浏览器的跨域数据访问的问题。<br>缺：仅支持<code>get</code>方法，具有局限性，不安全，可能会遭到<code>XSS</code>攻击。</p>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ul>
<li>声明一个回调函数<code>callFun</code>，函数名作为参数传递给服务器，形参就是要获取的数据</li>
<li>创建一个<code>script</code>标签，把跨域的 API 接口地址赋值给<code>script</code>的<code>src</code>属性，还要在地址中向服务器传递上一步创建的函数参数，比如<code>&lt;script src=&#39;http://192.168.0.1:8001/get_data?callback=callFun&#39;&gt;&lt;/script&gt;</code>；</li>
<li>服务器接收到请求后，获取请求中的 callback 函数名（<code>callFun</code>）拼接上返回的数据，比如<code>callFun({msg:&#39;返回数据&#39;})</code>；</li>
<li>服务器把返回值通过 HTTP 协议返回给客户端，客户端调用执行声明的回调函数，对返回的数据进行操作。</li>
</ul>
<p>封装 JSONP 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//index.html</span><br><span class="line">function jsonp(url, params, callback)&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        let script=document.createElement(&apos;script&apos;);</span><br><span class="line">        window[callback]=function(data)&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">            document.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        params=&#123;...params,callback&#125;;</span><br><span class="line">        let arrs=[];</span><br><span class="line">        for(let key in params)&#123;</span><br><span class="line">            arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">        &#125;</span><br><span class="line">        script.src=`$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;)&#125;`</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsonp(&#123;</span><br><span class="line">    url:&apos;http://localhost:8001/get_data&apos;,</span><br><span class="line">    params:&#123;msg:&apos;lalala&apos;&#125;,</span><br><span class="line">    callback:&apos;show&apos;</span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的请求相当于向<code>http://localhost:8001/get_data?msg=lalala&amp;callback=show</code></p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let express=require(&apos;express&apos;);</span><br><span class="line">let app= express();</span><br><span class="line">app.get(&apos;/get_data&apos;,function(req,res)&#123;</span><br><span class="line">    let &#123;msg,callback&#125;= req.query;</span><br><span class="line">    console.log(msg,callback); //&apos;lalala&apos; &apos;show&apos;</span><br><span class="line">    res.send(`$&#123;callback&#125;($&#123;msg&#125;)`)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(8001)</span><br></pre></td></tr></table></figure>
<h4 id="jQuery-的-jsonp-形式"><a href="#jQuery-的-jsonp-形式" class="headerlink" title="jQuery 的 jsonp 形式"></a>jQuery 的 jsonp 形式</h4><p>JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;http://localhost:8001/get_data&quot;,</span><br><span class="line">    dataType:&apos;jsonp&apos;,</span><br><span class="line">    type:&apos;get&apos;, //可省略</span><br><span class="line">    jsonCallback:&apos;show&apos;,//自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="line">    jsonp:&apos;callback&apos;,//传递函数名的形参callback=show,可省略</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>需要浏览器和后端同时支持，IE8 和 9 需要通过<code>XDomainRequest</code>来实现。<br>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。<br>服务端设置响应头 <code>Access-Control-Allow-Origin</code>配置：</p>
<ol>
<li><code>*</code>表示服务器设置任意域都同意<br><img src="/2020/07/17/跨域解决方案/img1.jpg" alt="跨域请求成功1"></li>
<li><p>设置允许一个跨域域名<br><strong>node</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:3000&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>koa2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin: function(ctx) &#123; //设置允许来自指定域名请求</span><br><span class="line">    return &apos;http://localhost:3000&apos;; //只允许http://localhost:3000这个域名的请求</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/17/跨域解决方案/img2.jpg" alt="跨域请求成功2"></p>
</li>
<li><p>设置允许多个跨域域名<br><strong>node</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://weipxiu.com,http://localhost:8001,http://localhost:3000&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>koa2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin: function (ctx) &#123;</span><br><span class="line">    //多个域</span><br><span class="line">    const whiteList = [&quot;http://weipxiu.com&quot;,&quot;http://localhost:8081&quot;,&quot;http://localhost:3000&quot;]; //可跨域白名单</span><br><span class="line">    let url = ctx.header.origin;</span><br><span class="line">    if (whiteList.includes(url)) &#123;</span><br><span class="line">    return url; //注意，这里域名末尾不能带/，否则不成功，所以在之前我把/通过substr干掉了</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;http://localhost:8001&quot;; //默认允许本地请求8001端口可跨域</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果服务器返回的信息中没有该字段信息，这个数据将会被浏览器拦截，无法到达请求方，浏览器并会报错。</p>
<p><img src="/2020/07/17/跨域解决方案/img3.png" alt="跨域请求成功3"></p>
</li>
</ol>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>解决以下问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间信息传递</li>
<li>页面与嵌套的<code>iframe</code>消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrigin,[transfer]);</span><br></pre></td></tr></table></figure>
<ul>
<li>message：将要发送到其他 window 的数据</li>
<li>targetOrigin：通过窗口的<code>origin</code>属性来指定哪些窗口能接收到消息事件，可以是<code>*</code>（表示无限制）或一个<code>URL</code>。在发送消息的时候回，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，消息就不会被发送，只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：一串和<code>message</code>同时传递的<code>Transferable</code>对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p><strong>例子</strong><br>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。<br>a.html 运行在 localhost:3000<br>可以使用<code>express</code>创建服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function load() &#123;</span><br><span class="line">        let frame = document.getElementById(&apos;frame&apos;);</span><br><span class="line">        frame.contentWindow.postMessage(&apos;我爱你&apos;,&apos;http://localhost:4000&apos;);</span><br><span class="line">        window.onmessage = function (e) &#123;</span><br><span class="line">        console.log(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>b.html 运行在 localhost:4000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onmessage = function (e) &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">    e.source.postMessage(&apos;我不爱你&apos;,e.origin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是 HTML5 的持久化的协议，实现浏览器和服务器的全双工通信，同时也是跨域的一种解决方案。<br><code>WebSocket</code>和<code>HTTP</code>都是应用层协议，都是基于<code>TCP</code>协议。但是<code>WebSocket</code>是一个双工通信协议，建立连接之后，<code>server</code>和<code>client</code>都能主动向对方发送或接收数据。<br><code>WebSocket</code>在建立连接时需要借助 <code>HTTP</code>协议，连接建立好了之后<code>client</code>与<code>server</code> 之间的双向通信就与<code>HTTP</code>无关。</p>
<p><code>Socket.io</code>很好地封装了<code>WebSocket</code>接口，提供了更简单、灵活的接口，也对不支持<code>WebSocket</code>的浏览器提供了向下兼容。<br>例子：本地文件 socket.html 向 localhost:8000 发生数据和接受数据<br>socket.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function WebSocketTest() &#123;</span><br><span class="line">  if (&quot;WebSocket&quot; in window) &#123;</span><br><span class="line">      // console.log(&apos;您的浏览器支持WebSocket!&apos;);</span><br><span class="line">      //打开一个web socket</span><br><span class="line">      var ws = new WebSocket(&apos;ws://localhost:8181&apos;)</span><br><span class="line">      ws.onopen = function () &#123;</span><br><span class="line">          //Web Socket已经连接上，使用send()发送数据</span><br><span class="line">          ws.send(&apos;发送数据&apos;);</span><br><span class="line">          console.log(&apos;数据发送中。。。&apos;)</span><br><span class="line">      &#125;;</span><br><span class="line">      ws.onmessage = function (evt) &#123;</span><br><span class="line">          var received_msg = evt.data;</span><br><span class="line">          console.log(&apos;数据已接收&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      ws.onclose = function () &#123;</span><br><span class="line">          //关闭</span><br><span class="line">          console.log(&apos;连接已关闭&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      //浏览器不支持WebSocket</span><br><span class="line">      console.log(&apos;浏览器不支持WebSocket&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">WebSocketTest()</span><br></pre></td></tr></table></figure>
<p>server.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var WebSocketServer = require(&quot;ws&quot;).Server,</span><br><span class="line">wss = new WebSocketServer(&#123; port: 8181 &#125;);</span><br><span class="line">wss.on(&quot;connection&quot;, function(ws) &#123;</span><br><span class="line">    console.log(&quot;client connected&quot;);</span><br><span class="line">    ws.on(&quot;message&quot;, function(message) &#123;</span><br><span class="line">        console.log(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Node-中间件代理（两次跨域）"><a href="#Node-中间件代理（两次跨域）" class="headerlink" title="Node 中间件代理（两次跨域）"></a>Node 中间件代理（两次跨域）</h3><p>原理：同源策略是浏览器需要遵循的标准，而如果服务器向服务器请求就无需遵循同源策略。<br>代理服务器，需要以下步骤：</p>
<ul>
<li>接收客户端请求</li>
<li>将请求转给服务器</li>
<li>拿到服务器响应的数据</li>
<li>将数据转发给客户端<br><img src="/2020/07/17/跨域解决方案/img6.png" alt="中间件"></li>
</ul>
<p><strong>例子：本地 index.html 文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据</strong><br>index.html(<a href="http://127.0.0.1:5500" target="_blank" rel="noopener">http://127.0.0.1:5500</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    url: &apos;http://localhost:3000&apos;,</span><br><span class="line">    type: &apos;post&apos;,</span><br><span class="line">    data: &#123; name: &apos;xiamen&apos;, password: &apos;123456&apos; &#125;,</span><br><span class="line">    contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">    success: function(result) &#123;</span><br><span class="line">        console.log(&apos;result&apos;, result)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(msg) &#123;</span><br><span class="line">        console.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>server1.js 代理服务器（<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// server1.js 代理服务器(http://localhost:3000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">// 第一步：接受客户端请求</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br><span class="line">  response.writeHead(200, &#123;</span><br><span class="line">    &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Methods&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Headers&apos;: &apos;Content-Type&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 第二步：将请求转发给服务器</span><br><span class="line">  const proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: &apos;127.0.0.1&apos;,</span><br><span class="line">        port: 4000,</span><br><span class="line">        url: &apos;/&apos;,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        // 第三步：收到服务器的响应</span><br><span class="line">        var body = &apos;&apos;;</span><br><span class="line">        serverResponse.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">          body += chunk;</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">          console.log(&apos;The data is &apos; + body)</span><br><span class="line">          // 第四步：将响应结果转发给浏览器</span><br><span class="line">          response.end(body);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The proxyServer is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>server2.js(<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const data = &#123; title: &apos;fontend&apos;, password: &apos;123456&apos; &#125;</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    response.end(JSON.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(4000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The server is running at http://localhost:4000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在<code>index.html</code>文件打印出<code>{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;}</code></p>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a><code>nginx</code>反向代理</h3><p>实现原理类似于<code>Node</code>中间件代理，需要你搭建一个中转<code>nginx</code>服务器，用于转发请求。<br>使用<code>nginx</code>反向代理实现跨域，是最简单的跨域方式。只需要修改<code>nginx</code>的配置即可解决跨域问题，支持所有浏览器，支持 <code>session</code>，不需要修改任何代码，并且不会影响服务器性能。<br>实现思路：通过<code>nginx</code>配置一个代理服务器（域名与<code>domain1</code>相同，端口不同）做跳板机，反向代理访问<code>domain2</code>接口，并且可以顺便修改<code>cookie</code>中<code>domain</code>信息，方便当前域<code>cookie</code>写入，实现跨域登录。<br>先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name+iframe"></a><code>window.name+iframe</code></h3><p>window.name 属性的独特之处：在一个窗口(window)的生命周期内，name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br><strong>例子，页面 a.html<a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a>获取页面 b.html<a href="http://localhost:4000/b.html" target="_blank" rel="noopener">http://localhost:4000/b.html</a>的数据</strong><br>b.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &quot;&#123;&apos;name&apos;:&apos;lala&apos;&#125;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>a.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function getData(url) &#123;</span><br><span class="line">        var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        iframe.style.display = &quot;none&quot;;</span><br><span class="line">        var state = 0;</span><br><span class="line">        iframe.onload = function () &#123;</span><br><span class="line">            if (state === 1) &#123;</span><br><span class="line">                var data = iframe.contentWindow.name;</span><br><span class="line">                console.log(data);</span><br><span class="line">                // 获取到数据后将隐藏的iframe去除</span><br><span class="line">                iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">                iframe.contentWindow.close();</span><br><span class="line">                document.removeChild(iframe);</span><br><span class="line">            &#125; else if (state === 0) &#123;</span><br><span class="line">                state = 1;</span><br><span class="line">                iframe.contentWindow.location.href = window.location.href;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iframe.src = url;</span><br><span class="line">        document.body.appendChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">    getData(&apos;http://localhost:4000/c.html&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash+iframe"></a><code>location.hash+iframe</code></h3><p>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code>。<br>a.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 路径后面的hash值可以用来通信  --&gt;</span><br><span class="line">&lt;!-- 目的a想访问c --&gt;</span><br><span class="line">&lt;!-- a给c传一个hash值 c收到hash值后  c把hash值传递给b b将结果放到a的hash值中--&gt;</span><br><span class="line">&lt;iframe src=&quot;http://localhost:4000/c.html#howareyou&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        console.log(location.hash)//iamfine</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>b.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.parent.parent.location.hash = location.hash;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>c.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    console.log(location.hash);//howareyou</span><br><span class="line">    let iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.src = &apos;http://localhost:3000/b.html#iamfine&apos;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a><code>document.domain+iframe</code></h3><p><strong>该方法只能用于二级域名相同的情况下，比如<code>a.test.com</code>和<code>b.test.com</code>适用于该方法。</strong><br>实现原理：两个页面都通过<code>js</code>强制设置<code>document.domain</code>为基础主域，就实现了同域。<br><strong>例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中的<code>a</code>的值</strong><br>a.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 域名 一级域名二级域名 --&gt;</span><br><span class="line">&lt;!-- www.baidu.com --&gt;</span><br><span class="line">&lt;!-- viode.baidu.com --&gt;</span><br><span class="line">&lt;!-- a是通过 http://a.zf1.cn:3000/a.html --&gt;</span><br><span class="line"> hello a</span><br><span class="line">  &lt;iframe src=&quot;http://b.zf1.cn:3000/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.domain = &apos;zf1.cn&apos;</span><br><span class="line">    function load() &#123;</span><br><span class="line">      console.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>b.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   hello b</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     document.domain = &apos;zf1.cn&apos;</span><br><span class="line">     var a = 100;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>CORS</code>支持所有类型的<code>HTTP</code>请求，是跨域<code>HTTP</code>请求的根本解决方案；</li>
<li><code>JSONP</code>只支持<code>GET</code>请求，<code>JSONP</code>的优势在于支持老式浏览器，以及可以向不支持<code>CORS</code> 的网址请求数据；</li>
<li>不管是<code>Node</code>中间件代理还是<code>nginx</code>反向代理，主要是通过同源策略对服务器不加限制；</li>
<li>日常工作中，用得比较多的跨域方案是<code>CORS</code>和<code>nginx</code>反向代理。</li>
</ul>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
  </entry>
  <entry>
    <title>JS-执行上下文和执行栈</title>
    <url>/2020/07/16/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    <content><![CDATA[<p>执行上下文和执行栈</p>
<a id="more"></a>
<p>执行上下文（<code>Execution Context</code>）：当前<code>JS</code>代码被解析和执行时所在环境的抽象概念。当前代码的执行环境，会形成一个作用域。<br><code>JavaScript</code>中的运行环境包括三种：</p>
<ul>
<li>全局环境：<code>JavaScript</code>代码运行起来会首先进入该环境；</li>
<li>函数环境：当函数被调用执行时，进入当前函数中执行代码；</li>
<li><code>eval</code>（不建议使用，可忽略）<br>JS 程序中，会产生多个执行上下文，JS 引擎会以函数调用栈（call stack）的方式来处理，栈底永远是全局上下文，栈顶是当前正在执行的上下文。<br>代码执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，处于栈顶的上下文执行完毕后，自动出栈，</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var color = &apos;blue&apos;;</span><br><span class="line"></span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var anotherColor = &apos;red&apos;;</span><br><span class="line"></span><br><span class="line">  function swapColors() &#123;</span><br><span class="line">    var tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>全局上下文入栈；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img1.png" alt="全局上下文入栈"></p>
</li>
<li><p>执行到<code>changeColor()</code>，创建当前函数的执行上下文；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img2.png" alt="函数执行栈"></p>
</li>
<li><p>执行<code>changeColor</code>中的可执行代码，遇到<code>swapColors()</code>,创建<code>swapColors</code>执行上下文；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img3.png" alt="函数执行栈"></p>
</li>
<li><code>swapColors</code>函数执行完成后，<code>swapColors EC</code>出栈；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img2.png" alt="函数执行栈"></li>
<li>继续执行<code>changeColor</code>函数，执行完成后，<code>changeColor EC</code>出栈，只剩下全局执行上下文。<br><img src="/2020/07/16/JS-执行上下文和执行栈/img1.png" alt="全局上下文入栈"></li>
<li>全局上下文在浏览器窗口关闭后出栈。</li>
</ol>
<p><code>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</code><br><img src="/2020/07/16/JS-执行上下文和执行栈/img4.png" alt="全局上下文入栈"></p>
<p><strong>生命周期</strong>：创建阶段、执行阶段、回收阶段<br><img src="/2020/07/16/JS-执行上下文和执行栈/img5.png" alt="全局上下文入栈"></p>
<ol>
<li><p>创建阶段（函数创建，但未执行）</p>
<ul>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明</li>
<li>创建作用域链</li>
<li>确定 this 指向</li>
</ul>
</li>
<li><p>函数内部执行时，会形成新的私有作用域，然后依次执行</p>
<ul>
<li>如果有形参，先给形参赋值</li>
<li>进行私有作用域的预解释，函数声明优先级比变量声明高，但可以重新赋值，</li>
<li>私有作用域中的代码从上到下执行<br>每次调用函数创建一个新的执行上下文，JS 引擎创建了执行栈来管理执行上下文，执行栈是一个存储函数调用的栈结构，遵循先进后出的原则。</li>
</ul>
</li>
</ol>
<p>多个函数执行过程：</p>
<ul>
<li>JS 执行在单线程上，所有的代码都是排队执行</li>
<li>首先创建全局执行上下文，压入执行栈的底部</li>
<li>函数执行时就创建新的执行上下文，压入执行栈的底部。</li>
<li>函数执行完，该函数执行上下文出栈，等待垃圾回收</li>
<li>浏览器的 JS 执行引擎总是访问栈顶执行上下文</li>
<li>全局执行上下文只有唯一一个，它在浏览器关闭时出栈。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JS-闭包</title>
    <url>/2020/07/14/JS-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>闭包</p>
<a id="more"></a>
<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>外层函数包裹受保护的变量和内层函数量，外层函数将内层函数返回到外部。<br>优点： 重用变量，保护变量被污染<br>缺点：占用内层。滥用会造成内存泄漏<br>如何释放闭包：将引用内存函数对象的外部变量设置为 null<br>外层函数将内层函数返回到外部的方法：</p>
<ul>
<li>return</li>
<li>赋值给全局变量</li>
<li>将内层函数包裹在对象或数组内返回</li>
</ul>
<p>应用场景：</p>
<ul>
<li>函数作为参数传递（作用域的例子）</li>
<li>函数作为返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return function inner() &#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var func1 = outer()</span><br><span class="line">func1() //1</span><br><span class="line">func1() //2</span><br><span class="line">var func2 = outer()</span><br><span class="line">func2() //1</span><br><span class="line">func2() //2</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn = null;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  function innerFoo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  fn = innerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  fn(); // 此处的保留的innerFoo的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); // 2</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/14/JS-闭包/img1.png" alt="闭包"></p>
<p><strong>总结</strong></p>
<ul>
<li>闭包是在函数被调用执行的时候才被确认创建的。</li>
<li>闭包的形成，与作用域链的访问顺序有直接关系。</li>
<li>只有内部函数访问了上层作用域中的变量对象，才会形成闭包。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>柯里化</li>
<li>模块化</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-作用域和作用域链</title>
    <url>/2020/07/14/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<p>作用域和作用域链</p>
<a id="more"></a>
<h2 id="词法环境（Lexical-Environments）-作用域-词法作用域"><a href="#词法环境（Lexical-Environments）-作用域-词法作用域" class="headerlink" title="词法环境（Lexical Environments）/作用域/词法作用域"></a>词法环境（Lexical Environments）/作用域/词法作用域</h2><p>是一种规范类型，用于根据 ECMAScript 代码的词法嵌套结构来定义标识符与特定变量和函数的关联。<br>通俗的将，词法环境就是一套约定好的规则。写代码应该按照这个规则来。<code>JS</code> 引擎对 <code>JS</code> 源码进行词法分析，也是按照这个规则。<br>所以，词法环境在我们写代码的时候已经确定，另外<code>this</code>指向在执行阶段才能确定。</p>
<ol>
<li>在 <code>JS</code> 中，我们可以将作用域定义为一套规则，这套规则用来管理 <code>JS</code> 引擎如何在当前作用域以及嵌套的子作用域中根据标识符（变量名或函数名）名称进行变量查找。</li>
<li><code>JS</code>有全局作用域与函数作用域。</li>
</ol>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  var b = a + 10;</span><br><span class="line"></span><br><span class="line">  function innerTest() &#123;</span><br><span class="line">    var c = 10;</span><br><span class="line">    return b + c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return innerTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p><strong>innerTest 的执行上下文</strong><br><img src="/2020/07/14/JS-作用域和作用域链/img1.png" alt="innerTest执行上下文"><br>当前作用域与上层作用域不是包含关系。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。<br><strong>innerTest 作用域链</strong><br><img src="/2020/07/14/JS-作用域和作用域链/img2.png" alt="innerTest作用域链"><br><code>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象(AO)</code></p>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><p>作用域：就是一个独立的地盘，让变量不会外泄、暴露出去。<br>分类：全局作用域，函数作用域，块级作用域（ES6）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var b = 200;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>在当前作用域没有该变量，就会向父级作用域寻找。如果还有找到，就向再向上级寻找，直到全局作用域，如果都没找到就报错。这种一层一层的关系，就是作用域链。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function F1() &#123;</span><br><span class="line">    var a = 100;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F2(f1) &#123;</span><br><span class="line">    var a = 200;</span><br><span class="line">    f1()</span><br><span class="line">&#125;</span><br><span class="line">var f1 = F1();</span><br><span class="line">F2(f1) //100</span><br></pre></td></tr></table></figure>
<p>上述代码中，变量 a，从函数 F1 中查找而不是 F2，变量从作用域链中去寻找，*<em>依据的是函数定义时的作用域链，而不是函数执行时</em>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(0, a) //0 undefined</span><br><span class="line">  if (!a) &#123;</span><br><span class="line">    console.log(1,a) //1 undefined</span><br><span class="line">    a = 100;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(2,a) //2 100</span><br><span class="line">  var a = 10;</span><br><span class="line">  console.log(3,a) //3 10</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-变量对象</title>
    <url>/2020/07/14/JS-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>变量对象</p>
<a id="more"></a>
<h2 id="变量对象-Variable-Object"><a href="#变量对象-Variable-Object" class="headerlink" title="变量对象 Variable Object"></a>变量对象 <code>Variable Object</code></h2><p>函数变量对象的创建过程</p>
<ol>
<li>建立<code>arguments</code>对象：检查当前上下文的函数参数，建立该对象下的属性和属性值。</li>
<li>检查当前上下文的函数声明，指的是<code>function</code>关键字声明的函数，在变量对象中以函数名建立一个属性，属性值为指向该函数的所在内存地址的引用。</li>
<li>检查当前上下文中的变量声明，在变量对象中以变量名建立一个属性，属性值为<code>undefined</code>。</li>
</ol>
<p><code>如果变量与函数同名，则在这个阶段，以函数值为准</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(foo); // function foo</span><br><span class="line">function foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class="line">var foo = 20;</span><br></pre></td></tr></table></figure>
<p><code>函数参数与变量同名，参数为准</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">  console.log(a);//20</span><br><span class="line">  a=10;</span><br><span class="line">&#125;</span><br><span class="line">foo(20)</span><br></pre></td></tr></table></figure>
<p><code>函数参数与内部函数同名，参数为准</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">  console.log(a); //f a()&#123;&#125;</span><br><span class="line">  function a()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(20)</span><br></pre></td></tr></table></figure>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(foo());</span><br><span class="line"></span><br><span class="line">    var a = 1;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>创建</strong><br><img src="/2020/07/14/JS-变量对象/img1.png" alt="创建变量对象"><br>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
</li>
<li><p><strong>执行阶段</strong><br>AO：活动对象<br><img src="/2020/07/14/JS-变量对象/img2.png" alt="创建变量对象"><br>实际执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  function foo() &#123;</span><br><span class="line">      return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  var a;</span><br><span class="line">  console.log(a);</span><br><span class="line">  console.log(foo());</span><br><span class="line">  a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="全局上下文变量对象"><a href="#全局上下文变量对象" class="headerlink" title="全局上下文变量对象"></a>全局上下文变量对象</h3><p>浏览器，全局对象为<code>Window</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windowEC=&#123;</span><br><span class="line">  VO：Window,</span><br><span class="line">  scopeChain：&#123;&#125;,</span><br><span class="line">  this：Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量对象和<code>this</code>都指向<code>Window</code>对象<br>全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>
<h3 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h3><p><code>let/const</code> 声明的变量，是否还会变量提升？<br><code>let/const</code> 声明的变量，仍然会提前被收集到变量对象中，但和<code>var</code>不同的是，<code>let/const</code>定义的变量，不会在这个时候给他赋值<code>undefined</code>。<br>因为存在暂时性死区，所以不能再声明前使用。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><h3 id="编译时和运行时"><a href="#编译时和运行时" class="headerlink" title="编译时和运行时"></a>编译时和运行时</h3><ul>
<li><strong>编译时</strong>：var 和 function 声明的变量和函数提升</li>
<li><strong>运行时</strong>：变量初始化</li>
</ul>
<h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><p>将变量声明及函数声明提升至当前作用域的顶端。</p>
<h3 id="为什么会存在变量提升"><a href="#为什么会存在变量提升" class="headerlink" title="为什么会存在变量提升"></a>为什么会存在变量提升</h3><p>提升存在的根本原因就是为了解决函数间互相调用的情况</p>
<ul>
<li>var 声明的提升<br>只提升声明，未赋值前使用是<code>undefined</code><br><strong>var 声明的变量只存在全局作用域和函数作用域</strong></li>
</ul>
<p><strong>例一</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a=10;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<p>预编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);//undefined</span><br><span class="line">a=10;</span><br><span class="line">console.log(a);//10</span><br></pre></td></tr></table></figure>
<p><strong>例二</strong><br>如果当前作用域声明了多个同名变量，同一个标识符会被提升到顶部，赋值操作顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var a</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
<p>预编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a</span><br><span class="line">a = 10</span><br><span class="line">console.log(a)//10</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数声明提升</p>
<ul>
<li>如果函数声明方式跟变量声明方式一样，则提升方式也是一样的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(fun);//undefined</span><br><span class="line">var fun=function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">fun();//1</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>function</code>声明<br>会把声明和赋值全部提升到作用域顶部</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun();//1</span><br><span class="line">function fun()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>例三</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(arg) &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">    //ƒ arg()&#123;</span><br><span class="line">    //console.log(&apos;hello world&apos;);</span><br><span class="line">    //&#125;</span><br><span class="line">    var arg = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">    function arg() &#123;</span><br><span class="line">        console.log(&apos;hello world&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg) //hello</span><br><span class="line">&#125;</span><br><span class="line">test(&apos;hi&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>阿里面试题</strong></p>
<p>考点：变量提升，作用域，继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;;</span><br><span class="line">var getName = function () &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;;</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line">new Foo.getName();</span><br><span class="line">new Foo().getName();</span><br><span class="line">new new Foo().getName();</span><br><span class="line">//2 4 1 1 2 3 3</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算优先级</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2020/07/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>浏览器渲染原理</p>
<a id="more"></a>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>渲染引擎+JS 引擎<br>浏览器内核分类：</p>
<ol>
<li>IE - Trident</li>
<li>Firefox - Gecko</li>
<li>Safari - Webkit</li>
<li>Chrome - Blink （Webkit 的分支）<br>Webkit 占比最多。</li>
</ol>
<h2 id="浏览器线程"><a href="#浏览器线程" class="headerlink" title="浏览器线程"></a>浏览器线程</h2><ul>
<li>GUI 渲染线程<br>GUI-图形用户界面，那 GUI 渲染线程也就是负责渲染浏览器界面上显示内容，即负责解析 HTML 标签和 CSS 样式。在浏览器的五个渲染过程中，GUI 渲染线程均参与其中。</li>
<li>JS 引擎线程<br>负责处理 JavaScript 脚本的线程。单线程，执行栈+任务队列。<br>事件循环机制</li>
<li>定时触发线程<br>处理<code>setTimeout</code>、<code>setInterval</code>代码的线程。<br>当定时器被触发后，会将需要执行的任务添加到JS的任务队列，当JS引擎线程空闲的时候，会按顺序执行任务队列中的任务。</li>
<li>事件处理线程<br>JS 引擎遇到事件处理程序代码块时，会将这个处理程序添加到事件处理线程中。当事件满足条件被触发后，事件处理程序会将该事件添加到前面提到前面说的 JS 执行时维护的任务队列中，之后就交由 JS 引擎线程去处理。</li>
<li><p>异步 http 请求线程<br>用于处理<code>XMLHttpRequest</code>请求。<br>需要向服务器发起请求时，就会交给该线程处理。当请求得到响应后，如果需要执行回调函数，会将回调放入JS的任务队列，后续再由JS引擎线程处理。</p>
<h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2></li>
<li><p>浏览器根据 DNS 服务器得到域名的 IP 地址</p>
</li>
<li>向 IP 发送 HTTP 请求</li>
<li>服务器收到、处理并返回 HTTP 请求</li>
<li>浏览器得到返回内容</li>
</ul>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol>
<li><strong>解析 HTML 生成 DOM 树</strong> - 渲染引擎首先解析<code>HTML</code>文档，生成<code>DOM</code>树；</li>
<li><strong>解析 CSS 生成 CSSOM 树</strong> - 处理<code>CSS</code>标记，构成层叠样式表模型<code>CSSOM</code>(CSS Object Model)；</li>
<li><strong>构建 Render 树</strong> - 将<code>DOM</code>和<code>CSSOM</code>合并为渲染树（rendering tree），代表一系列将被渲染的对象；</li>
<li><strong>布局 Render 树</strong> - 渲染树的每个元素包含的内容都是计算过的，被称作布局<code>layout</code>。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。</li>
<li><strong>绘制 Render 树</strong> - 将渲染树的各个节点绘制到屏幕上，<code>painting</code>。</li>
</ol>
<p>以上五个步骤并不一定一次性顺序完成，如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上重新渲染。</p>
<p><img src="/2020/07/07/浏览器渲染原理/img1.webp" alt="渲染过程"></p>
<h2 id="浏览器渲染具体流程"><a href="#浏览器渲染具体流程" class="headerlink" title="浏览器渲染具体流程"></a>浏览器渲染具体流程</h2><h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>当浏览器接收到服务器返回来的 HTML 文档后，会遍历文档节点，生成 DOM 树。</p>
<p><strong>重点</strong>：</p>
<ul>
<li><code>DOM</code>树在构建过程中可能会被<code>CSS</code>和<code>JS</code>的加载而阻塞；</li>
<li><code>display:none</code>的元素也会在<code>DOM</code>树中；</li>
<li>注释也会在<code>DOM</code>树中；</li>
<li><code>script</code>标签也会在<code>DOM</code>树中</li>
</ul>
<p>无论是<code>DOM</code>还是<code>CSSOM</code>，都是要经过<code>Bytes=&gt;Characters=&gt;Tokens=&gt;Nodes=&gt;DOM</code>这个解析步骤。<br><img src="/2020/07/07/浏览器渲染原理/img2.webp" alt="构建 DOM 树"></p>
<ol>
<li><strong>转换</strong>，将接收到的 HTML 原始字节根据指定编码（一般是 UTF-8）转换成字符（Character）。</li>
<li><strong>令牌化</strong>， 通过状态机将字符串转换为<code>Token</code>,每个<code>Token</code>都具有特殊含义和一组规则。</li>
<li><strong>词法分析</strong>，<code>Token</code>会被转换成定义了属性等规则的‘对象’。</li>
<li><strong>DOM 构建</strong>， 利用栈构建 DOM 树。</li>
</ol>
<h4 id="Token-的拆分"><a href="#Token-的拆分" class="headerlink" title="Token 的拆分"></a>Token 的拆分</h4><p><code>Token</code>（词）出自编译原理，表示最小的有意义的单元。</p>
<p>词（token）是如何被拆分的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码依次被拆分成<code>token</code>:</p>
<ul>
<li><code>&lt;p</code> - ’开始标签‘的开始</li>
<li><code>class=&#39;a&#39;</code> - 属性</li>
<li><code>&gt;</code> - ’开始标签‘的结束</li>
<li><code>text text text</code> - 文本</li>
<li><code>&lt;/p&gt;</code> - 结束标签</li>
</ul>
<p><strong>常见的 token</strong><br>|token|解释|<br>|–|–|<br>|<code>&lt;xxx</code> |’开始标签‘的开始|<br>|<code>a=&#39;xxx&#39;</code>|属性|<br>|<code>&gt;</code>|’开始标签‘的结束|<br>|text text text|文本|<br>|<code>&lt;/xxx&gt;</code>|结束标签|<br>|<code>&lt;!xxxx&gt;</code>|注释|<br>|<code>&lt;![CDATA[hello world!]]&gt;</code>|CDATA 数据节点|</p>
<p>在 Chrome 里，总共定义了 7 中 Token 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum TokenType &#123;</span><br><span class="line">    StartTag,</span><br><span class="line">    EndTag,</span><br><span class="line">    Comment,</span><br><span class="line">    Character,</span><br><span class="line">    Uninitialized,</span><br><span class="line">    DOCTYPE,</span><br><span class="line">    EndOfFile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码从字符流中读取字符，在接收第一个字符之前，无法判断这个是哪个词（token），随着我们接收的字符越来越多，拼出其他内容的可能性越来越小。比如，我们接收第一字符<code>&lt;</code>，我们就能确定这个不是文本节点，接着读到第二个字符<code>x</code>，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。<br>这样我们每读入一个字符，其实都要做一次决策，而且这些决策是跟’当前状态‘有关。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>将字符流解析成 Token 的最常用方案。<br>简单的状态机：<br><img src="/2020/07/07/浏览器渲染原理/img3.png" alt="HTML词法状态机"><br>真正完整的 HTML 词法状态机，比上图描述的要复杂的多，更详细的内容可以参考<a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" target="_blank" rel="noopener">HTML 官方文档</a>，HTML 官方文档了 80 个状态。</p>
<p><strong>状态机的具体过程：</strong></p>
<ul>
<li><p>初始状态，从 data 开始，首先区分<code>&lt;</code>和<code>非&lt;</code></p>
<ul>
<li>如果是<code>非&lt;</code>那么可以判断这个是一个文本节点。</li>
<li>如果是<code>&lt;</code>，那么进入一个标签状态</li>
</ul>
</li>
<li><p>标签状态</p>
<ul>
<li>如果下一个字符是”!”，那么可能进入注释节点或 CDATA 节点</li>
<li>如果下一个字符是”/“，那么可以确定进入一个结束标签</li>
<li>如果下一个字符是字母，那么可以确定进入一个开始标签，<code>tag open</code>状态</li>
<li>如果要完整处理各种 HTML 标准中定义的东西，还要考虑”?”,”%”等内容<br>-</li>
</ul>
</li>
<li><p><code>tag open</code>状态</p>
<ul>
<li>字母<code>letter</code></li>
<li>“!”</li>
<li>“/“</li>
</ul>
<p>就这样根据字符去判断下一步的状态。其本质就是将每个词的“特征字符”逐个拆分成独立的状态，然后再把所有词的特征字符合并起来，形成一个连通图。</p>
</li>
</ul>
<h4 id="构建-DOM-树-1"><a href="#构建-DOM-树-1" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h4><p>事实上，构建 DOM 的过程中，不是等所有 Token 都转换完成后再去生成节点对象，而是一边生成 Token 一边消耗 Token 来生成节点对象。<br>也就是，每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象。<br><strong>注意：带有结束标签标识的 Token 不会创建节点对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">     &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">         &lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>把这段代码拆成 Token 之后，就是下面这样，我这里省略了里面的换行跟空格。<br>|TagName|type|attr|text|<br>|–|–|–|–|–|<br>|html|StartTag||’’|<br>|head|StartTag||’’|<br>|meta|StartTag|charset=’utf-8’|’’|<br>|head|EndTag||’’|<br>|body|StartTag||’’|<br>|div|StartTag||’’|<br>|p|StartTag|class=’a’|’’|<br>||Character||’text text text’|<br>|div|EndTag||’’|<br>|body|EndTag||’’|<br>|html|EndTag||’’|<br>||EndOfFile||’’|</p>
<p><strong>第一步</strong>，在 Tokens 中，<code>StartTag</code>和<code>EndTag</code>通常需要成对匹配。对于<code>&lt;br/&gt;</code>这种自闭合标签，可以视为入栈后立马出栈。<br>在解析开始的时候，会默认创建一个根为<code>document</code>的空 DOM 结构。同时会将一个 <code>startTag document</code> 的 Token 放入栈底。<br><img src="/2020/07/07/浏览器渲染原理/img4.png" alt="DOM1"><br><strong>第二步</strong>，经过词法分析后一个个 <code>StartTag</code> 被放入栈中，同时会创建响应的 DOM 节点，当遇到<code>tagName</code>相同的<code>EndTag</code> 时，对应的<code>StartTag</code>（正常情况下在栈顶，否则出错）弹出栈。<br><img src="/2020/07/07/浏览器渲染原理/img5.png" alt="DOM2"><br><strong>第三步</strong>，不断的出栈入栈，最后生成 DOM 树<br><img src="/2020/07/07/浏览器渲染原理/img6.png" alt="DOM3"><br>上面是最简单的情况，在实际构建过程还是需要考虑如下情况：</p>
<ul>
<li>遇到<code>StartTag</code>就入栈一个节点，当前节点就是这个节点的父节点</li>
<li>遇到<code>EndTag</code>就出栈一个节点（还可以检查是否匹配）</li>
<li>栈顶元素就是当前节点</li>
<li>遇到属性，就添加到当前节点</li>
<li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点</li>
<li>遇到注释节点，作为当前节点的子节点</li>
</ul>
<p>HTML 具有很强的容错能力，奥妙在于当<code>EndTag</code>跟栈顶的<code>StartTag</code> 不匹配的时候如何处理。</p>
<h3 id="构建-CSSOM-规则树"><a href="#构建-CSSOM-规则树" class="headerlink" title="构建 CSSOM 规则树"></a>构建 CSSOM 规则树</h3><p>在浏览器构建 DOM 树时，在 HTML 文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该 CSS 资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure>
<p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：<code>Bytes=&gt;Characters=&gt;Tokens=&gt;Nodes=&gt;DOM</code><br><img src="/2020/07/07/浏览器渲染原理/img7.png" alt="CSSOM1"><br><code>.CSS 文件</code>，又名层叠样式表。当<code>CSSOM</code>树生成节点时，每一个节点首先会继承其父节点的所有样式，层叠覆盖，然后再以”向下级联”的规则，为该节点应用更具体的样式，递归生成<code>CSSOM</code>树。譬如，上右图中第二层的<code>p</code>节点，有父节点<code>body</code>，因此该<code>p</code>将继承 body <code>节点的样式：</code>“font-size: 16px;”<code>。然后再应用该</code>p<code>节点自身的样式：</code>“font-weight: bold;”<code>。所以最终该</code>p<code>节点的样式为：</code>“font-size: 16px;font-weight: bold;”`。<br>还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式。</p>
<p><strong>注意：CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情。所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去</strong></p>
<h3 id="构建渲染树-（Render-Tree）"><a href="#构建渲染树-（Render-Tree）" class="headerlink" title="构建渲染树 （Render Tree）"></a>构建渲染树 （Render Tree）</h3><p>通过 DOM 树和 CSS 规则树，浏览器就可以通过它两构建渲染树了。</p>
<ul>
<li>浏览器会先从 DOM 树的根节点开始遍历每个可见节点</li>
<li>某些节点完全不可见（例如 script 标签、meta 标签），因为它们不会在渲染结果中反映，所以会被忽略</li>
<li>某些节点通过 CSS 隐藏，也会在渲染树中忽略。比如设置或继承<code>display:none</code></li>
<li><p>给每个可见节点找到相应匹配的 CSSOM 规则，并应有这些规则。</p>
<p><img src="/2020/07/07/浏览器渲染原理/img8.webp" alt="构建渲染树"></p>
</li>
</ul>
<h3 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h3><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。<br>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。<br>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p>
<h2 id="与之相关的几个问题"><a href="#与之相关的几个问题" class="headerlink" title="与之相关的几个问题"></a>与之相关的几个问题</h2><h3 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h3><p>DOM 是属于渲染引擎相关，而 JS 又与 JS 引擎相关，于是在用 JS 操作 DOM 的时候，其实涉及到浏览器两大线程之间的通信，必然会有性能损耗。还有操作 DOM 可能会导致重绘回流的情况。<br><strong>经典面试题：插入几万个 DOM，如何实现页面不卡顿？</strong></p>
<ol>
<li><code>requestAnimationFrame</code>循环插入 DOM</li>
<li>虚拟滚动（virtualized scroll）<br>只渲染可视区域的内容，非可视区域的完全不渲染，当用户滚动的时候实时渲染</li>
</ol>
<h3 id="浏览器如果渲染过程中遇到-JS-文件怎么处理"><a href="#浏览器如果渲染过程中遇到-JS-文件怎么处理" class="headerlink" title="浏览器如果渲染过程中遇到 JS 文件怎么处理"></a>浏览器如果渲染过程中遇到 JS 文件怎么处理</h3><p>渲染过程中如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器的渲染引擎和 JS 引擎是互斥的。JS 代码的加载、解析与执行都会阻塞 DOM 的构建，<br>如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍）。</p>
<p><strong>JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建。</strong><br>原本 DOM 和 CSSOM 的构建是互不影响，但是一旦引入了 JavaScript，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，DOM 再恢复 DOM 构建。</p>
<h3 id="什么情况下阻塞渲染"><a href="#什么情况下阻塞渲染" class="headerlink" title="什么情况下阻塞渲染"></a>什么情况下阻塞渲染</h3><ol>
<li><p>渲染的前提是生成渲染树，所以<code>HTML</code>和<code>CSS</code>肯定会阻塞渲染。所以，渲染的<strong>文件越小</strong>，并且<strong>扁平层级，优化选择器</strong>，就渲染的越快。<br>当解析<code>HTML</code>的时候，会把新来的元素插入<code>DOM</code>树里面，同时去查找<code>CSS</code>，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。<br>例如：div p {font-size: 16px}，会先寻找所有 p 标签并判断它的父标签是否为 div 之后才会决定要不要采用这个样式进行渲染）。<br>所以，我们平时写 CSS 时，尽量用 id 和 class，千万不要过渡层叠。</p>
</li>
<li><p>当浏览器在解析到<code>script</code> 标签时，会暂停构建<code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载<code>JS</code>文件，这也是都建议将<code>script</code>标签放在<code>body</code>标签底部的原因。<br>现在可以给<code>script</code>标签添加<code>defer</code>或者<code>async</code>属性，异步加载<code>JS</code>文件:</p>
<ul>
<li><code>defer</code>:表示延迟执行引入的<code>JavaScript</code>，但是会放到<code>HTML</code>解析完成后，并且<code>JS</code>文件加载完成后，顺序执行，这时，可以把 script 标签放在任意位置。</li>
<li><code>async</code>: 表示异步执行引入的<code>JavaScript</code>，是在自己加载完成后立即执行，如果是多个，执行顺序和加载顺序无关。</li>
</ul>
</li>
</ol>
<p>需要注意的是，这种方式加载的<code>JavaScript</code>依然会阻塞<code>load</code>事件。换句话说，<code>async-script</code>可能在<code>DOMContentLoaded</code>触发之前或之后执行，但一定在<code>load</code>触发之前执行。</p>
<h2 id="回流（reflow）和重绘（repaint"><a href="#回流（reflow）和重绘（repaint" class="headerlink" title="回流（reflow）和重绘（repaint)"></a>回流（reflow）和重绘（repaint)</h2><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>当一个元素的外观发生变化，但没有改变布局，重新把元素的外观绘制出来的过程<br><strong>常见的引起重绘的属性</strong><br>|||||<br>|–|–|–|–|<br>|color|border-style|visibility|background|<br>|text-decoration|background-image|background-position|background-repeat|<br>|outline-color|outline|outline-style|border-radius|<br>|outline-with|box-shadow|background-size||</p>
<h3 id="回流、重构、重排"><a href="#回流、重构、重排" class="headerlink" title="回流、重构、重排"></a>回流、重构、重排</h3><p>当 DOM 变化影响可元素的几何信息（<code>DOM</code> 对象的位置、尺寸大小、显隐），浏览器需要重新计算元素的几何属性，将其安放在界面的正确位置。<br>每个页面至少需要一次回流，就是页面第一次加载的时候。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。<br><strong>触发条件</strong></p>
<ul>
<li>添加或删除可见的<code>DOM</code>元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变 – 边距<code>padding/margin</code>、边框<code>border</code>、宽度<code>width</code>、高度<code>height</code></li>
<li>元素内容改变 – 输入框输入文字</li>
<li>页面渲染初始化 – 无法避免</li>
<li>浏览器窗口尺寸改变 – <code>resize</code>事件发生</li>
<li>隐藏可见元素 – <code>display:none</code></li>
<li>激活<code>CSS</code>伪类</li>
<li>读取某些元素属性 – <code>offsetLeft/Top/Height/Width</code>, <code>clientTop/Left/Width/Height</code>, <code>scrollTop/Left/Width/Height</code>, <code>width/height</code>, <code>getComputedStyle()</code>, <code>currentStyle(IE)</code></li>
</ul>
<h2 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="headerlink" title="浏览器的渲染队列"></a>浏览器的渲染队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.style.left = &apos;10px&apos;;</span><br><span class="line">div.style.top = &apos;10px&apos;;</span><br><span class="line">div.style.width = &apos;20px&apos;;</span><br><span class="line">div.style.height = &apos;20px&apos;;</span><br></pre></td></tr></table></figure>
<p>这段代码理论上会触发 4 次重排+重绘，因为每一次都改变了元素的几何属性，实际上最后只触发了一次重排，这都得益于浏览器的渲染队列机制：<br>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p>
<ul>
<li>强制刷新队列:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.style.left = &apos;10px&apos;;</span><br><span class="line">console.log(div.offsetLeft);</span><br><span class="line">div.style.top = &apos;10px&apos;;</span><br><span class="line">console.log(div.offsetTop);</span><br><span class="line">div.style.width = &apos;20px&apos;;</span><br><span class="line">console.log(div.offsetWidth);</span><br><span class="line">div.style.height = &apos;20px&apos;;</span><br><span class="line">console.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>
<p>这段代码会触发 4 次重排+重绘，因为在<code>console</code>中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。<br>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。<br><strong>强制刷新队列的 style 样式请求：</strong></p>
<ol>
<li><code>offsetTop</code>, <code>offsetLeft</code>, <code>offsetWidth</code>, <code>offsetHeight</code></li>
<li><code>scrollTop</code>, <code>scrollLeft</code>, <code>scrollWidth</code>, <code>scrollHeight</code></li>
<li><code>clientTop</code>, <code>clientLeft</code>, <code>clientWidth</code>, <code>clientHeight</code></li>
<li><code>getComputedStyle()</code>, 或者 IE 的 <code>currentStyle</code></li>
</ol>
<p>我们在开发中，应该谨慎的使用这些 style 请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗</p>
<h3 id="优化：减少重绘和回流"><a href="#优化：减少重绘和回流" class="headerlink" title="优化：减少重绘和回流"></a>优化：减少重绘和回流</h3><ol>
<li><p><strong>分离读写操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.style.left = &apos;10px&apos;;</span><br><span class="line">div.style.top = &apos;10px&apos;;</span><br><span class="line">div.style.width = &apos;20px&apos;;</span><br><span class="line">div.style.height = &apos;20px&apos;;</span><br><span class="line">console.log(div.offsetLeft);</span><br><span class="line">console.log(div.offsetTop);</span><br><span class="line">console.log(div.offsetWidth);</span><br><span class="line">console.log(div.offsetHeight);</span><br></pre></td></tr></table></figure>
<p>上面触发 4 次重排+重绘的代码，这次只触发了一次重排。<br>在第一个<code>console</code> 的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的<code>console</code>，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。</p>
</li>
<li><p><strong>样式集中改变</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.style.left = &apos;10px&apos;;</span><br><span class="line">div.style.top = &apos;10px&apos;;</span><br><span class="line">div.style.width = &apos;20px&apos;;</span><br><span class="line">div.style.height = &apos;20px&apos;;</span><br></pre></td></tr></table></figure>
<p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下：建议通过改变 class 或者 csstext 属性集中改变样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad</span><br><span class="line">var left = 10;</span><br><span class="line">var top = 10;</span><br><span class="line">el.style.left = left + &quot;px&quot;;</span><br><span class="line">el.style.top  = top  + &quot;px&quot;;</span><br><span class="line">// good</span><br><span class="line">el.className += &quot; theclassname&quot;;</span><br><span class="line">// good</span><br><span class="line">el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缓存布局信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bad 强制刷新 触发两次重排</span><br><span class="line"> div.style.left = div.offsetLeft + 1 + &apos;px&apos;;</span><br><span class="line"> div.style.top = div.offsetTop + 1 + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line"> // good 缓存布局信息 相当于读写分离</span><br><span class="line"> var curLeft = div.offsetLeft;</span><br><span class="line"> var curTop = div.offsetTop;</span><br><span class="line"> div.style.left = curLeft + 1 + &apos;px&apos;;</span><br><span class="line"> div.style.top = curTop + 1 + &apos;px&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>离线改变 dom</strong></p>
<ul>
<li><p>隐藏要操作的<code>dom</code><br>在要操作 dom 之前，通过 display 隐藏 dom，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dom.display = &apos;none&apos;</span><br><span class="line">// 修改dom样式</span><br><span class="line">dom.display = &apos;block&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过使用<code>DocumentFragment</code>创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</p>
</li>
<li>复制节点，在副本上工作，然后替换。</li>
</ul>
</li>
<li><p><strong>position 属性为 absolute 或 fixed</strong><br>将需要多次重排的元素，<code>position</code> 属性设为 <code>absolute</code> 或 <code>fixed</code> 的元素，重排开销比较小，不用考虑它对其他元素的影响。</p>
</li>
<li><p><strong>优化动画</strong><br>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p>
</li>
<li>不要使用<code>table</code>布局，可能很小的一个小改动会造成整个<code>table</code>的重新布局<br>去·</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>m-面试题汇总</title>
    <url>/2020/07/07/m-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>整理一些有意思的面试题</p>
<a id="more"></a>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    n: 1</span><br><span class="line">&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">a.x = a = &#123;</span><br><span class="line">    n: 2</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a.n, b.n);</span><br><span class="line">console.log(a.x, b.x);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">//2, 1</span><br><span class="line">//undefined &#123;n:2&#125;</span><br></pre></td></tr></table></figure>
<p>1 - <code>a</code> 和 <code>b</code>指向同一对象<br>2 - <code>.</code>运算符优先级高于<code>=</code>,所以先计算<code>a.x</code>，<br>就是给对象添加新属性<code>x</code>,所以 <code>a</code>和<code>b</code>指向的对象<code>{n:1, x:undefined}</code><br>3 - 然后计算赋值运算，赋值从右到左，此时<code>a</code>指向一个新对象，<code>a</code>-&gt;<code>{ n:2 }</code><br>4 - <code>a.x</code>已经执行过了,此时对象的<code>x</code>属性赋值为<code>a</code>,也是指向<code>{ n:2 }</code><br>即:<br>a = {n:2}<br>b = {n:1,x:{n:2}}</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(c);</span><br><span class="line">var c;</span><br><span class="line">function c(a) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a = 3;</span><br><span class="line">    function a()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">c(2);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">function c(a)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a = 3;</span><br><span class="line">    function a()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量提升也有优先级, 函数声明 &gt; arguments &gt; 变量声明。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &apos;Grace&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        var name = &apos;John&apos;;</span><br><span class="line">        console.log(name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">John</span><br></pre></td></tr></table></figure>
<p>自执行函数执行时,会先进行变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &apos;Grace&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">var name;  // 变量name会提升到当前作用域顶部</span><br><span class="line">if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        name = &apos;John&apos;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>所以执行的是 if 里面的代码</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var val = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    val: 2,</span><br><span class="line">    del: function () &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">        this.val *= 2;</span><br><span class="line">        console.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.del();</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">obj(指向的值)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>当通过 obj.del()调用 del 函数时,del 函数作用域中的 this 绑定为 obj。<br>在函数作用域中访问 val 时,由于函数中并没有变量 val,因此实际上访问的是全局作用域中的 val,即 1。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">A.prototype.n = 1;</span><br><span class="line">var b = new A();</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    n: 2,</span><br><span class="line">    m: 3</span><br><span class="line">&#125;</span><br><span class="line">var c = new A();</span><br><span class="line">console.log(b.n, b.m);</span><br><span class="line">console.log(c.n, c.m);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">1 undefined</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p>var b = new A(); 实例化 b 时,A 的 prototype 为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor:A,</span><br><span class="line">    n:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当访问 b.n 和 b.m 时,通过原型链找到 A.prototype 指向的对象上,即 b.n = 1,b.m = undefined。<br>var c = new A(); 实例化 c 时,A 的 prototype 为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">    n: 2,</span><br><span class="line">    m: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当访问<code>a.n</code>和<code>a.m</code>时,通过原型链找到<code>A.prototype</code>指向的对象上,此时<code>A.prototype</code>重写,因此<code>a.n = 2</code>,<code>b.m = 3</code>。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function Person() &#123;</span><br><span class="line">    getAge = function () &#123;</span><br><span class="line">        console.log(10)</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Person.getAge = function () &#123;</span><br><span class="line">    console.log(20)</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = function () &#123;</span><br><span class="line">    console.log(30)</span><br><span class="line">&#125;</span><br><span class="line">var getAge = function () &#123;</span><br><span class="line">    console.log(40)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getAge() &#123;</span><br><span class="line">    console.log(50)</span><br><span class="line">&#125;</span><br><span class="line">Person.getAge();</span><br><span class="line">getAge();</span><br><span class="line">Person().getAge();</span><br><span class="line">new Person.getAge();</span><br><span class="line">getAge();</span><br><span class="line">new Person().getAge();</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">20</span><br><span class="line">40</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">10</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Person.getAge();</code>，执行<code>Person</code>函数上的<code>getAge</code>方法，=》20</li>
<li><p><code>getAge();</code>，执行全局函数，由<br>变量提升，先是<code>var getAge = undefined</code>，接着<code>function getAge() { console.log(50) }</code>；<br>赋值，执行到<code>var getAge = function () { console.log(40) }</code>；<br>=》40</p>
</li>
<li><p><code>Person().getAge();</code>，执行<code>Person</code>函数，显示改变全局函数<code>getAge</code>=&gt;<br><code>function () {console.log(10)}</code>，<br>然后返回<code>this</code>，这里的<code>this</code>就是<code>window</code>，<br>所以<code>window.getAge()</code> =&gt; 10</p>
</li>
<li><p><code>new Person.getAge();</code>，没有参数的<code>new</code>方法，优先级低于<code>.</code>函数，所以先执行<code>Person.getAge</code>，然后实例化这个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let b=Person.getAge();</span><br><span class="line">new b() // =&gt;20</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getAge();</code>，执行全局函数，=》10</p>
</li>
<li><code>new Person().getAge();</code>，先执行<code>new Person()</code>实例化<code>Person</code>，接着执行实例的函数，实例上没有该函数，就会执行原型上的函数，就是<code>Person.prototype.getAge = function () { console.log(30) }</code> =&gt;30</li>
</ul>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(false.toString());</span><br><span class="line">console.log([1,2,3].toString());</span><br><span class="line">console.log(1.toString());</span><br><span class="line">console.log(5...toString());</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">&apos;false&apos;</span><br><span class="line">1,2,3</span><br><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">&apos;5&apos;</span><br></pre></td></tr></table></figure>
<p><code>1.toString()</code>，实际是<code>(1.)toString()</code>，点会被认为是浮点数。如果执行<code>(1).toString()</code>结果就是 1。<br>同理，<code>5..toString()</code>，第一个点是浮点数，第二个点是函数调用</p>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1 + &quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 + +&quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 + -&quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log(+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + 2);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">&apos;122&apos;</span><br><span class="line">&apos;32&apos;</span><br><span class="line">&apos;02&apos;</span><br><span class="line">&apos;112&apos;</span><br><span class="line">&apos;NaN2&apos;</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>
<p><strong>重点</strong></p>
<ol>
<li><code>+a</code>会把<code>a</code>转换为数字，<code>-a</code>会把<code>a</code>转换成数字的负值（如果不能转换为数字就是<code>NaN</code>）</li>
<li>字符串与任何值相加都是字符串拼接<br><code>1 + -&quot;1&quot; + &quot;2&quot;</code>； <code>1+(-1)+&#39;2&#39;</code> =&gt; <code>0+&#39;2&#39;</code> =&gt; ‘02’</li>
</ol>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if(function f()&#123;&#125;)&#123;</span><br><span class="line">    x += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出</span><br><span class="line">1undefined</span><br></pre></td></tr></table></figure>
<p><code>function f(){}</code>当做 if 条件判断,其隐式转换后为<code>true</code>。但是在函数参数不会声明提升,因此 f 函数在外部是不存在的。因此<code>typeof f = ‘undefined’</code>,所以 x += typeof f,相当于 x = x + ‘undefined’为<code>&#39;1undefined&#39;</code></p>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &quot;123abc&quot;;</span><br><span class="line">console.log(typeof str++);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;number&apos;</span><br></pre></td></tr></table></figure>
<p>使用++运算符时(无论是前置还是后置),如果变量不是数字类型,会首先用<code>Number()</code>转换为数字。因此<code>typeof str++</code>相当于<code>typeof Number(str)++</code>。由于后置的++是先取值后计算,因此相当于 <code>typeof Number(&#39;123abc&#39;)</code>。即 <code>typeof NaN</code>,所以输出<code>&#39;number&#39;</code>。</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">    var x = 20;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>JavaScript采用的是词法作用域，规定了函数内访问变量时，查找变量是从函数声明的位置向外层作用域中查找，而不是从调用函数的位置开始向上查找。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>JS-原理</title>
    <url>/2020/07/04/JS-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>总结一些 js 函数原理，手写</p>
<a id="more"></a>
<p><code>JavaScript</code>是什么？</p>
<ol>
<li>脚本编程语言</li>
<li>弱类型语言<br>变量可以被隐式转换成另一个类型。<ul>
<li>二元运算<code>+</code>会把两个操作数转换成字符串，除非两个操作数都是数字类型</li>
<li>二元操作符<code>-</code>会把两个操作数转换成数字类型</li>
<li>操作符，包括<code>+</code>和<code>-</code>，会把操作数转换成数字。</li>
</ul>
</li>
<li>动态类型<br>变量可以赋值不同类型的值</li>
<li>单线程</li>
<li>解释型语言</li>
<li><p>具有良好的跨平台性</p>
<p><strong>组成部分</strong></p>
<ul>
<li>ECMAScript<br>JavaScript 的语法和基本对象</li>
<li>DOM<br>文档对象模型，提供了与网页内容交互的<code>方法</code>和<code>接口</code></li>
<li>BOM<br>浏览器对象模型，提供了与浏览器交互的<code>方法</code>和<code>接口</code></li>
</ul>
</li>
</ol>
<h2 id="手写-call、apply、bind-函数"><a href="#手写-call、apply、bind-函数" class="headerlink" title="手写 call、apply、bind 函数"></a>手写 call、apply、bind 函数</h2><p>非严格模式：</p>
<ol>
<li>不传入第一个参数，上下文默认为<code>window</code></li>
<li>改变<code>this</code>指向，让新的对象可以执行该函数，并能接受参数</li>
</ol>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mySymbol(obj) &#123;</span><br><span class="line">    let unique = (Math.floor(Math.random() * 10) + new Date().getTime()).toString(32).slice(0, 8);</span><br><span class="line">    if (obj.hasOwnProperty(unique)) &#123;</span><br><span class="line">        return mySymbol(obj) //递归调用</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return unique</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.myCall = function (context) &#123;</span><br><span class="line">    // 如果没有传或传的值为空对象 context指向window</span><br><span class="line">    context = context || window;</span><br><span class="line">    let fnName = mySymbol(context); //保证方法名唯一</span><br><span class="line">    context[fnName] = this; //为context添加一个方法，指向this，</span><br><span class="line">    //调用方法，去掉第一个参数</span><br><span class="line">    let arg = [...arguments].slice(1);</span><br><span class="line">    context[fnName](...arg);</span><br><span class="line">    delete context[fnName]; //删除方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    say(age) &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">        console.log(`I am $&#123;this.name&#125;,my age is $&#123;age&#125;.`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let another = &#123;</span><br><span class="line">    name: &apos;John&apos;</span><br><span class="line">&#125;</span><br><span class="line">Person.say.myCall(another, 18)//I am John,my age is 18.</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply = function (context) &#123;</span><br><span class="line">    // 如果没有传或传的值为空对象 context指向window</span><br><span class="line">    context = context || window;</span><br><span class="line">    let fnName = mySymbol(context); //保证方法名唯一</span><br><span class="line">    context[fnName] = this; //为context添加一个方法，指向this，</span><br><span class="line">    let result;</span><br><span class="line">    if (arguments[1]) &#123;</span><br><span class="line">        result = context[fnName](...arguments[1])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = context[fnName]()</span><br><span class="line">    &#125;</span><br><span class="line">    delete context[fnName]</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">Person.say.myApply(another, [18]);//I am John,my age is 18.</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ol>
<li>函数调用，改变 this</li>
<li>返回一个绑定 this 的函数</li>
<li>接收多个参数</li>
<li>支持柯里化形式传参 fn(1)(2)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">    //返回一个绑定this的函数，先保存this</span><br><span class="line">    let self = this;</span><br><span class="line">    //保存参数</span><br><span class="line">    let args = [...arguments].slice(1);</span><br><span class="line">    //返回一个函数</span><br><span class="line">    return function () &#123;</span><br><span class="line">        //因为支持柯里化形式传参我们需要再次获取存储参数</span><br><span class="line">        let newArg = [...arguments];</span><br><span class="line">        console.log(newArg);</span><br><span class="line">        // 返回函数绑定this，传入两次保存的参数</span><br><span class="line">        //考虑返回函数有返回值做了return</span><br><span class="line">        return self.apply(context, args.concat(newArg))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> let fn = Person.say.myBind(another, 118)</span><br><span class="line"> fn(18);////I am John,my age is 118.</span><br></pre></td></tr></table></figure>
<h2 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判断left是不是right的实例</span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    let prototype = right.prototype;</span><br><span class="line">    left = left.__proto__;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (left === null || left === undefined) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        if (prototype === left) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        left = left.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>数据结构和 JavaScript 内存空间</p>
<a id="more"></a>
<p><img src="/2020/06/30/数据结构/img1.png" alt="数据结构"></p>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆-Heap"></a>堆-Heap</h3><p>堆数据结构是一种树状结构，利用完全二叉树维护的一组无序数据，比如对象的<code>key-value</code>数据。<br>堆分为最大堆和最小堆。<br>最大堆：将根节点最大的堆叫做最大堆或大根堆。最小堆：根节点最小的堆叫做最小堆或小根堆。<br>最大堆：<br><img src="/2020/06/30/数据结构/img2.png" alt="最大堆"></p>
<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈-Stack"></a>栈-Stack</h3><p>栈是只能在某一端插入和删除的特殊线性表。<br>按照先进后出或后进先出（LIFO—last in first out）的原则存储数据，最先进入栈内的被压入栈底，最后的数据子栈顶。<br>入栈：往栈内添加元素<br>出栈：从栈内删除元素</p>
<p><strong>使用数组实现一个栈</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现一个先进后出的栈结构</span><br><span class="line"> * 添加元素push</span><br><span class="line"> * 弹出元素pop</span><br><span class="line"> * 返回栈顶元素top</span><br><span class="line"> * 是否空栈isEmpty</span><br><span class="line"> * 返回元素个数size</span><br><span class="line"> * 清空栈元素clear</span><br><span class="line"> */</span><br><span class="line">function MyStack() &#123;</span><br><span class="line">  let items = []; //内部变量，保护</span><br><span class="line">  //方法</span><br><span class="line">  //向栈顶添加元素</span><br><span class="line">  this.push = function (value) &#123;</span><br><span class="line">    items.push(value);</span><br><span class="line">  &#125;;</span><br><span class="line">  //弹出栈顶元素,返回</span><br><span class="line">  this.pop = function () &#123;</span><br><span class="line">    return items.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  //返回栈顶元素</span><br><span class="line">  this.top = function () &#123;</span><br><span class="line">    return items[items.length - 1];</span><br><span class="line">  &#125;;</span><br><span class="line">  //判断栈是否为空</span><br><span class="line">  this.isEmpty = function () &#123;</span><br><span class="line">    return items.length === 0;</span><br><span class="line">  &#125;;</span><br><span class="line">  //返回栈里元素个数</span><br><span class="line">  this.size = function () &#123;</span><br><span class="line">    return items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  //情况栈元素</span><br><span class="line">  this.clear = function () &#123;</span><br><span class="line">    items = [];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>栈的应用</strong></p>
<ul>
<li><p>判断括号是否合法<br>思路：如果是<code>(</code>就入栈，如果是<code>)</code>就查看栈是否为空，如果栈为空就不合法，如果不为空，就弹出一个栈顶元素。循环结束，查看栈是否为空，为空就是合法，否则就不合法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function is_leagl_brackets(string) &#123;</span><br><span class="line">let stack = new MyStack();</span><br><span class="line">for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">    let str = string[i];</span><br><span class="line">    if (str === &quot;(&quot;) &#123;</span><br><span class="line">    stack.push(str);</span><br><span class="line">    &#125; else if (str === &quot;)&quot;) &#123;</span><br><span class="line">    if (stack.isEmpty()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">console.log(is_leagl_brackets(&quot;()()))&quot;));//false</span><br><span class="line">console.log(is_leagl_brackets(&quot;(sd(qwqw)sd(sd))&quot;));//true</span><br><span class="line">console.log(is_leagl_brackets(&quot;()()sd()(sd()fw))(&quot;));//false</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算逆波拉表达式<br>逆波兰表达式也叫后缀表达式，将复杂的表达式转换为可以依靠简单的操作得到计算结果的表达式，例如<code>(a+b)*(c+d)</code>转换为<code>ab+cd+*</code><br>根据简单的逆波兰表达式数组，计算表达式结果。<br>思路：如果是数字就入栈，如果是符号（只是简单的例子，不考虑错误的情况）就连续弹出两个栈顶元素，用两个元素和操作符组成计算表达式（第二个元素在操作符左边），利用<code>eval</code>计算结果，取整，变成字符串再放入栈中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function calc_exp(arr) &#123;</span><br><span class="line">let stack = new MyStack();</span><br><span class="line">arr.forEach((item) =&gt; &#123;</span><br><span class="line">    if ([&quot;+&quot;, &quot;-&quot;, &quot;/&quot;, &quot;*&quot;].indexOf(item) &gt; -1) &#123;</span><br><span class="line">    let v1 = stack.pop();</span><br><span class="line">    let v2 = stack.pop();</span><br><span class="line">    let exp = v2 + item + v1;</span><br><span class="line">    let result = parseInt(eval(exp));</span><br><span class="line">    stack.push(result.toString());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    stack.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">return stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">console.log(calc_exp([&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]));//6</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个有 min 方法的栈<br>思路：利用两个栈，一个存放数据，一个存放最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MinStack() &#123;</span><br><span class="line">let data_stack = new MyStack(); //存储数据</span><br><span class="line">let min_stack = new MyStack(); //存储最小值</span><br><span class="line">//入栈</span><br><span class="line">this.push = function (item) &#123;</span><br><span class="line">    data_stack.push(item);</span><br><span class="line">    //如果最小值栈是空的或当前元素小于最小栈顶元素，就入栈到最小栈顶</span><br><span class="line">    if (min_stack.isEmpty() || item &lt; min_stack.top()) &#123;</span><br><span class="line">    min_stack.push(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //如果当前值大于最小值栈顶元素，就把最小值栈顶元素再次入栈</span><br><span class="line">    min_stack.push(min_stack.top());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//出栈</span><br><span class="line">this.pop = function () &#123;</span><br><span class="line">    min_stack.pop();</span><br><span class="line">    return data_stack.pop();</span><br><span class="line">&#125;;</span><br><span class="line">//最小值</span><br><span class="line">this.min = function () &#123;</span><br><span class="line">    return min_stack.top();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let minStack = new MinStack();</span><br><span class="line">minStack.push(3);</span><br><span class="line">console.log(minStack.min()); //3</span><br><span class="line">minStack.push(6);</span><br><span class="line">console.log(minStack.min()); //3</span><br><span class="line">minStack.push(9);</span><br><span class="line">console.log(minStack.min()); //3</span><br><span class="line">minStack.push(1);</span><br><span class="line">console.log(minStack.min()); //1</span><br><span class="line">minStack.pop();</span><br><span class="line">console.log(minStack.min()); //3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列-Queue"></a>队列-Queue</h3><p>队列也是一种操作受限制的线性表。<br>只允许在前端（头）进行删除操作，在后端（尾）进行插入操作。所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）<br>队列没有元素时，成为空队列。<br>入队：往队列中插入元素<br>出队：从队列中删除元素</p>
<p><strong>使用数组实现一个队列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * enqueue从队列尾部添加一个元素</span><br><span class="line"> * dequeue从队列头部删除一个元素</span><br><span class="line"> * head返回头部的元素</span><br><span class="line"> * size 返回队列大小</span><br><span class="line"> * clear 清空对列</span><br><span class="line"> * isEmpty 判断队列是否为空</span><br><span class="line"> */</span><br><span class="line">function MyQueue() &#123;</span><br><span class="line">  let items = [];</span><br><span class="line">  //入队</span><br><span class="line">  this.enqueue = function (item) &#123;</span><br><span class="line">    items.push(item);</span><br><span class="line">  &#125;;</span><br><span class="line">  //出队</span><br><span class="line">  this.dequeue = function () &#123;</span><br><span class="line">    return items.shift();</span><br><span class="line">  &#125;;</span><br><span class="line">  //返回头部元素</span><br><span class="line">  this.head = function () &#123;</span><br><span class="line">    return items[0];</span><br><span class="line">  &#125;;</span><br><span class="line">  //返回队列大小</span><br><span class="line">  this.size = function () &#123;</span><br><span class="line">    return items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  //清空队列</span><br><span class="line">  this.clear = function () &#123;</span><br><span class="line">    items = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  //队列是否为空</span><br><span class="line">  this.isEmpty = function () &#123;</span><br><span class="line">    return items.length === 0;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>队列的应用</strong></p>
<ul>
<li><p>约瑟夫环<br>题目：一个数组<code>a[100]</code>存放<code>0-99</code>，要求每隔两个数删掉一个数，到末尾时循环至开头继续执行（删除逻辑也是继续），求最后一个被删掉的数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function circle(arr_list) &#123;</span><br><span class="line">let queue = new MyQueue();</span><br><span class="line">arr_list.forEach((v) =&gt; queue.enqueue(v));</span><br><span class="line">let index = 0;</span><br><span class="line">while (queue.size() &gt; 1) &#123;</span><br><span class="line">    let item = queue.dequeue();</span><br><span class="line">    index++;</span><br><span class="line">    if (index % 3 != 0) &#123;</span><br><span class="line">    queue.enqueue(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return queue.head();</span><br><span class="line">&#125;</span><br><span class="line">let arr_list = new Array(100).fill(0).map((v, i) =&gt; i);</span><br><span class="line">console.log(circle(arr_list));</span><br></pre></td></tr></table></figure>
</li>
<li><p>斐波那契数列<br>公式：<code>fn= f(n-2)+f(n-1)</code><br>前两位是 1，1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib(n) &#123;</span><br><span class="line">  if (n === 1 || n === 2) return 1;</span><br><span class="line">  let queue = new MyQueue();</span><br><span class="line">  //初始值前两位是1</span><br><span class="line">  queue.enqueue(1);</span><br><span class="line">  queue.enqueue(1);</span><br><span class="line">  let index = 2;</span><br><span class="line">  while (index &lt; n) &#123;</span><br><span class="line">      //弹出队头</span><br><span class="line">      let num1 = queue.dequeue();</span><br><span class="line">      //获取队头</span><br><span class="line">      let num2 = queue.head();</span><br><span class="line">      //计算下一个数据</span><br><span class="line">      let num3 = num1 + num2;</span><br><span class="line">      //将新数据入队</span><br><span class="line">      queue.enqueue(num3);</span><br><span class="line">      index++;</span><br><span class="line">  &#125;</span><br><span class="line">  //弹出队头</span><br><span class="line">  queue.dequeue();</span><br><span class="line">  return queue.head();</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;fib&quot;, fib(5));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="JavaScript-内存空间"><a href="#JavaScript-内存空间" class="headerlink" title="JavaScript 内存空间"></a>JavaScript 内存空间</h3><h4 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h4><p>JavaScript 的内存生命周期：</p>
<ol>
<li>为变量分配所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不再使用时将其销毁，释放内存</li>
</ol>
<p>内存管理不善，会出现内存泄漏，造成浏览器内存占用过多，页面卡顿等问题。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 20;  // 在内存中给数值变量分配空间</span><br><span class="line">alert(a + 100);  // 使用内存</span><br><span class="line">a = null; // 使用完毕之后，释放内存空间</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>JavaScript 有自动的垃圾回收机制，会通过标记清除的算法，找出不再继续使用的变量对象，释放其内存。<br>开发者也可通过设置<code>a=null</code>手动标记清除，让其原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾回收执行时找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。<br>局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。<br>全局环境只有页面退出时才会出栈，解除变量引用。所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标记清除，将其内存释放掉。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>JS-EventLoop</title>
    <url>/2020/06/30/JS-EventLoop/</url>
    <content><![CDATA[<p>JavaScript 事件循环<br>进程与线程<br>单线程的非阻塞脚本语言<br>同步任务和异步任务</p>
<p><strong>参考：</strong><br><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂 Event Loop（彻底解决此类面试问题）</a></p>
<a id="more"></a>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是程序在执行过程中分配和管理资源的基本单位，<br>线程是 CPU 调度和分配的基本单位，它可与同属于一个进程的其他线程共享进程所拥有的全部资源。<br>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。<br>一个进程可以包含多个线程。<br>单个 CPU 总是运行一个进程，其他进程处于非运行状态。<br>一个 CPU 的一个时间点上运行的可能是一个进程上的不同线程。<br>可以简单的比喻：线程=车厢，进程=火车。</p>
<h2 id="JavaScript-是单线程的非阻塞脚本语言"><a href="#JavaScript-是单线程的非阻塞脚本语言" class="headerlink" title="JavaScript 是单线程的非阻塞脚本语言"></a>JavaScript 是单线程的非阻塞脚本语言</h2><h3 id="什么是单线程"><a href="#什么是单线程" class="headerlink" title="什么是单线程"></a>什么是单线程</h3><p>主程序只有一个线程，即同一时间片段内主程序只能执行单个任务。</p>
<h3 id="为什么-JavaScript-是单线程"><a href="#为什么-JavaScript-是单线程" class="headerlink" title="为什么 JavaScript 是单线程"></a>为什么 JavaScript 是单线程</h3><p>因为 JavaScript 的执行环境是浏览器。主要用途是与用户互动，以及操作 DOM。<br>例如，操作 Dom 的时候，如果是多线程的操作一个 Dom，一个向其添加事件，而另一个删除了这个 dom，这时无法处理。</p>
<h3 id="单线程意味着什么"><a href="#单线程意味着什么" class="headerlink" title="单线程意味着什么"></a>单线程意味着什么</h3><p>单线程意味着，JavaScript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>
<h3 id="如何解决单线程带来的性能问题"><a href="#如何解决单线程带来的性能问题" class="headerlink" title="如何解决单线程带来的性能问题"></a>如何解决单线程带来的性能问题</h3><p><strong>异步</strong>。所以 JavaScript 是非阻塞，意味着当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后异步任务返回结果的时候再根据一定规则去执行相应的回调。<br>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><ul>
<li>宏任务（MacroTask/Task）<ul>
<li>script 全部代码、</li>
<li>setTimeout、</li>
<li>setInterval、setImmediate（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN）</li>
<li>I/O、</li>
<li>postMessage、</li>
<li>UI Rendering。</li>
</ul>
</li>
<li>微任务（MicroTask/jobs）<ul>
<li>Process.nextTick（Node 独有）、</li>
<li>Promise()、</li>
<li>await、</li>
<li>MutationObserver(html5 新特性)</li>
<li>Object.observe(废弃)、<br><strong>setTimeout/Promise 等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</strong> 所以 setTimeout 和 Promise 是立即执行的，setTimeout 的第一个参数-回调函数，和 Promise 的 then 方法才会放到任务队列中。</li>
</ul>
</li>
</ul>
<h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><h3 id="执行栈-函数调用栈（call-stack）"><a href="#执行栈-函数调用栈（call-stack）" class="headerlink" title="执行栈/函数调用栈（call stack）"></a>执行栈/函数调用栈（call stack）</h3><p>同步代码的执行，按照顺序添加到执行栈中<br><img src="/2020/06/30/JS-EventLoop/img1.gif" alt="执行栈"><br><img src="/2020/06/30/JS-EventLoop/img2.gif" alt="执行栈1"></p>
<h3 id="任务队列-事件队列"><a href="#任务队列-事件队列" class="headerlink" title="任务队列/事件队列"></a>任务队列/事件队列</h3><p>异步代码的执行。遇到异步事件，主线程不会等待，而是将事件挂起，继续执行栈中的其他任务。<code>当异步任务返回结果，将他放到事件队列中</code>，被放入事件队列不会立刻执行起回调，而是等待当前执行栈中所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;start&apos;)</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;1000s-setTimeout&apos;)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;500s-setTimeout&apos;)</span><br><span class="line">&#125;, 500)</span><br><span class="line"></span><br><span class="line">console.log(&apos;end&apos;);</span><br><span class="line">//start</span><br><span class="line">//end</span><br><span class="line">//500s-setTimeout</span><br><span class="line">//1000s-setTimeout</span><br></pre></td></tr></table></figure>
<h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务<br>异步任务： 异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。</p>
<h3 id="事件循环顺序"><a href="#事件循环顺序" class="headerlink" title="事件循环顺序"></a>事件循环顺序</h3><ol>
<li>script(整体代码)开始第一次循环,之后全局上下文进入函数调用栈。</li>
<li>如果遇到微任务，先将异步任务交给对应的线程，当异步任务满足条件需要执行时，异步代码压入微任务队列中，同理宏任务进入宏任务队列；</li>
<li>调用栈清空(只剩全局)，然后从微任务队列的队头依次取出微任务并执行，如果遇到其他宏任务和微任务，按照上一步执行，直到清空微任务队列</li>
<li>取出队头的宏任务执行，执行步骤同 2-3，一直循环下去。</li>
</ol>
<ul>
<li>例子 1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;start&apos;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;)</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;end&apos;)</span><br></pre></td></tr></table></figure>
<p>步骤（盗图，懂了，就不想画了）<br><img src="/2020/06/30/JS-EventLoop/img3.gif" alt="执行栈"><br><strong>重点</strong>，因为例子中的 setTimeout 的延迟是 0，所以是立刻入队（宏任务队列）的，如果是<code>1000</code>就是 1s 后入队，如果宏任务队列内没有其他任务，并且主程序空闲（没有其他宏任务，微任务清空），就会执行，这样就是延迟 1s 执行。否则主程序还在执行其他任务，即使 1s 后入队，延迟时间会大于 1s。</p>
<ul>
<li><p>例子 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;script start&apos;)</span><br><span class="line"></span><br><span class="line">async function async1() &#123;</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(&apos;async1 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&apos;Promise&apos;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;)</span><br><span class="line">//新 script start - async2 end - Promise - script end - async1 end - promise1 - promise2</span><br><span class="line"> //旧 script start - async2 end - Promise - script end - promise1 - promise2 - async1 end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先 async/await 在底层转换成了 promise 和 then 回调函数，是 promise 的语法糖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(&apos;async1 end&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化理解：<br><strong>老版浏览器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         async2();</span><br><span class="line">        // Promise.resolve() 将代码插入微任务队列尾部</span><br><span class="line">        // resolve 再次插入微任务队列尾部</span><br><span class="line">        resolve(Promise.resolve())</span><br><span class="line">    &#125;).then(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;async1 end&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>await</code>后面返回还是<code>Promise</code>的话，<code>Promise.resolve()</code>先进入微任务队列，这样函数<code>async1</code>就会挂起，代码接着执行下面的<code>Promise</code>，<code>promise1</code>和<code>promise2</code>进入微任务队列。最后这一轮微任务队列清空输出<code>promise1</code>和<code>promise2</code>，<code>resolve(Promise.resolve())</code>执行， <code>console.log(&#39;async1 end&#39;)</code>才进入微任务队列。<br><strong>新版浏览器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return Promise.resolve(async2())</span><br><span class="line">    .then(()=&gt;&#123;</span><br><span class="line">        console.log(&apos;async1 end&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比老版减少了一次 Promise</p>
<h2 id="Node-中的-Event-Loop"><a href="#Node-中的-Event-Loop" class="headerlink" title="Node 中的 Event Loop"></a>Node 中的 Event Loop</h2><p><img src="/2020/06/30/JS-EventLoop/img3.png" alt="node"></p>
<h3 id="分为-6-个阶段"><a href="#分为-6-个阶段" class="headerlink" title="分为 6 个阶段"></a>分为 6 个阶段</h3><ul>
<li><ol>
<li><p><code>定时器检测阶段(timers)</code><br>执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation(callback) &#123;</span><br><span class="line">// Assume this takes 95ms to complete</span><br><span class="line">fs.readFile(&apos;/a.js&apos;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeoutScheduled = Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">const delay = Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line">// do someAsyncOperation which takes 95 ms to complete</span><br><span class="line">someAsyncOperation(() =&gt; &#123;</span><br><span class="line">const startCallback = Date.now();</span><br><span class="line"></span><br><span class="line">// do something that will take 10ms...</span><br><span class="line">while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    // do nothing</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>理论上<code>setTimeout</code>的回调函数是<code>100ms</code>后执行,但是，当进入事件循环时，它有一个空队列（fs.readFile()尚未完成），因此定时器将等待剩余毫秒数，当到达 95ms 时，fs.readFile()完成读取文件并且其需要 10 毫秒完成回调添加到轮询队列并执行。<br>当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的阈值，然后回到 timers 阶段以执行定时器的回调。<br>在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为 105 毫秒左右。<br><img src="/2020/06/30/JS-EventLoop/img4.png" alt="node"></p>
</li>
<li><ol start="2">
<li><code>I/O事件回调阶段(I/O callbacks)</code>/<code>pending callback</code><br>上一轮循环中少数的<code>callback</code>会放在这一阶段执行</li>
</ol>
</li>
<li><ol start="3">
<li><code>闲置阶段(idle, prepare)</code>：仅在内部使用</li>
</ol>
</li>
<li><ol start="4">
<li><code>轮询阶段(poll)</code>：<br>用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。<br>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</li>
</ol>
<ul>
<li>回到<code>timer</code>阶段执行回调</li>
<li><p>执行 <code>I/O</code> 回调</p>
<p>并且在进入该阶段时如果没有设定了 <code>timer</code> 的话，会发生以下两件事情</p>
</li>
<li><p>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</p>
</li>
<li>如果 <code>poll</code> 队列为空，则会发生以下两种情况之一：<ul>
<li>如果有<code>setImmediate()</code>回调需要执行，则会立即停止执行<code>poll</code>阶段并进入执行 <code>check</code> 阶段以执行回调。</li>
<li>如果没有<code>setImmediate()</code>回到需要执行，<code>poll</code> 阶段将等待 <code>callback</code> 被添加到队列中，然后立即执行。<br>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="5">
<li><p><code>检查阶段(check)</code><br>此阶段允许人员在 poll 阶段完成后立即执行回调。<br>如果 poll 阶段闲置并且 script 已排队 setImmediate()，则事件循环到达 check 阶段执行而不是继续等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用 <code>libuv API</code> 来调度在 poll 阶段完成后执行的回调。</p>
<p>通常，当代码被执行时，事件循环最终将达到 poll 阶段，它将等待传入连接，请求等。<br>但是，如果已经调度了回调 setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达 check 阶段，而不是等待 poll 事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;start&apos;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&apos;timer1&apos;)</span><br><span class="line"> Promise.resolve().then(function() &#123;</span><br><span class="line">   console.log(&apos;promise1&apos;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;timer2&apos;)</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise3&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br></pre></td></tr></table></figure>
<p>如果 node 版本为 v11.x， 其结果与浏览器一致。执行一个宏任务之后都去清空微任务队列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>
<p>如果 v10 版本上述结果存在两种情况：</p>
<ul>
<li><p>如果 time2 定时器已经在执行队列中了,先清空完 timer 队列再清空执行微任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src="/2020/06/30/JS-EventLoop/img5.gif" alt="timer"> - 如果 time2 定时器没有在执行对列中，执行结果为（没看到这种情况，我的理解是 timer1 执行的很快，timer2 还没进入队列），执行结果跟 v11.1 效果一样</p>
</li>
<li><ol start="6">
<li><code>关闭事件回调阶段(close callbacks)</code><br>执行 close 事件</li>
</ol>
</li>
</ul>
<h3 id="setImmediate-的-setTimeout-的区别"><a href="#setImmediate-的-setTimeout-的区别" class="headerlink" title="setImmediate() 的 setTimeout()的区别"></a>setImmediate() 的 setTimeout()的区别</h3><ul>
<li>setImmediate()设计用于在当前 poll 阶段完成后 check 阶段执行脚本 。</li>
<li><p>setTimeout() 安排在经过最小（ms）后运行的脚本，在 timers 阶段执行。<br><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(&apos;timeout&apos;);</span><br><span class="line"></span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">console.log(&apos;immediate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。<br>如果在 <code>I/O</code>周期内移动两个调用，则始终首先执行立即回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;immediate&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其结果可以确定一定是<code>immediate =&gt; timeout</code>。<br>主要原因是在 <code>I/O</code> 阶段读取文件后，事件循环会先进入 <code>poll</code> 阶段，发现有 <code>setImmediate</code> 需要执行，会立即进入 <code>check</code> 阶段执行 <code>setImmediate</code> 的回调。<br>然后再进入<code>timers</code>阶段，执行<code>setTimeout</code>，打印<code>timeout</code>。</p>
<h3 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h3><p><code>process.nextTick()</code>虽然它是异步 API 的一部分，但未在图中显示。这是因为从技术上讲，它不是事件循环的一部分。它有一个自己的队列，当每个阶段完成后，如果存在 <code>nextTick</code> 队列，就会清空队列中的所有回调函数，并且优先于其他 <code>microTask</code> 执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bar;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setImmediate&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;bar&apos;, bar); // 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = 1;</span><br></pre></td></tr></table></figure>
<p>对于以上代码，大家可以发现无论如何，永远都是先把 nextTick 全部打印出来。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-this指向</title>
    <url>/2020/06/26/JS-this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>确定 this 指向</p>
<a id="more"></a>
<p><code>this</code>的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定<code>this</code>到底指向谁，实际上<code>this</code>的最终指向的是那个调用它的对象。</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><ul>
<li>浏览器环境，严格模式或非严格模式<code>this</code>指向<code>Window</code>对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&apos;非严格模式&apos;)</span><br><span class="line">  console.log(&apos;this === window&apos;, this === window)</span><br><span class="line">  console.log(&apos;this.document === document&apos;, this.document === document)</span><br><span class="line">  this.a = &apos;test&apos;;</span><br><span class="line">  console.log(&apos;this.a === window.a&apos;, this.a === window.a)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>node 环境，指定<code>空对象{}</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;this&quot;, this);//window</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/26/JS-this指向/img1.png" alt="全局作用域"></p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><ul>
<li>浏览器环境，非严格模式，<code>this</code>指向<code>window</code>;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function a() &#123;</span><br><span class="line">    console.log(&apos;非严格模式-函数&apos;)</span><br><span class="line">    console.log(&apos;this === window&apos;, this === window)</span><br><span class="line">    console.log(&apos;this.document === document&apos;, this.document === document)</span><br><span class="line">    this.a = &apos;test&apos;;</span><br><span class="line">    console.log(&apos;this.a === window.a&apos;, this.a === window.a)</span><br><span class="line">  &#125;</span><br><span class="line">  a()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/26/JS-this指向/img2.png" alt="非严格模式-函数"></p>
<ul>
<li>浏览器环境，严格模式，<code>this</code>指向<code>undefined</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    console.log(&apos;严格模式-函数&apos;,this)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/26/JS-this指向/img3.png" alt="严格模式-函数"></p>
<ul>
<li>node 环境，<code>this</code>指向<code>global</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&quot;foo&quot;, this);//global</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li>浏览器环境<br>箭头函数中没有<code>this</code>绑定，必须通过查找作用域链来决定其值。 如果箭头函数被非箭头函数包含，则<code>this</code>绑定的是最近一层非箭头函数的<code>this</code>，否则<code>this</code>的值则被设置为全局对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   function b() &#123;</span><br><span class="line">        this.c = &apos;test&apos;;</span><br><span class="line">        let that = this;</span><br><span class="line">        const a = () =&gt; &#123;</span><br><span class="line">            console.log(&apos;箭头函数&apos;)</span><br><span class="line">            console.log(&apos;this.c === that.c&apos;, this.c === that.c)//true</span><br><span class="line">        &#125;</span><br><span class="line">        a()</span><br><span class="line">    &#125;</span><br><span class="line">    b()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/26/JS-this指向/img4.png" alt="箭头函数"></p>
<ul>
<li><code>node</code>环境<br>与浏览器环境一样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  this.a = &quot;a&quot;;</span><br><span class="line">  let foo = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;foo&quot;, this.a);</span><br><span class="line">  &#125;;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<h2 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h2><p>如果函数作为对象的方法调用，<code>this</code> 指向的是这个上级对象，即调用方法的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name = &apos;window&apos;;</span><br><span class="line">  let doSth = function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  let student = &#123;</span><br><span class="line">      name: &apos;student_name&apos;,</span><br><span class="line">      doSth: doSth,</span><br><span class="line">      other: &#123;</span><br><span class="line">          name: &apos;other_name&apos;,</span><br><span class="line">          doSth: doSth</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  student.doSth(); //student_name</span><br><span class="line">  student.other.doSth(); //other_name</span><br><span class="line">  student.other.doSth.call(student); //student_name</span><br></pre></td></tr></table></figure>
<p>call 方法执行函数，传入的第一个参数就是 this 的指向<br>如果将对象方法赋值给变量就变成了普通函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let student = &#123;</span><br><span class="line">     name: &apos;student_name&apos;,</span><br><span class="line">     doSth: function () &#123;</span><br><span class="line">         console.log(this)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let stu_doSth = student.doSth;</span><br><span class="line"> stu_doSth(); //window</span><br></pre></td></tr></table></figure>
<h2 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h2><p>构造函数使用 new 调用的时候，如果没有返回 function 或者是 object，this 指向当前的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function showName(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">let obj = new showName(&apos;obj&apos;);</span><br><span class="line">let obj1 = new showName(&apos;obj1&apos;);</span><br><span class="line">console.log(obj.name);//obj</span><br><span class="line">console.log(obj1.name);//obj1</span><br></pre></td></tr></table></figure>
<h2 id="call、apply-和-bind"><a href="#call、apply-和-bind" class="headerlink" title="call、apply 和 bind"></a>call、apply 和 bind</h2><p>this 是第一个参数，bind 不会执行，返回绑定好的函数。apply 的第二个参数是数组。</p>
<ul>
<li>如果第一个参数值是<code>undefined</code>或<code>null</code>，严格模式下 <code>this</code> 的值为传入的值<code>null</code>或<code>undefined</code>，非严格模式下，<code>this</code> 指向全局对象(node 环境为 global，浏览器环境为 window)。</li>
<li>如果第一个参数没有传入，非严格模式，指向 <code>window/global</code>，严格模式指向<code>undefined</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(c, d) &#123;</span><br><span class="line">    return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3</span><br><span class="line">&#125;</span><br><span class="line">console.log(add.call(o, 5, 7)) //16</span><br><span class="line">console.log(add.bind(o, 1, 2))</span><br><span class="line">//ƒ add(c, d) &#123;</span><br><span class="line">//return this.a + this.b + c + d;</span><br><span class="line">//&#125;</span><br><span class="line">console.log(add.apply(o, [10, 20]))  //34</span><br></pre></td></tr></table></figure>
<ul>
<li>如果第一个参数值为原始值(数字，字符串，布尔值)的 <code>this</code> 会指向该原始值的自动包装对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var doSth = function (name) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">  console.log(name);</span><br><span class="line">&#125;;</span><br><span class="line">doSth.call(2, &quot;name&quot;); // Number&#123;2&#125;, &apos;name&apos;</span><br></pre></td></tr></table></figure>
<h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>在严格模式下，在事件处理函数中，this 指向触发事件的目标对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">   let btn = document.getElementById(&apos;loginBtn&apos;);</span><br><span class="line">   btn.onclick = function (e) &#123;</span><br><span class="line">       console.log(e.target === this)//true</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后<br>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ul>
<li>new 调用：绑定到新创建的对象，注意：显示 return 函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li>
<li>call 或者 apply（ 或者 bind） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null 和 undefined，指向全局对象（浏览器中是 window），其余值指向被 new Object()包装的对象。</li>
<li>对象上的函数调用：绑定到那个对象。</li>
<li>普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-CommonJS</title>
    <url>/2020/06/22/JS-CommonJS/</url>
    <content><![CDATA[<p>前端模块化——CommonJS</p>
<a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块可以多次加载，但是只会在第一次加载运行，然后运行结果被缓存，以后的加载就直接读取缓存，要想模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<p>每个文件就是一个模块，有自己的作用域，在一个文件中的变量、函数、类都是私有的对其他文件不可见。<br>如果多个文件分享变量，必须定义为<code>global</code>对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global.warning = true;</span><br></pre></td></tr></table></figure>
<p>上面代码的 warning 变量，可以被所有文件读取。当然，这样写法是不推荐的。</p>
<p>Node.js 是 commonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。<br>用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块。</p>
<h2 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h2><p>Node 内部提供一个 Module 构建函数。所有模块都是 Module 的实例。<br>每个模块中都会有一个内置对象<code>module</code>，表示当前模块。<br>在一个 node 文件中打印 module</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  id: &apos;.&apos;,</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &apos;/Users/fdd/fdd-project/html5/node/test.js&apos;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:</span><br><span class="line">   [ &apos;/Users/fdd/fdd-project/html5/node/node_modules&apos;,</span><br><span class="line">     &apos;/Users/fdd/fdd-project/html5/node_modules&apos;,</span><br><span class="line">     &apos;/Users/fdd/fdd-project/node_modules&apos;,</span><br><span class="line">     &apos;/Users/fdd/node_modules&apos;,</span><br><span class="line">     &apos;/Users/node_modules&apos;,</span><br><span class="line">     &apos;/node_modules&apos; ] &#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性</strong></p>
<ul>
<li>id：模块的唯一标示，根文件为.，引入的子模块就是文件的绝对路径</li>
<li>parent：对象，表示调用该模块的模块</li>
<li>children：数组，表示该模块调用的其他模块</li>
<li>filename：文件的绝对路径</li>
<li>paths：模块的地址，与后面的模块查找机制有关</li>
<li>loaded：布尔值，表示模块是否已经加载完成</li>
<li>exports：模块对外输出的值，加载某个模块，就是加载<code>module.exports</code>属性</li>
</ul>
<p>如果使用命令行调用模块，比如<code>node a.js</code>，那么<code>module.parent</code>就是 null，如果在其他脚本中调用，比如<code>require(&#39;./a.js&#39;)</code>，那么<code>module.parent</code>就是调用它的模块。利用这一点可以判断当前模块是否为入口脚本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!module.parent) &#123;</span><br><span class="line">    // ran with `node a.js`</span><br><span class="line">    app.listen(8088, function() &#123;</span><br><span class="line">        console.log(&apos;app listening on port 8088&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // used with `require(&apos;/.a.js&apos;)`</span><br><span class="line">    module.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exports-变量"><a href="#exports-变量" class="headerlink" title="exports 变量"></a>exports 变量</h2><p>Node 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exports=module.exports</span><br></pre></td></tr></table></figure>
<p>可以为 exports 添加属性或方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.area = function (r) &#123;</span><br><span class="line">  return Math.PI * r * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>不能为 exports 指向另一个值，这样 exports 不再与 module.exports 指向同一地址，同时 exports 也不会对外输出。</strong><br>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code>exports</code>输出，只能使用 <code>module.exports</code>输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = function (x)&#123; console.log(x);&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你觉得，<code>exports</code>与<code>module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code>exports</code>，只使用<code>module.exports</code>。</p>
<h2 id="require-命令"><a href="#require-命令" class="headerlink" title="require 命令"></a>require 命令</h2><p>Node 使用 CommonJS 模块规范，内置的 require 命令用于加载模块文件。<br>功能：读取 JS 文件，然后返回该模块的<code>module.exports</code>对象，如果没有发现指定模块。会报错。<br><strong>加载规则</strong></p>
<ol>
<li>默认加载<code>.js</code>文件</li>
<li>参数<ul>
<li>如果参数字符串以’/‘开头，表示一个绝对路径</li>
<li>如果参数字符串以’./‘开头，表示一个相对路径</li>
<li>如果参数字符串不以’/‘或’./‘开头，表示加载的是一个默认提供的核心模块（Node 的核心模块或 node_module 目录已安装的模块）。</li>
<li>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如 require(‘example-module/path/to/file’)，则将先找到 example-module 的位置，然后再以它为参数，找到后续路径。</li>
<li>如果指定的模块文件没有发现，Node 会尝试为文件名添加.js、.json、.node 后，再去搜索。.js 件会以文本格式的 JavaScript 脚本文件解析，.json 文件会以 JSON 格式的文本文件解析，.node 文件会以编译后的二进制文件解析。</li>
<li>如果想得到 require 命令加载的确切文件名，使用 require.resolve()方法。</li>
</ul>
</li>
</ol>
<p><strong>目录的加载规则</strong><br>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让 require 方法可以通过这个入口文件，加载整个目录。<br>例如，在目录中放置一个 package.json 文件，并且将入口文件写入 main 字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>require 发现参数字符串指向一个目录以后，会自动查看该目录的 package.json 文件，然后加载 main 字段指定的入口文件。如果 package.json 文件没有 main 字段，或者根本就没有 package.json 文件，则会加载该目录下的 index.js 文件或 index.node 文件。</p>
<p><strong>模块的缓存</strong><br>第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&quot;./test.js&quot;);</span><br><span class="line">require(&quot;./test.js&quot;).message = &quot;hello&quot;;</span><br><span class="line">let message = require(&quot;./test.js&quot;).message;</span><br><span class="line">console.log(message);//hello</span><br></pre></td></tr></table></figure>
<p>为模块添加的 message 依然存在，所以模块并没有重新加载。<br>所有缓存的模块保存在 require.cache 之中，如果想删除模块的缓存，可以像下面这样写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//删除指定模块的缓存</span><br><span class="line">// delete require.cache[moduleName];</span><br><span class="line">//删除所有模块的缓存</span><br><span class="line">Object.keys(require.cache).forEach((key) =&gt; &#123;</span><br><span class="line">  delete require.cache[key];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>moduleName:”/Users/home/html5/node/test.js”<br>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require 命令还是会重新加载该模块。</p>
<p><strong>require.main</strong><br>用来判断模块是直接执行，还是被调用执行。<br>直接执行的时候（node module.js），require.main 属性指向模块本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require.main===module;//true</span><br></pre></td></tr></table></figure>
<p>调用执行的时候（通过 require 加载该脚本执行），上面的表达式返回 false。</p>
<h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><p>输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//test.js</span><br><span class="line">var counter = 3;</span><br><span class="line">function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; counter, incCounter &#125;;</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">var counter = require(&quot;./test&quot;).counter;</span><br><span class="line">var incCounter = require(&quot;./test&quot;).incCounter;</span><br><span class="line">console.log(counter); //3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); //3</span><br></pre></td></tr></table></figure>
<p>上面代码说明，counter 输出以后，test.js 模块内部的变化就影响不到 counter 了。</p>
<p><strong>require 的内部处理流程</strong><br><code>require</code>不是全局命令，而是指向当前模块的<code>module.require</code>命令，而后者又调用 Node 的内部命令<code>Module._load</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">  // 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">  // 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">  // 3. 将它保存到缓存</span><br><span class="line">  // 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">  //    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">  // 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">  // 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>上面的第4步，采用module.compile()，执行指定模块的脚本，逻辑如下。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">  // 1. 生成一个require函数，指向module.require</span><br><span class="line">  // 2. 加载其他辅助方法到require</span><br><span class="line">  // 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">  // 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第 1 步和第 2 步，require 函数及其辅助方法主要如下。</p>
<ul>
<li>require(): 加载外部模块</li>
<li>require.resolve()：将模块名解析到一个绝对路径</li>
<li>require.main：指向主模块</li>
<li>require.cache：指向所有缓存的模块</li>
<li>require.extensions：根据文件的后缀名，调用不同的执行函数</li>
</ul>
<p>一旦 require 函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括 require、module、exports，以及其他一些参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">  // YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Module._compile 方法是同步执行的，所以 Module._load 要等它执行完成，才会向用户返回 module.exports 的值。</p>
<h1 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h1><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.js</span><br><span class="line">exports.done = false;</span><br><span class="line">var b = require(&apos;./b.js&apos;);</span><br><span class="line">console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done);</span><br><span class="line">exports.done = true;</span><br><span class="line">console.log(&apos;a.js 执行完毕&apos;);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，<code>a.js</code>脚本先输出一个 done 变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//b.js</span><br><span class="line">exports.done = false;</span><br><span class="line">var a = require(&apos;./a.js&apos;);</span><br><span class="line">console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done);</span><br><span class="line">exports.done = true;</span><br><span class="line">console.log(&apos;b.js 执行完毕&apos;);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，b.js 执行到第二行，就会去加载 a.js，这时，就发生了“循环加载”。系统会去 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值。<br>a.js 已经执行的部分，只有一行。<code>exports.done = false;</code><br>因此，对于 b.js 来说，它从 a.js 只输入一个变量 done，值为 false。<br>然后，b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js。于是，a.js 接着往下执行，直到执行完毕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//main.js</span><br><span class="line">var a = require(&apos;./a.js&apos;);</span><br><span class="line">var b = require(&apos;./b.js&apos;);</span><br><span class="line">console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.done);</span><br></pre></td></tr></table></figure>
<p>执行 main.js，运行结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = false</span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = true</span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=true, b.done=true</span><br></pre></td></tr></table></figure>
<p>上面的代码证明了两件事。一是，在 b.js 之中，a.js 没有执行完毕，只执行了第一行。二是，main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行<code>exports.done = true;</code>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-异步编程</title>
    <url>/2020/06/22/JS-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>JS 异步编程以及面试题</p>
<a id="more"></a>
<h2 id="并发（concurrency）和并行-parallelism-区别"><a href="#并发（concurrency）和并行-parallelism-区别" class="headerlink" title="并发（concurrency）和并行(parallelism)区别"></a>并发（concurrency）和并行(parallelism)区别</h2><ul>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。<br>通常在多处理器系统中存在。<br><img src="/2020/06/22/JS-异步编程/img1.webp" alt="并行"></li>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br>并发可以在单处理器和多处理器系统中都存在。<br>在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）<br><img src="/2020/06/22/JS-异步编程/img2.webp" alt="并发"></li>
</ul>
<p>当有多个线程在操作时，如果系统只有一个 <code>CPU</code>，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（<code>Concurrent</code>）。<br>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 <code>CPU</code> 执行一个线程时，另一个 <code>CPU</code> 可以执行另一个线程，两个线程互不抢占 <code>CPU</code> 资源，可以同时进行，这种方式我们称之为并行（<code>Parallel</code>）。</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul>
<li>同步编程，即是一种典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码。</li>
<li>异步编程，不同于同步编程的请求-响应模式，其是一种事件驱动编程，请求调用函数或方法后，无需立即等待响应，可以继续执行其他任务，而之前任务响应返回后可以通过状态、通知和回调来通知调用者。</li>
</ul>
<h2 id="回调函数（Callback）"><a href="#回调函数（Callback）" class="headerlink" title="回调函数（Callback）"></a>回调函数（Callback）</h2><p>把一个函数作为参数传递给另一个函数，并在此函数中执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&apos;/test.html&apos;,function(data)&#123;</span><br><span class="line">   // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>回调地狱的根本问题是：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会影响其他嵌套函数</li>
<li>嵌套函数难以处理错误</li>
</ol>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul>
<li><code>setTimeout</code>,<br><code>setTimeOut</code>产生一个宏任务，加入宏任务队列，等待当前宏任务执行完毕并且清空了微任务才会从宏任务队列中按照先进先出原则执行下一个宏任务。<br>因 JavaScript 是单线程的，所以<code>setTimeout</code>不一定会按照设置的延迟时间准时执行，如果当前宏任务和微任务执行花费的时间大于设置的延迟时间，可能延后。</li>
<li><p><code>setInterval</code><br>每隔一段时间执行一次回调函数。<br>通常不建议使用<code>setInterval</code>，第一，不能保证在预期的时间执行任务。第二，存在执行累积的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">  setInterval(function()&#123;</span><br><span class="line">      console.log(2)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">  sleep(2000)</span><br><span class="line"> &#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<ul>
<li><p><code>requestAnimationFrame</code><br>参数：回调函数。<br>返回值：一个整数，表示定时器的编号。可以传递给<code>cancelAnimationFrame</code>用于取消动画。<br>告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。<br><strong>注意</strong>，如果想在浏览器下次重绘之前继续更新下一帧动画，回调函数自身必须再次调用<code>window.requestAnimationFrame()</code>。<br><code>setTimeout</code> 和 <code>setInterval</code> 的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。<br><code>requestAnimationFrame</code>采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p><strong>特点</strong></p>
<ol>
<li>把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li>
<li>在隐藏或不可见的元素中，<code>requestAnimationFrame</code>将不会进行重绘或回流。</li>
<li><code>requestAnimationFrame</code>是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;div id=&apos;process&apos; style=&quot;background-color: lightblue;width: 0;height: 20px;line-height: 20px;&quot;&gt;0%&lt;/div&gt;</span><br><span class="line">&lt;button id=&apos;loginBtn&apos;&gt;loginBtn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//js</span><br><span class="line">let process = document.getElementById(&apos;process&apos;);</span><br><span class="line">let btn = document.getElementById(&apos;loginBtn&apos;);</span><br><span class="line">let timer = null;</span><br><span class="line">btn.onclick = () =&gt; &#123;</span><br><span class="line">    process.style.width = &apos;0&apos;;</span><br><span class="line">    window.cancelAnimationFrame(timer);</span><br><span class="line">    timer = window.requestAnimationFrame(loop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loop() &#123;</span><br><span class="line">    if (parseInt(process.style.width) &lt; 500) &#123;</span><br><span class="line">        process.style.width = parseInt(process.style.width) + 5 + &apos;px&apos;;</span><br><span class="line">        process.innerHTML = parseInt(process.style.width) / 5 + &apos;%&apos;;</span><br><span class="line">        timer = requestAnimationFrame(loop)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        window.cancelAnimationFrame(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>执行过程</p>
<p>执行步骤：</p>
<ol>
<li>Generator 函数执行后，生成一个指向内部状态的指针，也就是遍历器对象<code>Iterator</code>。</li>
<li>第一次调用<code>next</code>函数，函数参数会被忽略，函数会执行到<code>yield</code>就暂停，并且将<code>yield</code>后面跟的表达式的值作为<code>value</code>返回。<code>{value:value,done:true/false}</code>，但是<code>yield</code>返回的永远是<code>undefined</code>。</li>
<li>后续调用<code>next</code>函数，函数就会从上一次停下来的位置执行，并且<code>next</code>的参数会代替<code>yield</code>的返回值<code>undefined</code>，继续执行到下一个<code>yield</code>。返回<code>{value:value,done:true/false}</code></li>
<li>如果没有 yield，就会一直执行，直到遇到 return，将 return 后面的表达式的值返回，<code>{value:value ,done:true }</code>。</li>
<li>如果没有 return，则返回的对象<code>{value:undefined ,done:false }</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function *foo(x) &#123;</span><br><span class="line">let y = 2 * (yield (x + 1))</span><br><span class="line">let z = yield (y / 3)</span><br><span class="line">return (x + y + z)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5)//-&gt;1, 生成遍历器</span><br><span class="line">console.log(it.next()) // -&gt;2  执行x+1=6 返回&#123;value: 6, done: false&#125;，停止执行。即使执行it.next(11)，参数也会被忽略</span><br><span class="line">console.log(it.next(12)) //-&gt;3 参数12作为上次yield的返回值，y=2*12=24，然后返回 =&gt; &#123;value: 8, done: false&#125;，如果没有参数，就是y=2*undefined=NaN</span><br><span class="line">console.log(it.next(13)) // -&gt;4  z=13 5+24+13 返回&#123;value: 42, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>可以把上面的回调地狱的例子改成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function *fecth()&#123;</span><br><span class="line">    yield ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    yield ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    yield ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let it = fetch()</span><br><span class="line">let result1 = it.next()</span><br><span class="line">let result2 = it.next()</span><br><span class="line">let result3 = it.next()</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/writer#/notebooks/40257545/notes/36734731" target="_blank" rel="noopener">详情见 ES6—16、Generator 函数的语法</a><br><a href="https://www.jianshu.com/writer#/notebooks/40257545/notes/36734735" target="_blank" rel="noopener">详情见 ES6—17、Generator 函数的异步应用</a></p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      return ajax(url1)</span><br><span class="line">  &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      return ajax(url2)</span><br><span class="line">  &#125;).then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>
<p><a href="https://dorisfeng.github.io/2020/06/22/JS-Promise/">Promise</a></p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p><a href="https://www.jianshu.com/writer#/notebooks/40257545/notes/36722437" target="_blank" rel="noopener">async/await</a><br>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  return &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()) // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>async</code> 就是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，和 <code>then</code>中处理返回值一样，并且 <code>await</code> 只能配套 <code>async</code> 使用<br><code>async</code>和<code>await</code>是目前异步的终极解决方案，优点在于语义化更强，能够解决回调地狱问题。<br>缺点：如果几个异步操作没有依赖性，使用<code>await</code>会降低性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span><br><span class="line">  // 如果有依赖性的话，其实就是解决回调地狱的例子了</span><br><span class="line">  await fetch(url)</span><br><span class="line">  await fetch(url1)</span><br><span class="line">  await fetch(url2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序</strong><br>会等待<code>await</code>后面的语句或函数会放到微任务队列中，等待当前宏任务执行完毕，才去清空微任务队列，然后才会执行<code>await</code>下一行的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">let b = async () =&gt; &#123;</span><br><span class="line">    console.log(0,a);</span><br><span class="line">  a = a + await 10</span><br><span class="line">  console.log(&apos;2&apos;, a) // -&gt; &apos;2&apos; 10</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&apos;1&apos;, a) // -&gt; &apos;1&apos; 1</span><br><span class="line">// 0 0</span><br><span class="line">// 1 1</span><br><span class="line">// 2 10</span><br></pre></td></tr></table></figure>
<ol>
<li>先执行宏任务函数 b,打印<code>0 0</code>，接着<code>await 10</code>放大微任务队列，函数 b 停止执行，</li>
<li>宏任务接着执行<code>a++</code>, 打印<code>1 1</code></li>
<li>宏任务清空了，执行微任务，<code>a=a+10</code>，打印<code>2 10</code></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-Promise</title>
    <url>/2020/06/22/JS-Promise/</url>
    <content><![CDATA[<p>Promise，是一个代理对象，JavaScript 的异步操作解决方案，代表某个未来才会知道结果事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</p>
<a id="more"></a>
<h2 id="1、Promise-含义"><a href="#1、Promise-含义" class="headerlink" title="1、Promise 含义"></a>1、Promise 含义</h2><p>一种异步编程解决方案<br>Promise 是一个对象，获取异步操作的消息</p>
<p>使用<code>new</code>生成<code>Promise</code>对象的实例，构造函数内部的代码会立即执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&apos;new Promise&apos;);</span><br><span class="line">    resolve(&apos;success&apos;)</span><br><span class="line">    console.log(&apos;test&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;finish&apos;);</span><br><span class="line">//new Promise</span><br><span class="line">//test</span><br><span class="line">//finish</span><br></pre></td></tr></table></figure>
<p>特点：<br>1、对象的状态不受外界影响。<br>pending(进行中)，fulfilled(已成功)，rejected(已失败)<br>只有异步操作的解构可以决定当前是那种状态，任何其他操作都没办法改变这个状态<br>2、一旦状态改变，就不会再变。<br>状态只能从 pending 变为 fulfilled，或是从 pending 变为 rejected<br>resolved 代表 fulfilled</p>
<p>缺点<br>1、中途无法取消<br>2、如果不设置回调函数，Promise 内部错误不会抛出到外部<br>3、当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p>
<h2 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h2><p><code>Promise</code> 实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    if(/*异步操作成功*/)&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>resolve</code> 和 <code>reject</code> 函数是 <code>js</code> 引擎提供的。<br><code>promise</code> 实例生成以后，可以使用 <code>then</code> 方法分别指定 <code>resolved</code> 状态和 <code>rejected</code> 状态的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  value=&gt;&#123;</span><br><span class="line">    //success</span><br><span class="line">  &#125;,</span><br><span class="line">  error=&gt;&#123;</span><br><span class="line">    //failure</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>第二个回调函数是可选的，两个回调函数的参数都是生成实例的时候传出的<br><code>Promise</code>实例创建后立刻执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    console.log(&apos;Promise&apos;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;hi&apos;)</span><br><span class="line">//Promise</span><br><span class="line">//hi</span><br><span class="line">//resolved</span><br></pre></td></tr></table></figure>
<p>实例立刻执行所以先输出<code>Promise</code>，<code>then</code>里面的函数要等到所有同步任务执行完才执行，所以先输出<code>hi</code>再输出 <code>resolved</code>。<br>图片加载异步操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loadImageAsync(url)&#123;</span><br><span class="line">    return new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">      const image=new Image();</span><br><span class="line">      image.onload=function()&#123;</span><br><span class="line">        resolve(image)</span><br><span class="line">      &#125;</span><br><span class="line">      image.onerror=function()&#123;</span><br><span class="line">        reject(new  Error(&apos;Could not load image at&apos;+url))</span><br><span class="line">      &#125;</span><br><span class="line">      image.src=url</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reject 函数的参数通常是 Error 对象。<br>resolve 函数的参数有可能是数据，也有可能是另一个<code>Promise</code>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;reject(new Error(&apos;fail&apos;),3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;resolve(p1),1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(result=&gt;console.log(result))</span><br><span class="line">.catch(error=&gt;console.log(error))</span><br></pre></td></tr></table></figure>
<p><code>p2</code>的状态一秒之后变为 resolve，返回的是<code>p1</code>，<code>p1</code>定义时 3 秒后状态变为<code>reject</code>，所以再过两秒，<code>p1</code>变为<code>reject</code>。由于<code>p2</code>返回的是另一个<code>Promise</code>，所以<code>p2</code>的状态失效，下面的两个回调根据<code>p1</code>的执行结果执行。因此执行<code>.catch</code>，打印 <code>Error:fail</code>。</p>
<p><strong>注意</strong>，在创建<code>Promise</code>实例的时候调用函数<code>resolve</code>或是<code>reject</code>并不会终结 <code>Promise</code>的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;).then(value=&gt;console.log(value))</span><br><span class="line">//2</span><br><span class="line">//1</span><br></pre></td></tr></table></figure>
<p><code>Promise</code>实例会立刻执行，执行完，才会执行<code>.then</code>里面的语句，所以先 2 后 1。</p>
<h2 id="3、Promise-prototype-then"><a href="#3、Promise-prototype-then" class="headerlink" title="3、Promise.prototype.then"></a>3、Promise.prototype.then</h2><p><code>then</code> 方法是定义在 <code>Promise</code> 原型对象上的 为 <code>Promise</code> 实例状态变化添加回调函数。<br><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    if(成功)&#123;</span><br><span class="line">       resolve(1)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      reject(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then((value,error)=&gt;console.log(value, error))</span><br></pre></td></tr></table></figure>
<p>then 方法返回一个新的<code>Promise</code>实例，因此可以采用链式写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(result=&gt;&#123;</span><br><span class="line">    return result.data</span><br><span class="line">&#125;).then(data=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果<code>then</code>方法的回调函数返回的是<code>Promise</code>实例，后面的<code>then</code>方法会根据这<code>Promise</code>实例的状态变化才执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getJSON(&apos;/post/1.json&apos;).then(</span><br><span class="line">   post=&gt;getJSON(post.commonURL)</span><br><span class="line">).then(</span><br><span class="line">  newPost=&gt;&#123;console.log(&apos;resolved&apos;)&#125;,</span><br><span class="line">  error=&gt;&#123;console.log(&apos;rejected&apos;+error)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>第一个<code>then</code>方法的回调函数返回一个新的<code>Promise</code>实例，第二个<code>then</code>会根据这个 <code>Promise</code>的执行结果来判断是执行<code>resolved</code>还是<code>rejected</code>。</p>
<h2 id="4、Promise-prototype-catch"><a href="#4、Promise-prototype-catch" class="headerlink" title="4、Promise.prototype.catch"></a>4、Promise.prototype.catch</h2><p>用于指定发生错误时的回调函数<br>当<code>Promise</code>实例执行的时候抛出的错误状态就会变为<code>rejected</code>，然后就会执行<code>catch</code>方法，并且错误会作为参数传入<code>catch</code>的回调函数。<br>另外 <code>then</code> 方法的回调运行时抛出错误也会被 <code>catch</code> 捕获</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.then(val=&gt;console.log(&apos;fulfilled&apos;,val))</span><br><span class="line">.catch(err=&gt;console.log(&apos;rejected&apos;,err))</span><br><span class="line">//等同于</span><br><span class="line">p.then(val=&gt;console.log(&apos;fulfilled&apos;,val))</span><br><span class="line">.then(null ,err=&gt;console.log(&apos;rejected&apos;,err))</span><br></pre></td></tr></table></figure>
<p><code>reject</code>方法，等同于抛出错误，<code>throw Error</code><br>以下三种写法效果是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1</span><br><span class="line">new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">      throw new Error(&apos;test&apos;)</span><br><span class="line">&#125;).catch(err=&gt;console.log(&apos;rejected&apos;,err))</span><br><span class="line">//2</span><br><span class="line">new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      throw new Error(&apos;test&apos;)</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">      reject(e)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;).catch(err=&gt;console.log(&apos;rejected&apos;,err))</span><br><span class="line">//3</span><br><span class="line">new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    reject(new Error(&apos;test&apos;))</span><br><span class="line"> &#125;).catch(err=&gt;console.log(&apos;rejected&apos;,err))</span><br></pre></td></tr></table></figure>
<p>如果状态已经变为<code>resolved</code>再抛出错误是无效的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const`Promise`= new Promise(function(resolve, reject) &#123;</span><br><span class="line">  resolve(&apos;ok&apos;);</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(function(value) &#123; console.log(value) &#125;)</span><br><span class="line">  .catch(function(error) &#123; console.log(error) &#125;);</span><br><span class="line">// ok</span><br></pre></td></tr></table></figure>
<p>如果在<code>Promise</code>实例内部使用 <code>try/catch</code>，没有使用 <code>catch</code> 方法指定错误处理回调函数，抛出的错误不会返回到外部，即不会有任何反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  someAsync=function()&#123;</span><br><span class="line">    return new  Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">        resolve(x+2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">someAsync().then(</span><br><span class="line"> ()=&gt;console.log(&apos;everything is great&apos;)</span><br><span class="line">)</span><br><span class="line">setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);</span><br><span class="line">//ReferenceError: x is not defined</span><br><span class="line">//123</span><br></pre></td></tr></table></figure>
<p><code>Promise</code> 内部的语法错误，但是 123 还是打印出来，不会退出进程，终止整个脚本的执行<br><code>Promise</code> 内部的错误不会影响到 <code>Promise</code> 外部的代码，通俗的说法就是“Promise 会吃掉错误”</p>
<p><code>catch</code> 方法返回的还是一个 Promise，因此后面可以继续使用 <code>then</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;oh no&apos;, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function() &#123;</span><br><span class="line">  console.log(&apos;carry on&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// carry on</span><br></pre></td></tr></table></figure>
<p>上面的代码因为没有报错，跳过了<code>catch</code>方法，直接执行后面的<code>then</code>方法。此时，要是<code>then</code>方法里面报错，就与前面的<code>catch</code>无关了。<br><code>catch</code> 中也能抛出错误，并且可以被后面的 <code>catch</code> 捕获到。</p>
<h2 id="5、Promise-prototype-finally"><a href="#5、Promise-prototype-finally" class="headerlink" title="5、Promise.prototype.finally"></a>5、Promise.prototype.finally</h2><p><code>finally</code> 方法用于指定不管 <code>Promise</code> 对象的状态如何都会执行的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result=&gt;&#123;&#125;)</span><br><span class="line">.catch(error=&gt;&#123;&#125;)</span><br><span class="line">.finally(()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>finally</code> 方法本质是 <code>then</code> 方法的特例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.finally(()=&gt;&#123;&#125;)</span><br><span class="line">//等同于</span><br><span class="line">promise.then(</span><br><span class="line">  result=&gt;&#123;</span><br><span class="line">        //语句</span><br><span class="line">    return result</span><br><span class="line">  &#125;,</span><br><span class="line">  error=&gt;&#123;</span><br><span class="line">      //语句</span><br><span class="line">    throw  error</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>finally</code> 实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.prototype.finally=function(callback)&#123;</span><br><span class="line">  let p =this.constructor</span><br><span class="line">    return this.then(</span><br><span class="line">      value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">      reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，不管前面的 <code>Promise</code> 是 <code>fulfilled</code> 还是 <code>rejected</code>，都会执行回调函数 <code>callback</code>。<br>从上面的实现还可以看到，<code>finally</code> 方法总是会返回原来的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接是resolved状态，resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="6、Promise-all"><a href="#6、Promise-all" class="headerlink" title="6、Promise.all()"></a>6、Promise.all()</h2><p>用于将多个<code>Promise</code> 实例包装成一个<code>Promise</code> 实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  p=new Promise([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<p><code>Promise.all()</code>接收一个数组作为参数，参数都是 <code>Promise</code> 实例，如果不是 <code>Promise</code> 实例会调用 <code>Promise.resolve</code> 方法转为 <code>Promise</code> 实例<br>p 的状态由 p1,p2,p3 共同决定，分为两种情况<br>p1,p2,p3 的状态都是 fulfilled 的时候，p 的状态才会变成<code>fulfilled</code>，此时 p1,p2,p3 的返回值组成一个数组传递给 p 的回调函数<br>p1,p2,p3 之中有一个变为<code>rejected</code>状态，p 就是<code>rejected</code>状态，第一个变为 <code>rejected</code>的实例的返回值作为参数传递给 p 的回调函数<br><strong>注意</strong>，如果作为参数的的<code>Promise</code>实例里面定义了 catch，一但它进入 rejected 状态，并不会触发<code>Promise.all</code>的<code>catch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;hello&apos;)</span><br><span class="line">&#125;).then(result=&gt;&#123;console.log(&apos;p1&apos;,result)&#125;)</span><br><span class="line">.catch(err=&gt;console.log(&apos;p1&apos;,err))</span><br><span class="line">const p2=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">   throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;).then(result=&gt;&#123;console.log(&apos;p2&apos;,result)&#125;)</span><br><span class="line">.catch(err=&gt;console.log(&apos;p2&apos;,err))</span><br><span class="line">Promise.all([p1,p2])</span><br><span class="line">.then(result=&gt;&#123;console.log(&apos;all&apos;,result)&#125;)</span><br><span class="line">.catch(err=&gt;console.log(&apos;all&apos;,err))</span><br><span class="line">//p1 hello</span><br><span class="line">// p2 Error: 出错了</span><br></pre></td></tr></table></figure>
<p>p2 没有设置自身的<code>catch</code>方法时，就会调用 <code>promise.all</code> 的<code>catch</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;hello&apos;)</span><br><span class="line">&#125;).then(result=&gt;&#123;console.log(&apos;p1&apos;,result)&#125;)</span><br><span class="line">.catch(err=&gt;console.log(&apos;p1&apos;,err))</span><br><span class="line">const p2=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">   throw new Error(&apos;出错了&apos;)</span><br><span class="line">&#125;).then(result=&gt;&#123;console.log(&apos;p2&apos;,result)&#125;)</span><br><span class="line">Promise.all([p1,p2])</span><br><span class="line">.then(result=&gt;&#123;console.log(&apos;all&apos;,result)&#125;)</span><br><span class="line">.catch(err=&gt;console.log(&apos;all&apos;,err))</span><br><span class="line">//p1 hello</span><br><span class="line">// all Error: 出错了</span><br></pre></td></tr></table></figure>
<h2 id="7、Promise-race"><a href="#7、Promise-race" class="headerlink" title="7、Promise.race()"></a>7、Promise.race()</h2><p>同样是将多个<code>Promise</code>实例包裹后返回一个实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p=new  Promise([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<p>只要 p1，p2，p3 中的任何一个实例中的状态首先发生变化，p 的状态就跟着变化<br>率先发生变化的实例的返回值作为参数传入 p 的回调函数<br>同<code>Promise.all</code>一样如果传入的不是<code>Promise</code>的实例对象，就通过 <code>Promise.resolve</code> 转为<code>Promise</code>的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p=Promise.race([</span><br><span class="line">    fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class="line">    new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">        setTimeout(reject(new Error(&apos;request timeout&apos;)),5000)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line">p.then(result=&gt;console.log(result))</span><br><span class="line">.catch(err=&gt;console.log(err))</span><br><span class="line">//Error: request timeout</span><br></pre></td></tr></table></figure>
<p>5s 内 <code>fetch</code> 请求无法获取到返回结果，p 就会抛出超时错误</p>
<h2 id="8、Promise-resolve"><a href="#8、Promise-resolve" class="headerlink" title="8、Promise.resolve()"></a>8、Promise.resolve()</h2><p>将现有对象转为<code>Promise</code>对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  p=Promise.resolve($.ajax(&apos;/whatever.json&apos;))</span><br></pre></td></tr></table></figure>
<p>将 Jquery 生成的 deferred 对象转为<code>Promise</code>对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">//等同于</span><br><span class="line">new  Promise(resolve=&gt;resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve</code> 方法分为四种情况<br>1、参数是一个<code>Promise</code>实例<br>直接将实例返回，不做更改<br>2、参数是一个<code>thenable</code>对象<br><code>thenable</code> 对象时指具有<code>then</code>方法的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let  thenable=&#123;</span><br><span class="line">  then:function(resolve ,reject)&#123;</span><br><span class="line">        resolve(42)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve</code> 会将这个对象转为<code>Promise</code>实例，然后立即执行<code>thenable</code>对象中的 <code>then</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p=Promise.resolve(thenable)</span><br><span class="line">p.then(value=&gt;console.log(value))</span><br><span class="line">//42</span><br></pre></td></tr></table></figure>
<p>3、参数不是含<code>then</code>方法的对象，或者根本不是对象<br>如果参数是原始类型的值，或者是一个不具有<code>then</code>方法的对象。Promise.resolve 方法返回一个<code>Promise</code>对象状态是 resolved，Promise.resolve 方法的参数会传给后面<code>then</code>的回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p=Promise.resolve(&apos;Hello&apos;)</span><br><span class="line">p.then(s=&gt;console.log(s))</span><br><span class="line">//&apos;Hello&apos;</span><br></pre></td></tr></table></figure>
<p>4、不带任何参数<br><code>Promise.resolve</code>直接返回一个 resolved 状态的<code>Promise</code>对象<br>该对象时在本次事件循环结束的时候执行<br><code>setTimeout</code> 实在先出事件循环开始的时候执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;console.log(&apos;three&apos;),0)</span><br><span class="line">Promise.resolve().then(()=&gt;console.log(&apos;two&apos;))</span><br><span class="line">console.log(&apos;one&apos;)</span><br><span class="line">//one</span><br><span class="line">//two</span><br><span class="line">//three</span><br></pre></td></tr></table></figure>
<h2 id="9、Promise-reject"><a href="#9、Promise-reject" class="headerlink" title="9、Promise.reject()"></a>9、Promise.reject()</h2><p>返回一个状态为 rejected 的<code>Promise</code>实例对象,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p=Promise.reject(&apos;出错了&apos;)</span><br><span class="line">//相当于</span><br><span class="line">const p=new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">  reject(&apos;出错了&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(null ,err=&gt;console.log(err))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，<code>Promise.reject</code> 会将参数原封不动的传递给<code>then</code>方法的回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const thenable=&#123;</span><br><span class="line"> then:function()&#123;</span><br><span class="line">    reject(&apos;出错了&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.reject(thenable).catch(res=&gt;console.log(res===thenable))</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>
<h2 id="10、应用"><a href="#10、应用" class="headerlink" title="10、应用"></a>10、应用</h2><p>Generator 函数与<code>Promise</code>结合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFoo()&#123;</span><br><span class="line">    return new Promise((resolve ,reject)=&gt;&#123;</span><br><span class="line">         resolve(&apos;foo&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const  g=function*()&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      const foo=yield getFoo()</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function run(generator)&#123;</span><br><span class="line">   const  it=generator();</span><br><span class="line">   function go(result)&#123;</span><br><span class="line">      if(result.done) return result.value;</span><br><span class="line">      return result.value.then(</span><br><span class="line">          value=&gt;go(it.next(value),</span><br><span class="line">          error=&gt;go(it.throw(error))</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">  go(it.next())</span><br><span class="line">&#125;</span><br><span class="line">run(g)</span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>Generator</code> 函数 g 之中，有一个异步操作 <code>getFoo</code> ，它返回的就是一个<code>Promise</code>对象。函数 run 用来处理这个<code>Promise</code>对象，并调用下一个 <code>next</code> 方法。</p>
<h2 id="11、Promise-try"><a href="#11、Promise-try" class="headerlink" title="11、Promise.try()"></a>11、Promise.try()</h2><p>无论函数 f 是同步函数还是异步操作，都采用<code>Promise</code>处理它，不过是否包含异步操作，都采用<code>then</code>方法指定下一步操作，.catch 方法处理异常<br>一般写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve().then(f)</span><br></pre></td></tr></table></figure>
<p>缺点，如果 f 是同步函数，也会在本轮循环的末尾执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const f=()=&gt;console.log(&apos;now&apos;)</span><br><span class="line">Promise.resolve().then(f)</span><br><span class="line">console.log(&apos;next&apos;)</span><br><span class="line">//next</span><br><span class="line">//now</span><br></pre></td></tr></table></figure>
<p>让异步函数异步执行，同步函数同步执行<br>第一种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(async ()=&gt;f())()</span><br><span class="line">console.log(&apos;next&apos;)</span><br><span class="line">//now</span><br><span class="line">//next</span><br></pre></td></tr></table></figure>
<p>上面是一个立即执行的匿名函数，里面是一个 async 函数，如果 f 是同步的，就会得到同步的结果，如果 f 是异步的，就可以用<code>then</code>执行下一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(async ()=&gt;f())</span><br><span class="line">.then()</span><br><span class="line">.catch()</span><br></pre></td></tr></table></figure>
<p>async 会吃掉 f 里面的错误，需要使用 <code>catch</code> 捕获</p>
<p>第二种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  ()=&gt;new Promise(</span><br><span class="line">      resolve=&gt;resolve(f)</span><br><span class="line">   ）</span><br><span class="line">)()</span><br></pre></td></tr></table></figure>
<p>上面代码也是使用立即执行的匿名函数，执行 <code>new Promise()</code>。这种情况下，同步函数也是同步执行的。<br>新提案 Promise.try()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">database.users.get()</span><br><span class="line">.then()</span><br><span class="line">.catch()</span><br></pre></td></tr></table></figure>
<p>database.users.get()返回一个<code>Promise</code>对象，错误用<code>catch</code>捕获<br>还可能抛出同步错误，需要使用 <code>try...catch</code> 捕获</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  database.users.get()</span><br><span class="line">  .then()</span><br><span class="line">  .catch()</span><br><span class="line">&#125;catch&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Promise.try</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.try(  database.users.get() )</span><br><span class="line">.then()</span><br><span class="line">.catch()</span><br></pre></td></tr></table></figure>
<h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><h3 id="简单版-Promise"><a href="#简单版-Promise" class="headerlink" title="简单版 Promise"></a>简单版 Promise</h3><h4 id="Promise实例"><a href="#Promise实例" class="headerlink" title="Promise实例"></a><code>Promise</code>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建三变量记录表示状态</span><br><span class="line"> * 用that保存this，避免后期闭包导致this的指向不对</span><br><span class="line"> * value 变量用于保存 resolve 或者 reject 中传入的值</span><br><span class="line"> * resolvedCallbacks 和 rejectedCallbacks 用于保存`then`中的回调，</span><br><span class="line"> * 因为当执行完`Promise`时状态可能还是等待中，这时候应该把`then`中的回调保存起来用于状态改变时使用</span><br><span class="line"> */</span><br><span class="line">const PENDING = &apos;pending&apos;</span><br><span class="line">const RESOLVED = &apos;resolved&apos;</span><br><span class="line">const REJECTED = &apos;rejected&apos;</span><br><span class="line"></span><br><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">    const that = this;</span><br><span class="line">    that.state = PENDING;</span><br><span class="line">    that.value = null; //保存 resolve 或者 reject 中传入的值</span><br><span class="line">    //用于保存`then`中的回调，因为当执行完`Promise`时状态可能还是等待中,这时候应该把`then`中的回调保存起来用于状态改变时使用。</span><br><span class="line">    that.resolvedCallbacks = [];</span><br><span class="line">    that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        if (that.state === PENDING) &#123;</span><br><span class="line">            that.value = value; //保存，成功的值</span><br><span class="line">            that.state = RESOLVED;</span><br><span class="line">            //执行回调方法</span><br><span class="line">            that.resolvedCallbacks.map(cb =&gt; cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(value) &#123;</span><br><span class="line">        if (that.state === PENDING) &#123;</span><br><span class="line">            that.value = value; //保存，失败的值</span><br><span class="line">            that.state = REJECTED;</span><br><span class="line">            //执行回调方法</span><br><span class="line">            that.rejectedCallbacks.map(cb =&gt; cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 执行回调函数</span><br><span class="line">    try &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125;`catch`(e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="then方法的实现"><a href="#then方法的实现" class="headerlink" title="then方法的实现"></a><code>then</code>方法的实现</h4><p>所有的实例都可以调用<code>then</code>方法，所有<code>then</code>方法放到<code>promise</code>原型链上。<br>当状态是<code>PENDING</code>状态时，不执行回调，将回调方法分别放入不同的栈内，等待调用。<br>当状态为<code>FULFILLED</code>或者<code>REJECTED</code>时，则执行响应的方法即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">  const that = this</span><br><span class="line">  onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : v =&gt; v</span><br><span class="line">  onRejected =</span><br><span class="line">    typeof onRejected === &apos;function&apos;</span><br><span class="line">      ? onRejected</span><br><span class="line">      : r =&gt; &#123;</span><br><span class="line">          throw r</span><br><span class="line">        &#125;</span><br><span class="line">  if (that.state === PENDING) &#123;</span><br><span class="line">    that.resolvedCallbacks.push(onFulfilled)</span><br><span class="line">    that.rejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  if (that.state === RESOLVED) &#123;</span><br><span class="line">    onFulfilled(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (that.state === REJECTED) &#123;</span><br><span class="line">    onRejected(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先判断两个参数是否为函数类型，因为这两个参数是可选参数</li>
<li>当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 该代码目前在简单版中会报错</span><br><span class="line">// 只是作为一个透传的例子</span><br><span class="line">Promise.resolve(4).then().then((value) =&gt; console.log(value))</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="改造-Promise"><a href="#改造-Promise" class="headerlink" title="改造 Promise"></a>改造 Promise</h3><p>根据 Promises/A+规范，改造 promise，传给<code>then</code>的应该是个 promise,</p>
<h4 id="resolve-和-reject-的改造"><a href="#resolve-和-reject-的改造" class="headerlink" title="resolve 和 reject 的改造"></a>resolve 和 reject 的改造</h4><ul>
<li>对于 resolve 函数来说，首先需要判断传入的值是否为<code>Promise</code>类型</li>
<li>为了保证函数的执行顺序，需要将两个函数代码使用<code>setTimeout</code>包裹起来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function resolve(value) &#123;</span><br><span class="line">    if(value instanceof MyPromise)&#123;</span><br><span class="line">        return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        that.status = FULFILLED;</span><br><span class="line">        that.value = value;</span><br><span class="line">        //执行会回调方法</span><br><span class="line">        that.fulfilledCallbacks.forEach(myFn =&gt; myFn(that.value))</span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reject(value) &#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        that.status = REJECTED;</span><br><span class="line">        that.value = value;</span><br><span class="line">        //执行会回调方法</span><br><span class="line">        that.rejectedCallbacks.forEach(myFn =&gt; myFn(that.value))</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改造then方法"><a href="#改造then方法" class="headerlink" title="改造then方法"></a>改造<code>then</code>方法</h4><p>新增一个变量<code>promise2</code>，因为每个 <code>then</code> 函数都需要返回一个新的 <code>Promise</code> 对象，该变量用于保存新的返回对象。</p>
<ul>
<li><p>PENDING</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (that.state === PENDING) &#123;</span><br><span class="line">return (promise2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    that.resolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          const x = onFulfilled(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">      &#125;`catch`(r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    that.rejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          const x = onRejected(that.value)</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">      &#125;`catch`(r) &#123;</span><br><span class="line">          reject(r)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先我们返回了一个新的<code>Promise</code>对象，并在<code>Promise</code>中传入了一个函数</li>
<li>函数的基本逻辑还是和之前一样，往回调数组中 push 函数</li>
<li>同样，在执行函数的过程中可能会遇到错误，所以使用了 try…catch 包裹</li>
<li>规范规定，执行 onFulfilled 或者 onRejected 函数时会返回一个 x，并且执行<code>Promise</code>解决过程，这是为了不同的<code>Promise</code>都可以兼容使用，比如 JQuery 的<code>Promise</code>能兼容 ES6 的 Promise</li>
</ul>
</li>
<li><p>RESOLVED</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (that.state === RESOLVED) &#123;</span><br><span class="line">  return (promise2 = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          const x = onFulfilled(that.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">      &#125;`catch`(reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>REJECTED</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(that.state === REJECTED)&#123;</span><br><span class="line">  return (promise2 = new MyPromise((resolve, reject)=&gt;&#123;</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              let x = onRejected(that.value);</span><br><span class="line">              resolutionProduce(promise2, x, resolve, reject)</span><br><span class="line">          &#125;catch (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,0)</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>把返回值改成 Promise，同时捕获异常，</li>
</ul>
</li>
</ul>
<h4 id="resolutionProduce-函数"><a href="#resolutionProduce-函数" class="headerlink" title="resolutionProduce 函数"></a>resolutionProduce 函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function resolutionProcedure(promise2, x, resolve, reject) &#123;</span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line">    return reject(new TypeError(&apos;Error&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>规范规定保证当前的<code>x</code>不能与<code>promise2</code>一致，否则将执行无意义的相同操作，导致循环引用的发生。比如如下情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p =new MyPromise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">let p1=p.then(value=&gt;&#123;</span><br><span class="line">    return p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>然后判断<code>x</code>的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (x instanceof MyPromise) &#123;</span><br><span class="line">    x.then(function(value) &#123;</span><br><span class="line">    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">&#125;, reject)</span><br></pre></td></tr></table></figure>
<p>这里的代码是完全按照规范实现的。如果 <code>x</code> 为 <code>Promise</code> 的话，需要判断以下几个情况：</p>
<ul>
<li>如果 x 处于等待态，<code>Promise</code> 需保持为等待态直至 x 被执行或拒绝</li>
<li>如果 x 处于其他状态，则用相同的值处理 <code>Promise</code><br>以上这些是规范需要我们判断的情况，实际上我们不判断状态也是可行的。</li>
</ul>
<p>接下来我们继续按照规范来实现剩余的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let called = false</span><br><span class="line">if (x !== null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;)) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let`then`= x.then</span><br><span class="line">    if (typeof`then`=== &apos;function&apos;) &#123;</span><br><span class="line">      then.call(</span><br><span class="line">        x,</span><br><span class="line">        y =&gt; &#123;</span><br><span class="line">          if (called) return</span><br><span class="line">          called = true</span><br><span class="line">          resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">        &#125;,</span><br><span class="line">        e =&gt; &#123;</span><br><span class="line">          if (called) return</span><br><span class="line">          called = true</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;`catch`(e) &#123;</span><br><span class="line">    if (called) return</span><br><span class="line">    called = true</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  resolve(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先创建一个变量<code>called</code>用于判断是否已经调用过函数</li>
<li>判断<code>x</code>是否为对象或者函数，如果都不是的话，将<code>x</code>传入<code>resolve</code>中</li>
<li>如果 <code>x</code> 是对象或者函数的话，先把 <code>x.then</code> 赋值给<code>then</code>，然后判断 <code>then</code> 的类型，如果不是函数类型的话，就将 <code>x</code> 传入 <code>resolve</code> 中</li>
<li>如果<code>then</code> 是函数类型的话，就将 <code>x</code> 作为函数的作用域<code>this</code> 调用之，并且传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做<code>rejectPromise</code>，两个回调函数都需要判断是否已经执行过函数，然后进行相应的逻辑</li>
<li>以上代码在执行的过程中如果抛错了，将错误传入<code>reject</code> 函数中</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>m-核心考点</title>
    <url>/2020/06/20/m-%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<p>考点+面试题</p>
<a id="more"></a>
<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><h2 id="三、面向对象，构造函数、原型与原型链"><a href="#三、面向对象，构造函数、原型与原型链" class="headerlink" title="三、面向对象，构造函数、原型与原型链"></a>三、面向对象，构造函数、原型与原型链</h2><ul>
<li><p><strong>1. 对象</strong><br>定义：无序属性的集合，其属性可以包含基本值，对象或者函数。<br>创建对象的方法：</p>
<ul>
<li>new 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj =new Object()</span><br></pre></td></tr></table></figure>
<ul>
<li>字面量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据原型创建对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj=Object.create(Object.prototype)</span><br><span class="line">let obj=Object.create(null)</span><br></pre></td></tr></table></figure>
<ul>
<li>工厂模式<br>就是提供一个生成一类对象的函数，通过这个函数返回一个对象。<br>解决代码重复代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var createPerson = function (name, age) &#123;</span><br><span class="line">      var o = new Object();</span><br><span class="line">      o.name = name;</span><br><span class="line">      o.age = age;</span><br><span class="line">      o.getName = function () &#123;</span><br><span class="line">          return this.name</span><br><span class="line">      &#125;</span><br><span class="line">      return o;</span><br><span class="line">  &#125;</span><br><span class="line">  var perTom = createPerson(&apos;Tom&apos;, 20);</span><br><span class="line">  var perJake = createPerson(&apos;Jake&apos;, 22);</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>无法识别对象实例</li>
<li>相同的对象的方法会复制很多份，造成浪费</li>
</ul>
</li>
<li><p><strong>2. 构造函数</strong><br>目的：创建一个自定义类。<br>使用 new 关键字调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">    demo()  //window</span><br><span class="line">    new demo()  //demo</span><br></pre></td></tr></table></figure>
<p>new 方法实现，就是一个高阶函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person = function (name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.getName = function () &#123;</span><br><span class="line">            return this.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //以参数形式传入构造函数</span><br><span class="line">    function New(func) &#123;</span><br><span class="line">        //声明一个中间对象，为最终返回的实例</span><br><span class="line">        var res = &#123;&#125;;</span><br><span class="line">        if (func.prototype !== null) &#123;</span><br><span class="line">            //将实例的原型指向构造函数的原型</span><br><span class="line">            res.__proto__ = func.prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过apply将构造函数内部的this指向res，即实例对象</span><br><span class="line">        var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));</span><br><span class="line">        console.log(&#123;</span><br><span class="line">            ret,</span><br><span class="line">            res</span><br><span class="line">        &#125;)</span><br><span class="line">        //当我们在构造函数中明确指定了返回对象时，那new的执行结果就是该返回对象</span><br><span class="line">        if ((typeof ret === &apos;object&apos; || typeof ret === &apos;function&apos;) &amp;&amp; ret !== null) &#123;</span><br><span class="line">            return ret</span><br><span class="line">        &#125;</span><br><span class="line">        //如果没有明确指定返回对象，则默认返回res,</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">    var p1 = New(Person, &apos;tom&apos;, 20);</span><br><span class="line">    console.log(p1.getName()); //tom</span><br><span class="line">    // 判断实例的类型</span><br><span class="line">    console.log(p1 instanceof Person); // true</span><br></pre></td></tr></table></figure>
<p>new 关键字执行过程：</p>
<ol>
<li>声明一个中间对象。</li>
<li>将该中间对象的原型指向构造函数的原型</li>
<li>将构造函数的 this，指向中间对象</li>
<li>如果构造函数存在返回值，返回该返回值，否则返回中间对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>3. 原型</strong><br>原型对象的方法与属性就变成了共有方法与属性。</p>
<p><em>每个函数都可以是构造函数，每个对象都可以是原型对象。函数 prototype 指向原型，实例<code>__proto__</code>指向原型</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//通过prototype属性，将方法挂载带原型对象上</span><br><span class="line">Person.prototype.getName= function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&apos;tim&apos;, 10);</span><br><span class="line">var p2 = new Person(&apos;jak&apos;, 22);</span><br><span class="line">console.log(p1.getName === p2.getName)  //true</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/11538622-93ea98e7946f7ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型"><br><strong>当我们访问实例对象中的属性或方法时，会优先访问实例对象自身的属性和方法。</strong><br>判断对象是否拥有某个属性/放发，无论该属性、方法存在于实例对象还是原型对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;name&apos; in p1  //true</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong>in 的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isMoblie = &apos;ontouchstart&apos; in document</span><br></pre></td></tr></table></figure>
<p><strong>更简单的原型写法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">        constructor:Person, // 显示constructor的指向</span><br><span class="line">        getName:function()&#123;&#125;,</span><br><span class="line">        getAge:function()&#123;&#125;,</span><br><span class="line">        sayHello:function()&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>4. 原型链</strong><br><img src="https://upload-images.jianshu.io/upload_images/11538622-5c5c211accca495a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链"><br>add 是 Function 对象的实例。而 Function 的原型对象时 Object 的实例。这构成了一条原型链。</p>
</li>
<li><p><strong>5. 继承</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//构造函数的继承</span><br><span class="line">function cPerson(name, age, job) &#123;</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">    this.job = job</span><br><span class="line">&#125;</span><br><span class="line">//原型链继承</span><br><span class="line">cPerson.prototype = new Person();</span><br><span class="line">//添加方法</span><br><span class="line">cPerson.prototype.getLive = function () &#123;&#125;</span><br><span class="line">var p3 = new cPerson(&apos;111&apos;, 333, &apos;ddd&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>6. 更好的继承</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Student(name, age, grade) &#123;</span><br><span class="line">//构造函数继承</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function create(proto, options) &#123;</span><br><span class="line">    //创建一个空对象</span><br><span class="line">    var tmp = &#123;&#125;;</span><br><span class="line">    //让新的空对象成为父类对象的实例</span><br><span class="line">    tmp.__proto__ = proto;</span><br><span class="line">    //传入的方法都挂载到新对象上，新的对象作为子类对象的原型</span><br><span class="line">    Object.defineProperties(tmp, options);</span><br><span class="line">    return tmp</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//原型继承</span><br><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    //重新指定构造函数</span><br><span class="line">    constructor: Student,</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: function () &#123;</span><br><span class="line">            return this.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 ECMAScript5 中直接提供了一个 Object.create 方法来完成我们上面自己封装的 create 的功能。因此我们可以直接使用 Object.create.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//原型继承</span><br><span class="line">    Student.prototype = Object.create(Person.prototype, &#123;</span><br><span class="line">        //重新指定构造函数</span><br><span class="line">        constructor:  &#123;</span><br><span class="line">            value: Student,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;,</span><br><span class="line">        getGrade: &#123;</span><br><span class="line">            value: function () &#123;</span><br><span class="line">                return this.grade</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/writer#/notebooks/30666412/notes/35549465" target="_blank" rel="noopener">更多继承方式</a></p>
</li>
<li><p><strong>7. 对象属性</strong><br>数据属性包括：</p>
<ul>
<li>value</li>
<li>writable</li>
<li>configurable</li>
<li>enumerable</li>
</ul>
<p>访问器属性包括：</p>
<ul>
<li>configurable</li>
<li>enumerable</li>
<li>get</li>
<li>set</li>
</ul>
<p>一个属性只能设为访问器属性或数据属性，所以不能同时设置 value、writable 和 get、set</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">      name: &apos;ddd&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(Object.getOwnPropertyDescriptor(a, &apos;name&apos;))</span><br><span class="line">  Object.defineProperty(a, &apos;age&apos;, &#123;</span><br><span class="line">      value: 13</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(Object.getOwnPropertyDescriptor(a, &apos;age&apos;))</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/11538622-be1ec4f2cae2620e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象属性"><br><strong>注意</strong>，直接使用点（.）操作符给对象设置属性，configurable，enumerable，writable 都为 true。<br>Object.defineProperties(obj,{})，这些属性默认为 false</p>
<ul>
<li>configurable：表示该属性是否能被 delete 删除。<br>当值为 false 时，不能删除，其他特性也不能改变。</li>
<li>enumerable：是否能枚举。能否被 for-in 遍历，Object.keys()，。</li>
<li>writable：是否能修改值，</li>
<li>value：属性值，默认 undefined</li>
<li>get：对象访问属性时，get 被调用。</li>
<li><p>set：设置属性值的时候调用。<br>使用 Object.getOwnPropertyDescriptor 方法读取某一个属性的特性值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let student = &#123;</span><br><span class="line">        name: &apos;ddd&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    var initValue = 11;</span><br><span class="line">    Object.defineProperty(student, &apos;age&apos;, &#123;</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            console.log(&apos;getter&apos;);</span><br><span class="line">            return initValue</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (value) &#123;</span><br><span class="line">            console.log(&apos;setter&apos;);</span><br><span class="line">            initValue = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(student.age) //getter  11</span><br><span class="line">    student.age = 12 //setter</span><br><span class="line">    console.log(student.age) //getter 12</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="四、事件循环"><a href="#四、事件循环" class="headerlink" title="四、事件循环"></a>四、事件循环</h2><p>JS 单线程，只有一个事件循环。<br>函数调用栈-函数执行<br>任务队列(task queue)-执行除函数外的代码，先进先出（FIFO），可以有多个。</p>
<ul>
<li>宏任务（macro-task） 、task<br>任务源：script（整体代码）、setTimeout、setInterval、setImmediate、I/O、UI rendering</li>
<li>微任务（micro-task）、jobs<br>任务源：process.nextTick、Promise、Object.observe（已废弃）、MutationObserver(html5 新特性）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//setTimeout中的回调函数才是进入任务队列的任务</span><br><span class="line"> setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;xxx&apos;)</span><br><span class="line">    &#125;, 10);</span><br></pre></td></tr></table></figure>
<p>setTimeout 作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行。<br>事件循环的顺序：</p>
<ul>
<li>从 script 开始第一次循环</li>
<li>全局上下文进入函数调用栈</li>
<li>调用函数，创建函数执行上下文，执行完成，出栈</li>
<li>调用栈清空（只剩全局），就执行 micro-task</li>
<li>micro-task 执行完后，再次执行 macro-task<br>…….<br>setTime 队列<br>promise 任务队列</li>
</ul>
<p>setTime Promise Async Ajax 请求<br><strong>1. 同步 vs 异步</strong></p>
<ul>
<li>同步 顺序执行</li>
<li>异步 并行处理方式，不必等待一个程序执行完成，就可以执行其他任务</li>
</ul>
<h2 id="六、DOM-操作与-BOM-操作"><a href="#六、DOM-操作与-BOM-操作" class="headerlink" title="六、DOM 操作与 BOM 操作"></a>六、DOM 操作与 BOM 操作</h2><ul>
<li><p><strong>1. DOM 属性和操作</strong><br><a href="https://dorisfeng.github.io/2018/12/21/DOM%E6%93%8D%E4%BD%9C/">DOM 操作</a></p>
</li>
<li><p><strong>2. DOM 事件</strong><br><a href="https://dorisfeng.github.io/2020/01/05/m-DOM%E4%BA%8B%E4%BB%B6/">DOM 事件</a></p>
</li>
<li><p><strong>3. DOM 事件模型和事件流</strong><br>DOM 事件模型分为捕获和冒泡。<br>三个阶段：<br>1）. 捕获阶段<br>事件从 window 对象自上向下目标节点传播的阶段<br>window-&gt;document-&gt;html-&gt;body-&gt;…-&gt; 目标元素<br>2）. 目标阶段<br>真正目标节点正在处理事件的阶段<br>3）. 冒泡阶段<br>事件从目标节点自下而上向 window 对象传播阶段<br>跟捕获阶段相反<br><strong>阻止冒泡</strong><br>event.stopPropagation()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p2.onclick = (e) =&gt; &#123;</span><br><span class="line">        console.log(&apos;p2&apos;)</span><br><span class="line">        e.stopPropagation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://dorisfeng.github.io/2020/01/05/m-DOM%E4%BA%8B%E4%BB%B6/">Dom 事件</a></p>
</li>
<li><p><strong>4.事件代理(事件委托)</strong><br>由于事件会在冒泡阶段向上传输到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多子元素的事件。<br>优点：</p>
<ul>
<li>使代码简洁</li>
<li>减少浏览器的内存占用</li>
<li>删除子元素的时候不用考虑删除绑定事件<br>应用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&apos;list&apos;&gt;</span><br><span class="line">        &lt;li data-index=&apos;1&apos;&gt;item1&lt;/li&gt;</span><br><span class="line">        &lt;li data-index=&apos;2&apos;&gt;item2&lt;/li&gt;</span><br><span class="line">        &lt;li data-index=&apos;3&apos;&gt;item3&lt;/li&gt;</span><br><span class="line">        &lt;li data-index=&apos;4&apos;&gt;item4&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">let list = document.getElementById(&apos;list&apos;);</span><br><span class="line">    list.addEventListener(&apos;click&apos;, e =&gt; &#123;</span><br><span class="line">        var event = e || window.event; //兼容</span><br><span class="line">        var target = event.target || event.srcElement;</span><br><span class="line">        //判断是否匹配目标元素</span><br><span class="line">        if (target.nodeName.toLocaleLowerCase() === &apos;li&apos;) &#123;</span><br><span class="line">            console.log(target.dataset.index)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>5. BOM 操作</strong><br>浏览器对象模型，是浏览器本身的一些信息的设置和获取。</p>
<ul>
<li><p>window.screen 对象：屏幕的信息<br>屏幕宽高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">screen.width</span><br><span class="line">screen.height</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.location 对象：获取当前页面的地址（url），把浏览器重定向到新的页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location.href //网址https://juejin.im/timeline/frontend?a=10&amp;b=10#some</span><br><span class="line">location.protocol //协议https</span><br><span class="line">location.pathname //路径//juejin.im/timeline/frontend- window.history 对象：浏览器的前进后退等</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history.back() //后退</span><br><span class="line">history.forward() //前进</span><br></pre></td></tr></table></figure>
<ul>
<li>window.navigator 对象：获取浏览器信息，是否是移动端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ua = navigator.userAgent</span><br><span class="line">    var isChrome = ua.indexOf(&apos;Chrome&apos;) &gt; -1 ? true : false;</span><br><span class="line">    console.log(isChrome)</span><br></pre></td></tr></table></figure>
<p>[window 对象](<a href="https://dorisfeng.github.io/2018/12/21/window%E5%AF%B9">https://dorisfeng.github.io/2018/12/21/window%E5%AF%B9</a>%<br>location.search //参数?a=10&amp;b=10<br>location.hash //#some</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">E8%B1%A1/)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="八、对象拷贝"><a href="#八、对象拷贝" class="headerlink" title="八、对象拷贝"></a>八、对象拷贝</h2><p><a href="https://dorisfeng.github.io/2019/10/11/%E5%AF%B9%E8%B1%A1-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">对象操作方法</a></p>
<h2 id="九、手写call、apply、bind函数"><a href="#九、手写call、apply、bind函数" class="headerlink" title="九、手写call、apply、bind函数"></a>九、手写<code>call</code>、<code>apply</code>、<code>bind</code>函数</h2><p><a href="https://dorisfeng.github.io/2020/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#more">手写</a></p>
<h2 id="十、"><a href="#十、" class="headerlink" title="十、"></a>十、</h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>前端常用的几种设计模式</p>
<a id="more"></a>
<h1 id="发布-订阅模式（观察者模式）"><a href="#发布-订阅模式（观察者模式）" class="headerlink" title="发布-订阅模式（观察者模式）"></a>发布-订阅模式（观察者模式）</h1><p>定义一对一或一对多的依赖关系，当发布者发生变化时，订阅方都会收到通知。<br>异步编程中可以利用这种模式传递回调函数。比如请求成功或错误等事件。无需关系异步操作运行的内部状态，只需要订阅异步执行完成这个节点。<br>例子：DOM 节点绑定事件函数，这时 DOM 节点就是发布者，事件函数就是订阅者，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const btn=document.getElementById(&apos;btn&apos;);</span><br><span class="line">btn.addEventListener(&apos;click&apos;,function(event)&#123;</span><br><span class="line">    console.log(&apos;按钮被点击&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>确保一个类只有唯一一个实例，并且提供一个访问它的全局访问点。<br>举例：Window，全局缓存，全局状态管理<br>单例模式只实例化一次，多次调用实例化函数返回的都是第一次创建的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//单例模式</span><br><span class="line">let Singleton = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getName = function () &#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">//获取实例对象</span><br><span class="line">Singleton.getInstance = function (name) &#123;</span><br><span class="line">    if (!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    return this.instance</span><br><span class="line">&#125;</span><br><span class="line">let a = Singleton.getInstance(&apos;aa&apos;);</span><br><span class="line">let b = Singleton.getInstance(&apos;bb&apos;);</span><br><span class="line">console.log(a === b)</span><br></pre></td></tr></table></figure>
<p>实际例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> (function () &#123;</span><br><span class="line">    //管理单例的逻辑代码，如果没有数据则创建，有数据则返回</span><br><span class="line">    var getSingle = function (fn) &#123; //参数为创建对象的方法</span><br><span class="line">        var result;</span><br><span class="line">        return function () &#123; //判断是Null或赋值</span><br><span class="line">            console.log(result)</span><br><span class="line">            return result || (result = fn.apply(this, arguments));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    //创建登录窗口方法</span><br><span class="line">    var createLoginLayer = function () &#123;</span><br><span class="line">        var div = document.createElement(&apos;div&apos;);</span><br><span class="line">        div.innerHTML = &apos;我是登录浮窗&apos;;</span><br><span class="line">        div.style.display = &apos;none&apos;;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">        return div;</span><br><span class="line">    &#125;;</span><br><span class="line">    //单例方法</span><br><span class="line">    var createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"></span><br><span class="line">    //使用惰性单例，进行创建</span><br><span class="line">    document.getElementById(&apos;loginBtn&apos;).onclick = function () &#123;</span><br><span class="line">        var loginLayer = createSingleLoginLayer();</span><br><span class="line">        loginLayer.style.display = &apos;block&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>为了不暴露创建对象的具体逻辑，将逻辑封装在一个函数中，本质上市一个负责生产对象实例的工厂。<br>根据抽象程度分类：简单工厂，工厂方法，抽象工厂<br>例子：生产角色</p>
<ul>
<li>简单工厂模式 (适合创建的类比较少的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let UserFactory = function (role) &#123;</span><br><span class="line">    function SuperAdmin() &#123;</span><br><span class="line">        this.name = &apos;超级管理员&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;, &apos;权限管理&apos;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Admin() &#123;</span><br><span class="line">        this.name = &apos;管理员&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function NormalUser() &#123;</span><br><span class="line">        this.name = &apos;普通用户&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">    switch (role) &#123;</span><br><span class="line">        case &quot;superAdmin&quot;:</span><br><span class="line">            return new SuperAdmin();</span><br><span class="line">            break;</span><br><span class="line">        case &apos;admin&apos;:</span><br><span class="line">            return new Admin();</span><br><span class="line">            break;</span><br><span class="line">        case &apos;user&apos;:</span><br><span class="line">            return new User();</span><br><span class="line">        default:</span><br><span class="line">            throw new Error(&apos;参数错误，可选参数：superAdmin、admin、user&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let admin = UserFactory(&apos;admin&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>工厂方法 (创建多类对象)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let UserFactory = function (role) &#123;</span><br><span class="line">    if (this instanceof UserFactory) &#123;</span><br><span class="line">        var s = new this[role]();</span><br><span class="line">        return s;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new UserFactory(role)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">UserFactory.prototype = &#123;</span><br><span class="line">    SuperAdmin: function () &#123;</span><br><span class="line">        this.name = &apos;超级管理员&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;, &apos;权限管理&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    Admin: function () &#123;</span><br><span class="line">        this.name = &apos;管理员&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    NormalUser: function () &#123;</span><br><span class="line">        this.name = &apos;普通用户&apos;;</span><br><span class="line">        this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let superAdmin = UserFactory(&apos;SuperAdmin&apos;);</span><br><span class="line">let admin = UserFactory(&apos;Admin&apos;)</span><br><span class="line">let normalUser = UserFactory(&apos;NormalUser&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象工厂（创建父类，子类继承父类，具体实现在子类）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let VehicleFactory = function (subType, superType) &#123;</span><br><span class="line">    //判断抽象工厂中是否有该抽象类</span><br><span class="line">    if (typeof VehicleFactory[superType] === &apos;function&apos;) &#123;</span><br><span class="line">        //缓存类</span><br><span class="line">        function F() &#123;&#125;;</span><br><span class="line">        //继承父类属性和方法</span><br><span class="line">        F.prototype = new VehicleFactory[superType]();</span><br><span class="line">        subType.prototype = new F();</span><br><span class="line">        //将子类constructor指向子类</span><br><span class="line">        subType.constructor = subType</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //不存在抽象类</span><br><span class="line">        throw new Error(&apos;未创建该抽象类&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象一个汽车</span><br><span class="line">VehicleFactory.Car = function () &#123;</span><br><span class="line">    this.type = &apos;Car&apos;;</span><br><span class="line">&#125;</span><br><span class="line">VehicleFactory.Car.prototype = &#123;</span><br><span class="line">    getPrice: function () &#123;</span><br><span class="line">        return new Error(&apos;抽象方法不能调用&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    getSpeed: function () &#123;</span><br><span class="line">        return new Error(&apos;抽象方法不能调用&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let BMW = function (price, speed) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">    this.speed = speed</span><br><span class="line">&#125;</span><br><span class="line">VehicleFactory(BMW, &apos;Car&apos;)</span><br><span class="line">BMW.prototype.getPrice = function () &#123;</span><br><span class="line">    return this.price</span><br><span class="line">&#125;;</span><br><span class="line">BMW.prototype.getSpeed = function () &#123;</span><br><span class="line">    return this.speed</span><br><span class="line">&#125;;</span><br><span class="line">let one = new BMW(&apos;1000&apos;, &apos;100&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>解决两个接口不兼容的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Plug &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return &apos;港版插头&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.plug = new Plug()</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.plug.getName() + &apos; 适配器转二脚插头&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let target = new Target()</span><br><span class="line">target.getName() // 港版插头 适配器转二脚插头</span><br></pre></td></tr></table></figure>
<p>例如在项目中拿到的时间是时间戳，我们要展示成日期，就需要一个转换函数。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理是为了控制对象的访问，不让外部对象直接访问到对象。</p>
<ul>
<li><p>图片懒加载</p>
</li>
<li><p>缓存代理 （缓存请求结果、计算结果）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> const multi = function () &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    console.log(&apos;a&apos;, a)</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        a *= arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br><span class="line">//创建缓存代理</span><br><span class="line">const createProxyFactory = function (fn) &#123;</span><br><span class="line">    let cache = &#123;&#125;; //保存计算结果</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let args = Array.from(arguments).join(&apos;,&apos;); //将参数变成字符串，作为缓存对象的key</span><br><span class="line">        if (args in cache) &#123;</span><br><span class="line">            return cache[args]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return cache[args] = fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用代理对象创建函数</span><br><span class="line">const proxyMulti = createProxyFactory(multi);</span><br><span class="line">console.log(proxyMulti(1, 2, 3, 4))</span><br></pre></td></tr></table></figure>
<ul>
<li>虚拟代理<br>某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建<br>例：使用虚拟代理实现图片懒加载<ol>
<li>创建了一个 Image 对象，并为其绑定了 onload 事件。</li>
<li>将 imgNode 先设置为 ‘./loading.gif’ 加载的菊花图。</li>
<li>当 Image 对象加载完真实的图片，也就是上文的 ‘./reality.png’ ,将 imgNode 设置为 ‘./reality.png’。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const imgFunc = (</span><br><span class="line">    function () &#123;</span><br><span class="line">        const imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">        document.body.appendChild(imgNode);</span><br><span class="line">        return &#123;</span><br><span class="line">            setSrc(src) &#123;</span><br><span class="line">                imgNode.src = src</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)()</span><br><span class="line">//代理对象</span><br><span class="line">const proxyImage = (</span><br><span class="line">    function () &#123;</span><br><span class="line">        const img = new Image();</span><br><span class="line">        img.onload = function () &#123;</span><br><span class="line">            imgFunc.setSrc(this.src)</span><br><span class="line">        &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">            setSrc(src) &#123;</span><br><span class="line">                imgFunc.setSrc(&apos;./loading.gif&apos;);</span><br><span class="line">                img.src = src</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)()</span><br><span class="line">proxyImage.setSrc(&apos;./realImg.jpg&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>提供一个接口，隐藏内部的逻辑，更加方便外部调用<br>用于封装 JS 类库，通过封装一些接口用于兼容多浏览器</p>
<ul>
<li>实现一个兼容多种浏览器的添加事件方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addEvent(elm, evType, fn, useCapture) &#123;</span><br><span class="line">  if (elm.addEventListener) &#123;</span><br><span class="line">    elm.addEventListener(evType, fn, useCapture)</span><br><span class="line">    return true</span><br><span class="line">  &#125; else if (elm.attachEvent) &#123;</span><br><span class="line">    var r = elm.attachEvent(&quot;on&quot; + evType, fn)</span><br><span class="line">    return r</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    elm[&quot;on&quot; + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>兼容浏览器阻止冒泡、默认事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let N = window.N || &#123;&#125;;</span><br><span class="line">  N.tools = &#123;</span><br><span class="line">      stopPropagation(e) &#123;</span><br><span class="line">          if (e.stopPropagation) &#123;</span><br><span class="line">              e.stopPropagation();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              e.cancelBubble = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      preventDefault(e) &#123;</span><br><span class="line">          if (e.preventDefault) &#123;</span><br><span class="line">              e.preventDefault();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              e.returnValue = false;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      stopEvent(e) &#123;</span><br><span class="line">          this.stopPropagation(e);</span><br><span class="line">          this.preventDefault(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>不需要改变已有的接口，作用是给对象添加功能。<br>类装饰器，属性装饰器<br>ES7 的装饰器语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function readonly(target, key, descriptor) &#123;</span><br><span class="line">  descriptor.writable = false</span><br><span class="line">  return descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name = &apos;yck&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let t = new Test()</span><br><span class="line"></span><br><span class="line">t.yck = &apos;111&apos; // 不可修改</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>m-JS</title>
    <url>/2020/06/18/m-JS/</url>
    <content><![CDATA[<p>JavaScript 考点+面试题</p>
<a id="more"></a>
<h2 id="堆栈内存以及闭包作用域"><a href="#堆栈内存以及闭包作用域" class="headerlink" title="堆栈内存以及闭包作用域"></a>堆栈内存以及闭包作用域</h2><h3 id="堆栈内存"><a href="#堆栈内存" class="headerlink" title="堆栈内存"></a>堆栈内存</h3><p><a href="https://dorisfeng.github.io/2020/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p><a href="https://dorisfeng.github.io/2020/07/14/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域和作用域链</a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><a href="https://dorisfeng.github.io/2020/07/14/JS-%E9%97%AD%E5%8C%85/">闭包</a></p>
<h3 id="数据类型以及区别"><a href="#数据类型以及区别" class="headerlink" title="数据类型以及区别"></a>数据类型以及区别</h3><p><a href="https://dorisfeng.github.io/2019/02/26/JS-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/">JS-语言类型</a></p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><a href="https://dorisfeng.github.io/2020/07/14/JS-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/">变量提升</a></p>
<h2 id="JS-编译机制：AO-VO-GO-EC-ECStack"><a href="#JS-编译机制：AO-VO-GO-EC-ECStack" class="headerlink" title="JS 编译机制：AO/VO/GO/EC/ECStack"></a>JS 编译机制：AO/VO/GO/EC/ECStack</h2><p>AO：Active Object 活动对象<br>VO：Variable Object 变量对象<br>GO：Global Object 全局对象<br>EC：Execution Contexts 执行上下文<br>ECStack：执行栈</p>
<h2 id="JS-高级编程技巧"><a href="#JS-高级编程技巧" class="headerlink" title="JS 高级编程技巧"></a>JS 高级编程技巧</h2><p>惰性函数、科里化函数、高阶函数</p>
<h2 id="ECMAScript-3-5-6-7-8-9"><a href="#ECMAScript-3-5-6-7-8-9" class="headerlink" title="ECMAScript 3/5/6/7/8/9"></a>ECMAScript 3/5/6/7/8/9</h2><p><a href="https://dorisfeng.github.io/2019/04/05/ES6/">ES6</a><br><a href="https://dorisfeng.github.io/2020/08/18/ES7/">ES7</a><br><a href="https://dorisfeng.github.io/2020/08/18/ES8/">ES8</a><br><a href="https://dorisfeng.github.io/2019/01/14/ES9/">ES9</a><br><a href="https://dorisfeng.github.io/2020/08/19/ES10/">ES10</a></p>
<h3 id="浏览器底层渲染机制和-DOM-的回流重绘"><a href="#浏览器底层渲染机制和-DOM-的回流重绘" class="headerlink" title="浏览器底层渲染机制和 DOM 的回流重绘"></a>浏览器底层渲染机制和 DOM 的回流重绘</h3><p><a href="https://dorisfeng.github.io/2020/07/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">浏览器渲染原理</a></p>
<h3 id="DIALOG-模态框组件的封装"><a href="#DIALOG-模态框组件的封装" class="headerlink" title="DIALOG 模态框组件的封装"></a>DIALOG 模态框组件的封装</h3><h3 id="拖拽及拖拽插件的封装"><a href="#拖拽及拖拽插件的封装" class="headerlink" title="拖拽及拖拽插件的封装"></a>拖拽及拖拽插件的封装</h3><h3 id="移动端-Touch、Gesture-事件机封装处理"><a href="#移动端-Touch、Gesture-事件机封装处理" class="headerlink" title="移动端 Touch、Gesture 事件机封装处理"></a>移动端 Touch、Gesture 事件机封装处理</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><a href="https://dorisfeng.github.io/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p>
<h2 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h2><p><a href="https://dorisfeng.github.io/2020/06/26/JS-this%E6%8C%87%E5%90%91/">this</a></p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><a href="https://dorisfeng.github.io/2020/06/30/JS-EventLoop/">EventLoop</a></p>
<h2 id="前后端数据交换"><a href="#前后端数据交换" class="headerlink" title="前后端数据交换"></a>前后端数据交换</h2><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p><a href="https://dorisfeng.github.io/2020/07/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">跨域</a></p>
<h3 id="前端常用网络请求（AJAX-Fetch）"><a href="#前端常用网络请求（AJAX-Fetch）" class="headerlink" title="前端常用网络请求（AJAX,Fetch）"></a>前端常用网络请求（AJAX,Fetch）</h3><p><a href="https://dorisfeng.github.io/2019/10/30/%E5%89%8D%E7%AB%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/">前端请求</a></p>
<h3 id="GET-和-POST-核心机制与区别"><a href="#GET-和-POST-核心机制与区别" class="headerlink" title="GET 和 POST 核心机制与区别"></a>GET 和 POST 核心机制与区别</h3><p><a href="https://dorisfeng.github.io/2020/08/20/GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/">GET 和 POST</a></p>
<h3 id="axios-库和源码剖析"><a href="#axios-库和源码剖析" class="headerlink" title="axios 库和源码剖析"></a>axios 库和源码剖析</h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><p><a href="https://dorisfeng.github.io/2020/01/06/m-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/">性能优化</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="加密策略：encodeURIComponent和MD5"><a href="#加密策略：encodeURIComponent和MD5" class="headerlink" title="加密策略：encodeURIComponent和MD5"></a>加密策略：<code>encodeURIComponent</code>和<code>MD5</code></h3><h3 id="存储方法：cookie、webStorage-localStorage和sessionStorage、session"><a href="#存储方法：cookie、webStorage-localStorage和sessionStorage、session" class="headerlink" title="存储方法：cookie、webStorage:localStorage和sessionStorage、session"></a>存储方法：<code>cookie</code>、<code>webStorage:localStorage和sessionStorage</code>、<code>session</code></h3><p><a href="JS-浏览器缓存">缓存</a></p>
<h3 id="用户权限和登录态的校验处理、Token的校验处理"><a href="#用户权限和登录态的校验处理、Token的校验处理" class="headerlink" title="用户权限和登录态的校验处理、Token的校验处理"></a>用户权限和登录态的校验处理、<code>Token</code>的校验处理</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-HTML</title>
    <url>/2020/06/17/m-HTML/</url>
    <content><![CDATA[<p>HTML5</p>
<a id="more"></a>
<h2 id="谈谈你对-HTML5-的理解"><a href="#谈谈你对-HTML5-的理解" class="headerlink" title="谈谈你对 HTML5 的理解"></a>谈谈你对 HTML5 的理解</h2><p><a href="https://dorisfeng.github.io/2020/07/23/html5-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/">语义化标签</a><br><a href="https://dorisfeng.github.io/2020/07/23/html5-音视频处理/">音视频处理</a><br><a href="https://dorisfeng.github.io/2020/07/23/html5-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/">表单元素和表单校验</a><br><a href="https://dorisfeng.github.io/2020/07/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/">响应式布局</a></p>
<h3 id="CSS-预编译语言"><a href="#CSS-预编译语言" class="headerlink" title="CSS 预编译语言"></a>CSS 预编译语言</h3><p><a href="https://dorisfeng.github.io/categories/CSS/">LESS</a><br>SASS</p>
<h3 id="canvas-webGL"><a href="#canvas-webGL" class="headerlink" title="canvas/webGL"></a>canvas/webGL</h3><p><a href="https://dorisfeng.github.io/2020/07/23/html5-canvas%E5%9F%BA%E7%A1%80/">canvas 基础</a><br><a href="https://dorisfeng.github.io/2020/07/29/html5-canvas%E5%8A%A8%E7%94%BB/">canvas 动画</a><br>webGL：3D 动画，暂时没兴趣，用不着</p>
<h3 id="history-API"><a href="#history-API" class="headerlink" title="history API"></a>history API</h3><ul>
<li><code>history.back()</code><br>返回上一页，等价于<code>history.go(-1)</code>,等同于点击浏览的返回按钮。<br>当浏览器历史栈处于最底端时( 当前页面处于第一页时 )调用此方法没有效果也不报错。</li>
<li><code>history.forward()</code><br>下一页，等价于<code>history.go(1)</code>,等同于点击浏览的前进按钮。<br>当浏览器历史栈处于最顶端时( 当前页面处于最后一页时 )调用此方法没有效果也不报错。</li>
<li><code>history.go(0)</code><br>刷新页面。如果传入其他整数，就是跳转到相对于当前处于的浏览器历史栈的位置。</li>
<li><p><code>history.pushState(stateObj, title, url)</code></p>
<ul>
<li><code>stateObj</code>：状态对象，用来存储自定义数据的元素，与 url 配合使用</li>
<li><code>title</code>：标题，字符串，用于页面的标题，目前浏览器不支持，设置为空字符串</li>
<li><code>url</code>：一般是简单的<code>?page=2</code>等相对路径，自动以当前 url 为基准。如果该参数的 URL 与当前页面的 URL 不同源会报错。<br><code>history.pushState</code>会生成一条历史记录，可以让浏览器无跳转的各种状态保存到浏览器历史记录中，通过历史记录加载站点的时候，可以直接加载到对应状态。</li>
</ul>
</li>
<li><p><code>history.replaceState()</code><br>与<code>history.pushState</code>方法基本相同，区别是，<code>history.replaceState</code>不会生成新的历史记录，而是替换。</p>
</li>
<li><code>window.onpopstate</code><br>触发条件比较苛刻，只有点击浏览器的’前进’、‘后退’等导航按钮，或者由 JS 调用的<code>history.back()</code>等导航方法，切切换前后的两条历史记录都属于同一个网页文档，才会触发本事件。<br>”同一网页文档“,JS 环境的 document 是同一个，而不是指基础 URL 相同。</li>
</ul>
<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h3><p>要求浏览器在下次重绘之前调用指定的回调函数更新动画，参数是回调函数，该回调函数会在浏览器下一次重绘之前执行。<br>返回值：请求 ID，整数。可以使用<code>window.cancelAnimationFrame(id)</code>取消回调函数。<br><a href="https://dorisfeng.github.io/2020/06/22/JS-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程- requestAnimationFrame</a></p>
<h3 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLocation()</span><br><span class="line">&#123;</span><br><span class="line">    if (navigator.geolocation)</span><br><span class="line">    &#123;</span><br><span class="line">        navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        x.innerHTML=&quot;该浏览器不支持获取地理位置。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h3><p><a href="https://dorisfeng.github.io/2020/07/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">跨域-webSocket</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>vue-项目问题记录</title>
    <url>/2020/01/19/vue-%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Vue 项目问题<br>参考:<a href="https://www.ahwgs.cn/style-resources-loader-less.html" target="_blank" rel="noopener">https://www.ahwgs.cn/style-resources-loader-less.html</a></p>
<a id="more"></a>
<p><strong>1. less-mixin 全局引入</strong><br>实现手机端 1px 边框</p>
<ul>
<li>mixin.less<br>使用伪类实现下边框 1px</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.border-1px-mixin(@color) &#123;</span><br><span class="line">    position: relative;</span><br><span class="line"></span><br><span class="line">    &amp;:after &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        border-top: 1px solid @color;</span><br><span class="line">        content: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>global.less<br>使用媒体根据查询改变缩小因屏幕分辨率放大的高度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media(min-device-pixel-ratio:1.5) &#123;</span><br><span class="line">    .border-1px:after &#123;</span><br><span class="line">        border-bottom: 1px solid #000;</span><br><span class="line">        transform: scaleY(0.7)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media(min-device-pixel-ratio:2) &#123;</span><br><span class="line"></span><br><span class="line">    .border-1px:after &#123;</span><br><span class="line">        border-bottom: 1px solid #000;</span><br><span class="line">        transform: scaleY(0.5)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.js<br>全局引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;./common/less/index.less&quot;;</span><br></pre></td></tr></table></figure>
<p>其中 index.less</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &apos;./icon.less&apos;;</span><br><span class="line">@import &apos;./mixin.less&apos;;</span><br><span class="line">@import &apos;./global.less&apos;;</span><br></pre></td></tr></table></figure>
<p>其他的 css 样式都可以应用到全局，但是 mixin 无法使用</p>
<p><strong>解决方法</strong><br>安装 loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add style-resources-loader</span><br></pre></td></tr></table></figure>
<p>vue.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//全局注入mixin.less;</span><br><span class="line">function addStyleResource(rule) &#123;</span><br><span class="line">  rule</span><br><span class="line">    .use(&quot;style-resource&quot;)</span><br><span class="line">    .loader(&quot;style-resources-loader&quot;)</span><br><span class="line">    .options(&#123;</span><br><span class="line">      patterns: [path.resolve(__dirname, &quot;./src/common/less/mixin.less&quot;)]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack(config) &#123;</span><br><span class="line">    const types = [&quot;vue-modules&quot;, &quot;vue&quot;, &quot;normal-modules&quot;, &quot;normal&quot;];</span><br><span class="line">    types.forEach(type =&gt;</span><br><span class="line">      addStyleResource(config.module.rule(&quot;less&quot;).oneOf(type))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>m-页面布局</title>
    <url>/2020/01/07/m-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>三栏布局实现方法，比较</p>
<a id="more"></a>
<h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><h3 id="左右定宽，中间栏自适应"><a href="#左右定宽，中间栏自适应" class="headerlink" title="左右定宽，中间栏自适应"></a>左右定宽，中间栏自适应</h3><h4 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1.float+margin"></a>1.float+margin</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    .float_container &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        min-height: 100px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float_container .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        background-color: mediumpurple;</span><br><span class="line">        height: 100%</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float_container .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">        background-color: goldenrod;</span><br><span class="line">        height: 100%</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float_container .left,</span><br><span class="line">    .float_container .right &#123;</span><br><span class="line">        width: 300px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float_container .center &#123;</span><br><span class="line">        margin: 0 300px 0 300px;</span><br><span class="line">        background-color: mediumseagreen;</span><br><span class="line">        height: 100%</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line">&lt;div class=&apos;float_container&apos;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">        float方法实现三栏布局</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/07/m-页面布局/img1.png" alt="float"></p>
<p>优点：兼容性好<br>缺点：</p>
<ul>
<li>高度只能固定，否则三栏高度不会根据内容同时变化</li>
<li>脱离文档流，后面的元素需要清除浮动</li>
</ul>
<p><em>补充：脱离文档流</em></p>
<ul>
<li><code>float</code>属性不为<code>none</code>脱离文档流，不会撑开父元素的高度，它还在父元素中，但是其他元素会为其让开位置，环绕在周围。</li>
<li><code>position:absolute</code>，绝对定位，<ul>
<li>1.相对于父级或更上级<code>position</code>不是<code>static</code>的元素定位，</li>
<li>2.如果没有满足上一条件的元素，就相对于根元素定位。<br>其周围的元素将会忽略它的存在</li>
</ul>
</li>
<li><code>position:fixed</code>，固定定位，相对于根元素定位，完全脱离文档流。</li>
<li><code>position:relative</code>,相对定位，不完全脱离文档流<br>周围元素不会忽略它的存在，使用 top\left\right\bottom，设置偏移位置时，周围元素会忽略它的位置移动，还是认为它在原来的位置。</li>
</ul>
<p>周围元素不会忽略它的存在</p>
<h4 id="2-position"><a href="#2-position" class="headerlink" title="2.position"></a>2.position</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .position_container &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            min-height: 100px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        .position_container&gt;div &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 100%</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_container .left,</span><br><span class="line">        .position_container .right &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_container .left &#123;</span><br><span class="line">            background-color: mediumpurple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_container .right &#123;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">            right: 0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_container .center &#123;</span><br><span class="line">            background-color: mediumseagreen;</span><br><span class="line">            right: 300px;</span><br><span class="line">            left: 300px</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;h1&gt;position&lt;/h1&gt;</span><br><span class="line">    &lt;div class=&quot;position_container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">            position方法实现三栏布局</span><br><span class="line">            &lt;p&gt;position方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;position方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;position方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;position方法实现三栏布局&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/07/m-页面布局/img2.png" alt="position"><br>缺点：</p>
<ul>
<li>高度只能固定，否则三栏高度不会根据内容同时变化</li>
<li>脱离了文档流，可用性差</li>
</ul>
<h4 id="3-flexbox"><a href="#3-flexbox" class="headerlink" title="3.flexbox"></a>3.flexbox</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .flex_container &#123;</span><br><span class="line">            /* width: 100%; */</span><br><span class="line">            min-height: 100px;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: space-between;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex_container .left,</span><br><span class="line">        .flex_container .right &#123;</span><br><span class="line">            width: 300px</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex_container .left &#123;</span><br><span class="line">            background-color: mediumpurple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex_container .right &#123;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .flex_container .center &#123;</span><br><span class="line">            background-color: mediumseagreen;</span><br><span class="line">            flex: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;h1&gt;flexbox&lt;/h1&gt;</span><br><span class="line">    &lt;div class=&apos;flex_container&apos;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">            flexbox方法实现三栏布局</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;flexbox方法实现三栏布局&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>兼容性有问题</li>
</ul>
<p>优点：</p>
<ul>
<li>三栏高度由内容最高的一栏决定，可以自动一致高</li>
</ul>
<p><img src="/2020/01/07/m-页面布局/img3.png" alt="flexbox"></p>
<h4 id="4-table-table-cell"><a href="#4-table-table-cell" class="headerlink" title="4.table+table-cell"></a>4.table+table-cell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table_container &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            width: 100%</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_container&gt;div &#123;</span><br><span class="line">            display: table-cell</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_container .left,</span><br><span class="line">        .table_container .right &#123;</span><br><span class="line">            width: 300px</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_container .left &#123;</span><br><span class="line">            background-color: mediumpurple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_container .right &#123;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_container .center &#123;</span><br><span class="line">            background-color: mediumseagreen;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;h1&gt;table&lt;/h1&gt;</span><br><span class="line">    &lt;div class=&quot;table_container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">            table方法实现三栏布局</span><br><span class="line">            &lt;p&gt;table方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;table方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;table方法实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;table方法实现三栏布局&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/07/m-页面布局/img4.png" alt="table"><br>优点：</p>
<ul>
<li>三栏高度由内容最高的一栏决定，可以自动一致高</li>
<li>兼容性好</li>
</ul>
<h4 id="5-Grid（网格布局）"><a href="#5-Grid（网格布局）" class="headerlink" title="5.Grid（网格布局）"></a>5.Grid（网格布局）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .grid_container &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            width: 100%;</span><br><span class="line">            /*高度*/</span><br><span class="line">            /* grid-template-rows: 100px;</span><br><span class="line">                /*宽度*/</span><br><span class="line">            grid-template-columns: 300px auto 300px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_container .left &#123;</span><br><span class="line">            background-color: mediumpurple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_container .right &#123;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_container .center &#123;</span><br><span class="line">            background-color: mediumseagreen;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;h1&gt;网格布局&lt;/h1&gt;</span><br><span class="line">    &lt;div class=&quot;grid_container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">            网格布局实现三栏布局</span><br><span class="line">            &lt;p&gt;网格布局实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;网格布局实现三栏布局&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;网格布局实现三栏布局&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/07/m-页面布局/img5.png" alt="table"><br>优点：</p>
<ul>
<li>三栏高度由内容最高的一栏决定，可以自动一致高</li>
<li>代码简单</li>
</ul>
<p>缺点：新属性兼容性不好<br>学习方法：<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS-网格属性</a></p>
<h3 id="上下栏定高，中间栏自适应"><a href="#上下栏定高，中间栏自适应" class="headerlink" title="上下栏定高，中间栏自适应"></a>上下栏定高，中间栏自适应</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .position_layout &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_layout .header &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: darkorange</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_layout .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 100px;</span><br><span class="line">            bottom: 100px;</span><br><span class="line">            background-color: gold</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .position_layout .footer &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            position: absolute;</span><br><span class="line">            bottom: 0px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: plum</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&apos;position_layout&apos;&gt;</span><br><span class="line">        &lt;div class=&quot;header&quot;&gt;position&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>中间高度自适应，但是内容超出时，需要设置 overflows 属性，否则会影响 body</p>
<h4 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">          .flex_layout &#123;</span><br><span class="line">              display: flex;</span><br><span class="line">              flex-direction: column;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .flex_layout .header &#123;</span><br><span class="line">              height: 100px;</span><br><span class="line">              background-color: darkorange</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .flex_layout .middle &#123;</span><br><span class="line">              flex: 1;</span><br><span class="line">              background-color: gold</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          .flex_layout .footer &#123;</span><br><span class="line">              height: 100px;</span><br><span class="line">              background-color: plum</span><br><span class="line">          &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;div class=&apos;flex_layout&apos;&gt;</span><br><span class="line">          &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>中间内容超出时，自动隐藏</p>
<h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .grid_layout &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            grid-auto-flow: row;</span><br><span class="line">            grid-template-rows: 100px auto 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_layout .header &#123;</span><br><span class="line">            background-color: darkorange</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_layout .middle &#123;</span><br><span class="line">            background-color: gold</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .grid_layout .footer &#123;</span><br><span class="line">            background-color: plum</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&apos;grid_layout&apos;&gt;</span><br><span class="line">        &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>中间高度按照内容自动撑开，兼容性不好</p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table_layout &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_layout&gt;div &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            display: table-row;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_layout .header &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: darkorange</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_layout .middle &#123;</span><br><span class="line">            background-color: gold;</span><br><span class="line">            display: table-row;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .table_layout .footer &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: plum</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&apos;table_layout&apos;&gt;</span><br><span class="line">        &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;上下栏定高，中间栏自适应&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>三栏中，没有内容的话，背景就不会显示出来</li>
<li>中间高度按照内容自动撑开</li>
</ul>
<h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><h3 id="左定宽，右自适应"><a href="#左定宽，右自适应" class="headerlink" title="左定宽，右自适应"></a>左定宽，右自适应</h3><h3 id="右定宽，左自适应"><a href="#右定宽，左自适应" class="headerlink" title="右定宽，左自适应"></a>右定宽，左自适应</h3><h3 id="上定高，下自适应"><a href="#上定高，下自适应" class="headerlink" title="上定高，下自适应"></a>上定高，下自适应</h3><h3 id="下定高，上自适应"><a href="#下定高，上自适应" class="headerlink" title="下定高，上自适应"></a>下定高，上自适应</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-页面性能</title>
    <url>/2020/01/06/m-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>提升页面性能的方法<br>参考<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-22" target="_blank" rel="noopener">https://juejin.im/post/5b73ef38f265da281e048e51#heading-22</a></p>
<a id="more"></a>
<h2 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h2><h2 id="一-页面内容"><a href="#一-页面内容" class="headerlink" title="一.页面内容"></a>一.页面内容</h2><h4 id="1-减少-http-请求"><a href="#1-减少-http-请求" class="headerlink" title="1. 减少 http 请求"></a>1. 减少 http 请求</h4><ul>
<li>合并 js 脚本和 css 样式表</li>
<li>iconfont 代替小图标</li>
<li>使用 base64 格式的小图片</li>
</ul>
<h4 id="2-减少-DNS-查询"><a href="#2-减少-DNS-查询" class="headerlink" title="2.减少 DNS 查询"></a>2.减少 DNS 查询</h4><p>域名查询：将主机名映射到 IP 地址<br>DNS 查询完成之前，浏览器无法从主机名下载任何东西。</p>
<ul>
<li><p>DNS 缓存机制</p>
</li>
<li><p>减少资源存储在不同主机名下的数量，但这样同时减少页面能够并行下载的数量，为了避免 DNS 查找削减响应时间，却增加了因减少并行下载数量增加的响应时间，原则上把组件分散到 2-4 个主机名下，，同时减少 DNS 查询和允许高并发下载的这中方案。</p>
</li>
</ul>
<p><strong>预解析 DNS</strong><br>DNS 请求虽然占用了很少的带宽，但是延迟很高，DNS 预解析可以很好的降低延迟。</p>
<ul>
<li><p>用 meta 告诉浏览器，当前页面要做 DNS 预解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&apos;x-dns-prefetch-control&apos; content=&apos;on&apos;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在页面 header 中使用 link 标签来强制对 DNS 预解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 强制查询特定主机名</span><br><span class="line">  &lt;link rel=&apos;dns-prefetch&apos; href=&apos;http://bdimg.share.baidu.com&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>注：dns-prefetch 需慎用，多页面重复 DNS 预解析会增加重复 DNS 查询次数。</p>
</li>
</ul>
<p>需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用 DNS 预读取能节省每月 100 亿的 DNS 查询 。</p>
<p>如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-避免重定向"><a href="#3-避免重定向" class="headerlink" title="3. 避免重定向"></a>3. 避免重定向</h4><ul>
<li>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加/但未添加。</li>
<li>网站域名变更。</li>
</ul>
<h4 id="4-延迟加载"><a href="#4-延迟加载" class="headerlink" title="4. 延迟加载"></a>4. 延迟加载</h4><p>非页面初始加载的必须资源延迟加载</p>
<ul>
<li>非首屏使用的数据、样式、脚本、图片等</li>
<li>用户交互时才会显示的内容</li>
</ul>
<h4 id="5-预加载"><a href="#5-预加载" class="headerlink" title="5. 预加载"></a>5. 预加载</h4><p>利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面更快响应。</p>
<ul>
<li>无条件预先加载</li>
<li>有条件预先加载：根据用户预先判断用户取消，加载相关资源</li>
<li>有【阴谋】的预先加载：页面即将上线新版预先加载新版内容</li>
</ul>
<h4 id="6-减少-DOM-元素数量"><a href="#6-减少-DOM-元素数量" class="headerlink" title="6. 减少 DOM 元素数量"></a>6. 减少 DOM 元素数量</h4><ul>
<li>避免使用表格布局</li>
<li>通过伪元素实现功能</li>
<li><p>为了布局使用的无实际意义<code>div</code>，能否使用方法处理</p>
<p>表格布局的缺点：</p>
<ul>
<li>标签多，增加文件大小</li>
<li>不一维护，无法适应响应式布局</li>
<li>默认的表格布局算法产生大量的重绘</li>
</ul>
</li>
</ul>
<h4 id="7-划分内容到不同的域名"><a href="#7-划分内容到不同的域名" class="headerlink" title="7. 划分内容到不同的域名"></a>7. 划分内容到不同的域名</h4><p>浏览器一般限制每个域的并行线程（6 个或更少），使用不同的域名可以最大化线程，注意保持在 2-4 个域名内，避免 DNS 查询损耗</p>
<h4 id="8-减少-iframe-的使用"><a href="#8-减少-iframe-的使用" class="headerlink" title="8.减少 iframe 的使用"></a>8.减少 iframe 的使用</h4><p>优点：</p>
<ul>
<li>用来加载速度较慢的第三方资源，广告</li>
<li>作为安全沙箱</li>
<li>并行下载脚本</li>
</ul>
<p>缺点：</p>
<ul>
<li>加载代价高昂</li>
<li><p>阻塞页面 load 事件触发</p>
<p><em>iframe 完全加载后，父页面才会触发 load 事件，Safari,Chrome 中通过 JS 动态设置 iframe src 避免这个问题</em></p>
</li>
<li><p>缺乏语义</p>
</li>
</ul>
<h4 id="9-避免-404-错误"><a href="#9-避免-404-错误" class="headerlink" title="9. 避免 404 错误"></a>9. 避免 404 错误</h4><p>无效的 404 响应，浪费服务器资源</p>
<h2 id="二、服务器"><a href="#二、服务器" class="headerlink" title="二、服务器"></a>二、服务器</h2><h4 id="1-使用-CDN"><a href="#1-使用-CDN" class="headerlink" title="1. 使用 CDN"></a>1. 使用 CDN</h4><p>用户与服务器的物理距离对响应事件也有影响。<br>静态内容分发网络：一组分散在不同地理位置的 web 服务器，用来给用户更高效的发送内容。</p>
<h4 id="2-HTTP-缓存，添加-Expires-或-Catch-Control-响应头"><a href="#2-HTTP-缓存，添加-Expires-或-Catch-Control-响应头" class="headerlink" title="2.HTTP 缓存，添加 Expires 或 Catch-Control 响应头"></a>2.HTTP 缓存，添加 Expires 或 Catch-Control 响应头</h4><p>强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200。</p>
<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><ul>
<li>Expires:时间（基本已经淘汰）<br>缓存过期的时间<br><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code><br><code>Expires</code>是 HTTP/1 的产物，表示资源会在<code>Wed, 22 Oct 2018 08:41:00 GMT</code>后过期，需要再次请求。并且<code>Expires</code>受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</li>
<li>Catch-Control<br>具体可以看<a href="https://dorisfeng.github.io/2020/01/05/m-HTTP%E5%8D%8F%E8%AE%AE/">请求、响应头</a><br><code>Cache-control: max-age=30</code><ul>
<li>private:仅浏览器可以缓存</li>
<li>public:浏览器和代理服务器都可以缓存</li>
<li>max-age=xxx,过期时间（单位秒）</li>
<li>s-maxage=30,覆盖 max-age，作用一样，只在代理服务器中生效</li>
<li>no-catch:资源被缓存，但是立即失效，下次会发起请求验证资源是否过期</li>
<li>no-store:不强缓存，也不协商缓存</li>
</ul>
</li>
</ul>
<p>强缓存步骤：</p>
<ol>
<li>第一次请求文件时，缓存中没有信息，直接请求服务器</li>
<li>服务器返回请求的文件，并且 http response header 中 cache-control 为 max-age=xxx</li>
<li>再次请求该文件时，判断是否过期，没有过期直接读取本地缓存，否则进行协商缓存</li>
</ol>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>由服务确定缓存资源是否可用<br>触发条件：</p>
<ul>
<li><code>Catch-Control</code>的值为<code>no-catch</code></li>
<li><p><code>Catch-Control</code>的<code>max-age</code>过期</p>
</li>
<li><p><strong>Last-Modified/If-Modify-Since</strong>:本地文件最后修改日期</p>
<ul>
<li>第一次请求，服务器返回 header 会加上<code>Last-Modified</code>，标识该资源的最后修改时间，例如<code>Last-Modified: Thu,31 Dec 2037 23:59:59 GMT</code>。</li>
<li>再次请求该资源，请求头会包含<code>If-Modify-Since</code>，该值就是上次返回的<code>Last-Modified</code>。服务器收到<code>If-Modify-Since</code>，根据资源的最后修改时间判断是否能使用缓存。</li>
<li>如果可以使用缓存，返回 304，不会返回资源的内容，并且不会返回 <code>Last-Modified</code>。</li>
<li>如果有更新，返回 200，浏览器获取服务器最新资源，和<code>Last-Modified</code></li>
</ul>
<p><strong><code>Lat-Modified</code>的弊端</strong></p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成<code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为<code>Last-Modified</code>只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
</li>
<li><p><strong>ETag/If-None-Match</strong><br>返回一个校验码，任意资源改动了，会导致 ETag 变化<br>服务器根据浏览器 request 的 If-None-Match 值来判断是否命中缓存。<br>与<code>Last-Modified</code>不一样的是，当服务器返回 304 Not Modified 响应，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>
</li>
</ul>
<p>问题：每次验证还是要向服务器发送请求验证，失去了缓存的意义。<br>所以，HTML 使用协商缓存，CSS&amp;JS&amp;图片使用强缓存</p>
<p>web 服务器配置（Node）</p>
<p>ETag 计算</p>
<p>强缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Catch-Control&apos;,&apos;public,max-age=xxx&apos;)</span><br></pre></td></tr></table></figure>
<p>协商缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Catch-Control&apos;,&apos;public,max-age=0&apos;)</span><br><span class="line">res.setHeader(&apos;Last-Modified&apos;,xxx)</span><br><span class="line">res.setHeader(&apos;Etag&apos;,xxx)</span><br></pre></td></tr></table></figure>
<h4 id="3-启用-Gzip"><a href="#3-启用-Gzip" class="headerlink" title="3. 启用 Gzip"></a>3. 启用 Gzip</h4><p><em>注意，图片和 PDF 文件不要使用 gzip,他们本身已经压缩过，再次压缩浪费资源，还会增加文件体积</em><br>HTTP/1.1，web 客户端支持压缩的 Accept-Encoding 请求头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, compress, br</span><br><span class="line"></span><br><span class="line">Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1</span><br></pre></td></tr></table></figure>
<ul>
<li>gzip</li>
<li>compress</li>
<li>deflate</li>
<li>br</li>
<li>identity：指代自身，未经压缩</li>
<li>*</li>
<li>;q=权重</li>
</ul>
<p>如果 web 服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端开启 gzip 压缩<br>node、express 做服务器，中间件<code>compression</code>开启 gzip 压缩</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// server.js</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var compress = require(&apos;compression&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(compress());</span><br></pre></td></tr></table></figure>
<h4 id="4-避免图片-src-为空"><a href="#4-避免图片-src-为空" class="headerlink" title="4.避免图片 src 为空"></a>4.避免图片 src 为空</h4><h2 id="三、Cookie"><a href="#三、Cookie" class="headerlink" title="三、Cookie"></a>三、Cookie</h2><h4 id="1-减少-Cookie-大小"><a href="#1-减少-Cookie-大小" class="headerlink" title="1.减少 Cookie 大小"></a>1.减少 Cookie 大小</h4><p>Cookie 会在 HTTP 头在浏览器和服务器之间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。</p>
<ul>
<li>去除不必要的 Cookie</li>
<li>压缩 Cookie 大小</li>
<li>设置 Cookie 的 domain 级别，如无必要不要影响到 sub-domain</li>
<li>设置合适的过期时间</li>
</ul>
<h4 id="静态资源使用无-Cookie-域名"><a href="#静态资源使用无-Cookie-域名" class="headerlink" title="静态资源使用无 Cookie 域名"></a>静态资源使用无 Cookie 域名</h4><p>静态资源一般无需使用 Cookie,可以把它们放在二级域名或专门域名的无 Cookie 服务器上，降低 Cookie 传送造成的流量浪费，提高响应速度。</p>
<h2 id="四、CSS"><a href="#四、CSS" class="headerlink" title="四、CSS"></a>四、CSS</h2><h4 id="1-把样式表放在中"><a href="#1-把样式表放在中" class="headerlink" title="1.把样式表放在中"></a>1.把样式表放在<head><meta name="generator" content="Hexo 3.8.0">中</head></h4><h4 id="2-不要使用-CSS-表达式"><a href="#2-不要使用-CSS-表达式" class="headerlink" title="2.不要使用 CSS 表达式"></a>2.不要使用 CSS 表达式</h4><h4 id="3-使用代替-import"><a href="#3-使用代替-import" class="headerlink" title="3.使用代替@import"></a>3.使用<link>代替@import</h4><h4 id="4-不要使用-filter"><a href="#4-不要使用-filter" class="headerlink" title="4.不要使用 filter"></a>4.不要使用 filter</h4><p>AlphaImageLoader 为 IE5.5-IE8 专有的技术<br>不是 CSS3 filter</p>
<h2 id="五、JavaScript"><a href="#五、JavaScript" class="headerlink" title="五、JavaScript"></a>五、JavaScript</h2><h4 id="1-把脚本放在页面底部"><a href="#1-把脚本放在页面底部" class="headerlink" title="1.把脚本放在页面底部"></a>1.把脚本放在页面底部</h4><p>浏览器下载脚本，会阻塞其他资源并行下载，即使来自不同域名的资源。<br>最好将脚本放在底部，以提高页面加载速度。<br><strong>非核心代码异步加载</strong></p>
<ul>
<li>异步加载的方式<ol>
<li>动态脚本加载 2. defer 3.async</li>
</ol>
</li>
<li>异步加载的区别<br>defer 是在 html 解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>async 是在加载完成后立即执行，如果是多个，执行顺序和加载顺序无关</li>
</ul>
<h4 id="2-使用外部-JS-和-CSS"><a href="#2-使用外部-JS-和-CSS" class="headerlink" title="2.使用外部 JS 和 CSS"></a>2.使用外部 JS 和 CSS</h4><p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。<br>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p>
<h4 id="3-压缩-JS-和-CSS"><a href="#3-压缩-JS-和-CSS" class="headerlink" title="3.压缩 JS 和 CSS"></a>3.压缩 JS 和 CSS</h4><p>压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。<br>可以使用 Gulp、Webpack 等流行构建工具</p>
<h4 id="4-移除重复脚本"><a href="#4-移除重复脚本" class="headerlink" title="4.移除重复脚本"></a>4.移除重复脚本</h4><h4 id="5-减少-DOM-操作"><a href="#5-减少-DOM-操作" class="headerlink" title="5.减少 DOM 操作"></a>5.减少 DOM 操作</h4><h4 id="6-使用高效的事件处理"><a href="#6-使用高效的事件处理" class="headerlink" title="6.使用高效的事件处理"></a>6.使用高效的事件处理</h4><h2 id="六、图片"><a href="#六、图片" class="headerlink" title="六、图片"></a>六、图片</h2><h4 id="1-优化图片"><a href="#1-优化图片" class="headerlink" title="1.优化图片"></a>1.优化图片</h4><p>尝试把 GIF 格式转换成 PNG 格式，看看是否节省空间。在所有的 PNG 图片上运行 pngcrush（或者其它 PNG 优化工具）。</p>
<h4 id="2-不要在-HTML-中缩放图片"><a href="#2-不要在-HTML-中缩放图片" class="headerlink" title="2.不要在 HTML 中缩放图片"></a>2.不要在 HTML 中缩放图片</h4><p>不要用大图片，然后用宽高缩小图片。<br>设置图片的宽高。避免产生重绘。</p>
<h4 id="3-icon-使用字体图标代替"><a href="#3-icon-使用字体图标代替" class="headerlink" title="3. icon 使用字体图标代替"></a>3. icon 使用字体图标代替</h4><h4 id="4-小图片使用内联图片（base64）"><a href="#4-小图片使用内联图片（base64）" class="headerlink" title="4.小图片使用内联图片（base64）"></a>4.小图片使用内联图片（base64）</h4><h2 id="七、移动端"><a href="#七、移动端" class="headerlink" title="七、移动端"></a>七、移动端</h2><h4 id="1-保证所有组件都小于-25k"><a href="#1-保证所有组件都小于-25k" class="headerlink" title="1.保证所有组件都小于 25k"></a>1.保证所有组件都小于 25k</h4><h4 id="2-打包内容为分段文档"><a href="#2-打包内容为分段文档" class="headerlink" title="2.打包内容为分段文档"></a>2.打包内容为分段文档</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>性能优化考虑的方面：</p>
<ul>
<li>资源本身大小的压缩优化（想办法减少资源的体积）</li>
<li>网络请求的全过程（从 url 地址栏输入发送请求开始到返回响应包的每个环节）</li>
<li>浏览器渲染的全过程（拿到资源后浏览器渲染的每个环节）</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-错误监控</title>
    <url>/2020/01/06/m-%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>错误监控</p>
<a id="more"></a>
<h2 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h2><h3 id="即时运行错误：代码错误"><a href="#即时运行错误：代码错误" class="headerlink" title="即时运行错误：代码错误"></a>即时运行错误：代码错误</h3><h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><h2 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h2><h3 id="即时运行错误"><a href="#即时运行错误" class="headerlink" title="即时运行错误"></a>即时运行错误</h3><ul>
<li>try…catch</li>
<li>window.onerror</li>
</ul>
<h3 id="资源加载错误-1"><a href="#资源加载错误-1" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><ul>
<li>object.onerror<br>资源加载错误事件不会冒泡，只会在本身 object 报错事件进行相应</li>
<li>performance.getEntries()<br>获取所有资源的加载地址</li>
<li>Error 事件捕获</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&apos;error&apos;,function(e)&#123;</span><br><span class="line">    console.log(&apos;捕获&apos;，e)</span><br><span class="line">&#125;,true)</span><br></pre></td></tr></table></figure>
<p>跨域资源加载错误</p>
<ul>
<li>客户端：在 script 标签增加 crossorigin 属性</li>
<li>服务器：设置 JS 资源响应头 Access-Control-Allow-Origin:*</li>
</ul>
<h2 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h2><ul>
<li><p>使用 Ajax 通信进行上报</p>
</li>
<li><p>利用 Image 对象上报</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let errors = &apos;imgerror&apos;;</span><br><span class="line">    (new Image()).src = `http://www.kejiganhuo.com/test?error=$&#123;errors&#125;`;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-通信安全</title>
    <url>/2020/01/05/m-%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>有待补充<br>参考 <a href="https://zhuanlan.zhihu.com/p/61773197" target="_blank" rel="noopener">前端 | XSS 的攻击手段及其防御</a><br>参考 <a href="https://zhuanlan.zhihu.com/p/6182727" target="_blank" rel="noopener">前端 | CSRF 的攻击类型与防御</a><br>参考 <a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">前端安全系列（二）：如何防止 CSRF 攻击？</a></p>
<a id="more"></a>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>cross-site request forgery</p>
<h3 id="跨站攻击伪造"><a href="#跨站攻击伪造" class="headerlink" title="跨站攻击伪造"></a>跨站攻击伪造</h3><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，到达冒充用户对被攻击的网站会执行某项操作的目的。<br>流程：</p>
<ul>
<li>受害者登录 a.com，并保留登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问 b.com</li>
<li>b.com 向 a.com 发送了一个请求:a.com/act=xx，浏览器会默认携带 Cookie</li>
<li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com 以受害者的名义执行 act=xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。<br><strong>特点</strong></li>
<li>发生在第三方域名</li>
<li>攻击者不能获取到 Cookie 等信息，只能使用。</li>
</ul>
<p><strong>类型</strong></p>
<ul>
<li><p>GET 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://a.com/withdraw?amount=1000&amp;ffor=hacker&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>受害者访问含有这个 img 的页面后，浏览器会自动向 a.com 发出一次 HTTP 请求。<a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 就会收到包含受害者登录信息的一次跨域请求。</p>
</li>
<li><p>POST 类型<br>通常是一个自动提交的表单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;http://a.com/withdraw&quot; method=POST&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;airing&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。可见这种类型的 CSRF 与第一种一样，都是模拟请求，所以后端接口也不能将安全寄托在仅允许 POST 请求上。</p>
</li>
<li><p>链接类型<br>需要用户点击链接才会触发，但本质上与前两种一样。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://a.com/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;屠龙宝刀，点击就送！&lt;a/&gt;</span><br></pre></td></tr></table></figure>
<p>由于之前用户登录了信任的网站 A，并且保存登录状态，只要用户主动访问上面的这个页面，则表示攻击成功。<br><strong>防护策略</strong><br>自动防御即利用 HTTP 协议固有的特性进行自动防护，而主动防御则需要通过编程手段进行防御。</p>
<ul>
<li><p><strong>自动防御：阻止不明外域的访问</strong></p>
<ul>
<li>同源检测<ul>
<li>Origin Header<br>如果存在 Origin Header，直接利用其来确认来源域名。<br>Origin Header 不存在<ul>
<li>IE11 同源策略，不会在跨站 CORS 请求上添加 Origin，只使用 Referer</li>
<li>302 重定向之后不包含 Origin，因为 Origin 可能被认为是其他来源的敏感信息。</li>
</ul>
</li>
<li>Referer Header</li>
<li>根据 HTTP 协议，在 HTTP 请求头中有个字段 Referer 记录该请求的来源地址，对于 Ajax 请求、图片和 script 等资源请求，Referer 是发起请求的页面地址，对于页面跳转，Referer 为打开页面历史记录的前一个页面地址，因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名。<br>但是 Referer 的值是浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的 Referer。</li>
</ul>
</li>
<li>响应头 Samesite<ul>
<li><code>Samesite=Strict</code>，严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。</li>
<li>Samesite=Lax：宽松模式，比 Strict 放宽了点限制。假如这个请求是同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 cookie 可以作为第三方 cookie。<br>问题：兼容性不好，不支持子域</li>
</ul>
</li>
</ul>
<p>综上所述，同源验证是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施</p>
</li>
<li><p><strong>主动防御：提交时要求附加本域才能获取的信息</strong></p>
<ul>
<li><p>Synchronizer Tokens 同步表单的 CSRF 校验<br>通过响应页面将 token 渲染到页面上，在 form 表单提交的时候通过隐藏表单域提交。<br>CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。</p>
<p>具体步骤：</p>
<ol>
<li>将 CSRF Token 输出到页面中</li>
<li>页面提交请求携带 Token，通常隐藏在表单域中作为参数提交，或拼接在 URL 后作 query 提交</li>
<li>服务器验证 Token 是否正确</li>
</ol>
<p>服务器收到前端的请求需要判断 Token 的有效性，验证过程是先解密 Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的。这种 Token 的值通常是使用 UserID、时间戳和随机数，通过加密的方法生成。这样的加密既能验证请求的用户、请求的时间，又能保证 Token 不容易被破解。</p>
<p>这种方法要比之前检查 Referer 或者 Origin 要安全一些，Token 可以在产生并放于 Session 之中，然后在每次请求时把 Token 从 Session 中拿出，与请求中的 Token 进行比对。</p>
</li>
<li><p>双重 Cookie 验证<br>利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。<br>具体步骤：</p>
<ol>
<li>用户访问网站页面时，向请求域注入一个 Cookie，内容为随机字符串。</li>
<li>在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中</li>
<li>后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。<br>将 token 设置在 Cookie 中，在提交 POST 请求的时候提交 Cookie，并通过 header 或者 body 带上 Cookie 中的 token，服务端进行对比校验。</li>
</ol>
<p>比 CSRF Token 简单，但是存在缺陷没有大规模应用，因为跨域无法获取 Cookie 中的字段（包括子域名之间的）<br>由于任何跨域都会导致前端无法获取 Cookie 中的字段（包括子域名之间），所以当用户访问我的 me.ursb.me 之时，由于我的后端 api 部署在 api.ursb.me 上，那么在 me.ursb.me 用户拿不到 api.ursb.me 的 Cookie，也就无法完成双重 Cookie 验证。依此，我们的 Cookie 放在了 ursb.me 主域名下，以保证每个子域名都可以访问。但 ursb.me 下其实我还部署了很多其他的子应用，如果某个子域名 xxx.ursb.me 存在漏洞，虽然这个 xxx.ursb.me 可能没有什么值得窃取的信息，但是攻击者可以修改 ursb.me 下的 Cookie，从而实现 XSS 攻击，并利用篡改的 Cookie 对 me.ursb.me 发起 CSRF 攻击。同时，为了确保 Cookie 传输安全，采用这种防御方式的最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式会有风险。</p>
</li>
</ul>
</li>
</ul>
<h2 id="XSS-cross-site-sciriping"><a href="#XSS-cross-site-sciriping" class="headerlink" title="XSS cross-site sciriping"></a>XSS cross-site sciriping</h2><h3 id="跨域脚本攻击"><a href="#跨域脚本攻击" class="headerlink" title="跨域脚本攻击"></a>跨域脚本攻击</h3><p>代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。其重点是『跨域』和『客户端执行』</p>
<p>本质:</p>
<ul>
<li>恶意代码未经过滤，与网站正常代码混在一起</li>
<li>浏览器无法辨别哪些监本可信，导致恶意脚本执行</li>
</ul>
<p>分类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">存储区</th>
<th style="text-align:right">插入点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reflected XSS</td>
<td style="text-align:center">URL</td>
<td style="text-align:right">HTML</td>
</tr>
<tr>
<td>Stored XSS</td>
<td style="text-align:center">后端数据库</td>
<td style="text-align:right">HTML</td>
</tr>
<tr>
<td>DOM XSS</td>
<td style="text-align:center">后端数据库、前端存储、URL</td>
<td style="text-align:right">前端 JS</td>
</tr>
<tr>
<td>JSONP XSS</td>
<td style="text-align:center">后端数据库、前端存储、URL</td>
<td style="text-align:right">前端 JS</td>
</tr>
</tbody>
</table>
<ol>
<li>Reflected XSS（反射型 XSS 攻击）<br>只要由于服务端结束到客户端的不安全输入，在客户端触发执行从而发起 Web 攻击。<br>反射型 XSS 只是简单的把用户输入的数据反射给浏览器，需要攻击者诱使用户点击恶意连接，或者提交表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。这是一种非持久型的攻击。</li>
<li><p>Stored XSS（存储型 XSS 攻击）<br>通过提交恶意脚本在内容存储的服务器上，当其他人看到这些内容时发起 Web 攻击，一般提交内容都是通过富文本编辑的很容易插入危险代码。<br>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。这是一种持久型的攻击。</p>
</li>
<li><p>DOM XSS<br>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。<br>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。<br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const input = document.getElementById(&apos;input&apos;);</span><br><span class="line">    const btn = document.getElementById(&apos;btn&apos;);</span><br><span class="line">    const div = document.getElementById(&apos;div&apos;);</span><br><span class="line"></span><br><span class="line">    let val;</span><br><span class="line"></span><br><span class="line">    input.addEventListener(&apos;change&apos;, (e) =&gt; &#123;</span><br><span class="line">        val = e.target.value;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    btn.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">        div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容： <code>onclick=alert(/xss/)</code>用户提交之后，页面代码就变成了：<code>&lt;a href onclick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;</code><br><strong>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了</strong><br>在使用<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而尽量使用<code>.textContent</code>、<code>.setAttribute()</code>等。<br>DOM 中的内联时间监听器，如<code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code>等，a 标签的<code>href</code>属性，JS 的<code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>等，都能把字符串当做代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p>
</li>
<li><p>JSONP XSS</p>
<ul>
<li>callback 参数意外截断 js 代码，特殊字符单引号双引号，换行符 均存在风险。</li>
<li>callback 参数恶意添加标签，造成 XSS 漏洞<br>跨域访问，服务器返回<code>callback(json)</code>，如果 ajax 请求是 JSONP 请求，返回的内容浏览器还会自动检测，如果不按这个格式返回或者 callback 内容不对，请求失败。</li>
</ul>
</li>
</ol>
<p><strong>防御方式</strong><br>XSS 攻击有两大要素：1. 攻击者提交恶意代码 2. 浏览器执行恶意代码<br>根本的解决方法：从输入到输出都需要过滤、转义。</p>
<ul>
<li><p>输入-客户端请求参数</p>
<ul>
<li>用户输入</li>
<li>URL 参数</li>
<li>POST 参数<br>对输入字符进行转义<br>|特殊符号|实体编码|<br>|—|—|<br>|&amp;|\&amp;|<br>|&lt;|\&lt;|<br>|&gt;|\&gt;|<br>|”|\&quot;|<br>|’|\&#x27;|<br>|/|\&#x2F;|</li>
</ul>
<p>富文本的输入需要额外注意：</p>
<ol>
<li>例行进行输入检查，保证用户输入的是完整的 HTML 代码，而不是拼接的代码</li>
<li>通过<code>htmlParser</code>解析出 HTML 代码的标签、属性、事件</li>
<li><strong>富文本的事件要被禁止</strong>，因为富文本并不需要事件，另外一些危险的标签也需要禁止例如：<code>&lt;iframe&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;base&gt;</code>等</li>
<li>利用白名单机制，只允许安全的标签嵌入，例如：<code>&lt;a&gt;</code>.<code>&lt;img&gt;</code>,<code>&lt;div&gt;</code>等，白名单不仅仅适用于标签，也适用于属性。</li>
<li>过滤用户 CSS，检查是否有危险代码。</li>
</ol>
</li>
<li><p>输出<br>HTML 的输出和输入的转义方式相同<br>JS 代码使用 JavaScriptEncode 转义<br>CSS 严格控制用户将变量输入 style 标签内,不要引用未知的 CSS 文件。</p>
</li>
</ul>
<p><strong>JSONP XSS 的防御方式：</strong></p>
<ul>
<li>严格定义 Content-Type: application / json。如果接口返回的不是 html，千万不要写成 html。</li>
<li>callback 做长度限制，一般对函数名限制在 50 个字符内。</li>
<li>检测 callback 里面的字符。一般 callback 里面都是字母和数字，别的符号都不能有。函数名只允许 [, ], a-zA-Z0123456789_, \$, .，防止一般的 XSS，utf-7 XSS 等攻击。</li>
<li>过滤 callback 以及 JSON 数据输出，原理同输出转义。</li>
</ul>
<p><strong>Web 安全头支持</strong></p>
<ol>
<li>CPS：W3C 的 Content Security Policy，用来定义页面可以加载哪些资源，减少 XSS 发生。</li>
<li>X-Download-Options:noopen:默认开启，禁用 IE 下载框 Open，防止 IE 下载文件默认被打开 XSS</li>
<li>X-Content-Type-Options:nosniff：禁用 IE8 自动嗅探 mime 功能例如 text/plain 却当成 text/html 渲染，特别当本站点 server 的内容未必可信的时候。</li>
<li>X-XSS-Protection：IE 提供的一些 XSS 检测与防范，默认开启</li>
</ol>
<p><strong>HTTP-only Cookie</strong><br>浏览器将禁止页面的 Javascript 访问带有 <code>HttpOnly:true</code> 属性的 Cookie。<br>严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-通信</title>
    <url>/2020/01/05/m-%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>通信</p>
<a id="more"></a>
<h1 id="同源策略及限制"><a href="#同源策略及限制" class="headerlink" title="同源策略及限制"></a>同源策略及限制</h1><p>概念：同源策略限制从一个源文件或者脚本如何与另一个源的资源进行交互，是一个用于隔离潜在恶意文件的安全机制。<br>跨域存在的原因：浏览器同源策略，不允许访问非同源的页面。为了保证用户信息安全，防止恶意的网站窃取数据。<br>同源：协议相同，域名相同，端口相同</p>
<ol>
<li><code>Cookie</code>、<code>localStorage</code>、<code>indexDB</code>等无法读取</li>
<li>无法获取操作<code>DOM</code></li>
<li><code>AJAX</code>请求不能发送</li>
</ol>
<h1 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h1><p>Ajax–&gt;只适合同源通信<br>WebSocket–&gt;不受同源策略限制<br>CORS–&gt;最新通信标准，支持同源通信也支持跨域通信</p>
<h1 id="如何创建-ajax"><a href="#如何创建-ajax" class="headerlink" title="如何创建 ajax"></a>如何创建 ajax</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(options) &#123;</span><br><span class="line">    let params = formsParams(options.data)</span><br><span class="line">    //兼容性</span><br><span class="line">    let xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    //请求类型</span><br><span class="line">    if (options.type === &apos;GET&apos;) &#123;</span><br><span class="line">        xhr.open(options.type, options.url + &apos;?&apos; + params, options.async);</span><br><span class="line">        xhr.send(null)</span><br><span class="line">    &#125; else if (options.type === &apos;POST&apos;) &#123;</span><br><span class="line">        xhr.open(options.type, options.url, options.async);</span><br><span class="line">        xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">        xhr.send(params)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">        //成功 片段请求206</span><br><span class="line">        if (xhr.status === 200 || xhr.status === 304||xhr.status===206) &#123;</span><br><span class="line">            var res;</span><br><span class="line">            if (options.success &amp;&amp; options.success instanceof Function) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                if (typeof res === &apos;string&apos;) &#123;</span><br><span class="line">                    res = JSON.parse(res);</span><br><span class="line">                    options.success.call(xhr, res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //失败</span><br><span class="line">            if (options.error &amp;&amp; options.error instanceof Function) &#123;</span><br><span class="line">                options.error.call(xhr, res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //请求数据处理</span><br><span class="line">    function formsParams(data) &#123;</span><br><span class="line">        var arr = [];</span><br><span class="line">        for (var prop in data) &#123;</span><br><span class="line">            arr.push(prop + &quot;=&quot; + data[prop]);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr.join(&quot;&amp;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">    url: &quot;/price&quot;, // url----&gt;地址</span><br><span class="line">    type: &quot;GET&quot;, // type ---&gt; 请求方式</span><br><span class="line">    async: true, // async----&gt; 同步：false，异步：true</span><br><span class="line">    data: &#123; //传入信息</span><br><span class="line">        name: &quot;张三&quot;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (data) &#123; //返回接受信息</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (err) &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>参考：<a href="https://mp.weixin.qq.com/s/g6_-IU0HHP4rfFytFFHmdA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/g6_-IU0HHP4rfFytFFHmdA</a><br>参考：前端的网络请求方式</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-面向对象和原型链</title>
    <url>/2020/01/05/m-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>面向对象和原型链</p>
<a id="more"></a>
<h1 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h1><ul>
<li>直接量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125;,[],function()&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">let tom=new Person(&apos;tom&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Object.create</p>
<p>根据原型创建对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create(Object.prototype)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h1><p>参考简书上整理的<a href="https://www.jianshu.com/writer#/notebooks/30666412/notes/35549465" target="_blank" rel="noopener">面向对象</a><br><img src="/2020/01/05/m-面向对象和原型链/img1.webp" alt="原型链"></p>
<h1 id="intanceof-原理"><a href="#intanceof-原理" class="headerlink" title="intanceof 原理"></a>intanceof 原理</h1><p>实例 instanceof 构造函数<br>实例.<code>__proto__</code>是否等于构造函数<code>.prototype</code> 或原型链上的其他原型</p>
<p>所以使用 <code>instanceof</code>判断是否是该构造函数的实例并不严禁<br>应该使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例.`__proto__.constructor` 是否等于构造函数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-HTTP协议</title>
    <url>/2020/01/05/m-HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>需补充 HTTP1.0 1.1、2.0 区别</p>
<a id="more"></a>
<h2 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h2><p>HyperText Transfer Protocol<br>HTTP 是一个用在计算机世界里的协议，它确立了计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。<br>HTTP 是专门用来在两点之前传输数据，不能用于广播、寻址或路由。<br>HTTP 传输的是文字、图片、音频、视频等超文本数据。<br>HTTP 是构建互联网的重要技术基础技术，它没有实体，依赖许多其他的技术来实现，同时许多技术也依赖于它。<br>HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 实现寻址和路由，TCP 协议实现可靠数据传输、DNS 协议实现域名查找，SSL/TLS 协议实现安全通信，此外还有一些协议依赖于 HTTP,如 WebSocket、HTTPDNS 等。</p>
<h2 id="HTTP-不是什么"><a href="#HTTP-不是什么" class="headerlink" title="HTTP 不是什么"></a>HTTP 不是什么</h2><p>HTTP 不是互联网，<br>HTTP 不是编程语言<br>HTTP 不是 HTML<br>HTTP 不是一个孤立的协议</p>
<h2 id="HTTP-协议的主要特点"><a href="#HTTP-协议的主要特点" class="headerlink" title="HTTP 协议的主要特点"></a>HTTP 协议的主要特点</h2><ul>
<li>灵活可扩展： HTTP 允许传输任意类型的数据对象，正在传输的类型由 Content-Type 来标识。</li>
<li>可靠传输：尽量保证数据的送达</li>
<li>应用层协议：比 FTP、SSH 等更通用更多，能够传输任意数据</li>
<li>请求-应答通信模式：客户端主动发起请求，服务器被动回复请求</li>
<li>支持客户/服务器模式</li>
<li>简单快速<br>客户向服务器请求服务时，只需传送请求方法和路径。</li>
<li>无状态：每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<p>缺点</p>
<ul>
<li>明文 信息泄漏</li>
<li>不安全 身份认证和完整性校验 HTTPS</li>
<li>性能 Web 性能优化 HTTP/2 HTTP/3</li>
</ul>
<h2 id="浏览器发起-HTTP-请求过程"><a href="#浏览器发起-HTTP-请求过程" class="headerlink" title="浏览器发起 HTTP 请求过程"></a>浏览器发起 HTTP 请求过程</h2><p><img src="/2020/01/05/m-HTTP协议/img1.png" alt="HTTP 请求过程"></p>
<ol>
<li>浏览器从地址栏的输入中（可能通过 DNS 解析）获取服务器的 IP 地址（或 CDN 的 IP）和端口号</li>
<li>如果返回的是 CDN 的 IP,访问 CDN 时先看是否缓存了，缓存了响应用户，无法缓存，缓存失效或者无缓存，回源请求(back to the source request),来拉取最新的数据。</li>
<li>如果返回的是服务器的 IP,浏览器通过 TCP 三次握手与服务器建立连接</li>
<li>浏览器向服务器发送请求报文</li>
<li>服务器收到请求报文后回复确认收到请求的报文，然后将相应报文发给浏览器</li>
<li>浏览器解析响应报文，渲染出页面</li>
</ol>
<h2 id="域名解析的过程"><a href="#域名解析的过程" class="headerlink" title="域名解析的过程"></a>域名解析的过程</h2><ol>
<li>浏览缓存</li>
<li>操作系统缓存</li>
<li>本机域名解析文件 hosts</li>
<li>非权威域名服务器查询其缓存</li>
<li>根域名服务器，返回顶级域名服务器 IP</li>
<li>顶级域名服务器，返回权威域名服务器 IP</li>
<li>权威域名服务器，返回域名 IP，或报错</li>
</ol>
<h2 id="TCP-报文组成部分"><a href="#TCP-报文组成部分" class="headerlink" title="TCP 报文组成部分"></a>TCP 报文组成部分</h2><ul>
<li>TCP 头,至少 20 字节<ul>
<li>发送方端口号</li>
<li>接收方端口号</li>
<li>包序号</li>
<li>标志位</li>
<li>……</li>
</ul>
</li>
<li>实际传输的数据，大小通常 1460 字节</li>
</ul>
<h2 id="HTTP-报文的组成部分"><a href="#HTTP-报文的组成部分" class="headerlink" title="HTTP 报文的组成部分"></a>HTTP 报文的组成部分</h2><ul>
<li><p>请求报文</p>
<ul>
<li><p>请求行</p>
<ul>
<li><p>请求方法：大写<br>客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作。</p>
<ol>
<li>GET：获取资源，可以理解为读取或者下载资源</li>
<li>HEAD：获取资源的元信息(响应头)，GET 的简化版，检查一个文件是否存在</li>
<li>POST：向资源提交数据，写入或上传数据（create）</li>
<li>PUT：类似 POST（update）</li>
<li>DELETE：删除资源</li>
<li>CONNECT：建立客户端与另外一台服务器建立特殊的连接隧道</li>
<li>OPTIONS：要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。</li>
<li>TRACE：追踪请求-响应的传输路径</li>
</ol>
</li>
<li><p>请求 URI</p>
</li>
<li><p>HTTP 协议版本号<br>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>
<p><img src="/2020/01/05/m-HTTP协议/img2.png" alt="请求行"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>| 请求方法 | 请求 URI | 协议版本号 |<br>| ——– | ——– | ———- |<br>| GET      | /        | HTTP       |</p>
</li>
</ul>
</li>
<li><p>请求头：请求和响应的条件和属性 key-value 形式</p>
<ul>
<li>可以任意添加自定义头</li>
<li>字段名不区分大小写，一般首字母大写</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复除非这个字段本身的语义允许，例如 Set-Cookie</li>
</ul>
</li>
<li><p>空行：告诉服务器接下来是请求体</p>
</li>
<li>请求体</li>
</ul>
</li>
<li><p>响应报文</p>
<ul>
<li><p>状态行</p>
<ul>
<li>HTTP 协议版本</li>
<li>响应结果状态码，</li>
<li>原因短语，作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ul>
<p><img src="/2020/01/05/m-HTTP协议/img3.png" alt="状态行"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">HTTP/1.1 404  Not Found</span><br></pre></td></tr></table></figure>
<p>| 版本号   | 状态码 | 原因      |<br>| ——– | —— | ——— |<br>| HTTP/1.1 | 200    | OK        |<br>| HTTP/1.1 | 404    | Not Found |</p>
</li>
</ul>
</li>
<li><p>响应头</p>
</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h3 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h3><ul>
<li>通用字段：在请求头和响应头都可以出现</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件</li>
<li>响应字段：仅能出现在响应头里，进一步说明响应报文的信息</li>
<li><p>实体字段：属于通用字段，但专门描述 body 的额外信息<br><img src="/2020/01/05/m-HTTP协议/img21.png" alt="头字段"><br><strong>Host</strong><br>请求字段，只能出现在请求头里。唯一一个 HTTP/1.1 规范里要求必须出现的字段<br>告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器就需要用 Host 字段来选择。</p>
<p><strong>User-Agent</strong><br>请求字段，只能出现在请求头里。<br>使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</p>
<p><strong>Date</strong><br>通用字段，通常出现在响应头。表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</p>
<p><strong>Server</strong><br>响应字段，只能出现在响应头。客户端当前正在提供 Web 服务的软件名称和版本号，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server: openresty/1.15.8.1</span><br></pre></td></tr></table></figure>
<p>Server 字段不是必须的，黑客可能利用服务器 bug 攻陷服务器，所以响应头要么没有这个字段，要么是个无关的描述信息。</p>
</li>
</ul>
<h4 id="大文件传输相关头"><a href="#大文件传输相关头" class="headerlink" title="大文件传输相关头"></a>大文件传输相关头</h4><p>1.数据压缩 2.分块传输 3.范围请求 4.多段数据</p>
<p><strong>Content-Length</strong><br>报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务端/客户端通过它来得知后续要读取消息的长度。<br>Content-Length 首部指示出报文中实体主体的字节大小. 但如在请求处理完成前无法获取消息长度, 我们就无法明确指定 Content-Length, 此时应该使用 Transfer-Encoding: chunked</p>
<p><strong>Accept-Ranges</strong><br>响应头使用字段<code>Accept-Ranges: bytes</code>告诉客户端在请求头里可以使用 Range 的范围。<br>如果服务器不支持范围请求返回<code>Accept-Ranges:none</code></p>
<p><strong>Range</strong></p>
<ul>
<li>请求一段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes=start-end //注意，这个表示[start,end]，即是包含请求头的 start 及 end 字节的，所以，下一个请求，应该是上一个请求的[end+1, nextEnd]</span><br><span class="line">Range: bytes=10- //第10个字节及最后个字节的数据</span><br><span class="line">Range: bytes=40-100 //第 40 个字节到第 100 个字节之间的数据,对应Content-Length:61</span><br></pre></td></tr></table></figure>
<p>服务器收到<code>Range</code>字段后，需要做四件事：</p>
<ol>
<li>检查范围是否合法，如果超过范围（只有 100 字符，请求 200-300），返回 416</li>
<li>范围正确，服务器根据<code>Range</code>计算偏移量，读取文件片段（如果服务器需要压缩文件，也是按照计算范围后的）返回 206</li>
<li>服务器要添加一个响应头 Content-Range，片段的实际偏移量和资源总大小，<code>Content-Range: bytes 0-99/300</code></li>
</ol>
<ul>
<li><p>请求多段数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range: bytes=0-9,20-29</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种情况服务器的响应头需要一个新的文件内容<code>Content-Type:multipart/byteranges;boundary=xxx</code>，<br>“multipart/byteranges”是一种特殊额 MIME 类型，boundary 是分段之间的分隔标记。<br><img src="/2020/01/05/m-HTTP协议/img8.png" alt="多段数据格式"><br>每个分段必须以分隔符<code>--boundary</code>开始，之后是响应头<code>Content-Type</code>和<code>Content-Range</code>标记这段数据的类型和所在范围，然后跟正常数据一样加一个空行，加上分段数据，最后用<code>--boundary--</code>结束分段。</p>
<p><strong>Content-Range</strong><br>表示响应报文里 body 数据的具体范围，供客户端确认，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Range: bytes 0-99/2000”//意思是此次获取的是总计 2000 个字节的前 100 个字节。对应Content-Length:100</span><br></pre></td></tr></table></figure>
<p><strong>Transfer-Encoding</strong><br>Transfer-Encoding:chunked 与 Content-Length 互斥，这种方式分块传输无法得知 body 的长度。<br>数据格式：<br>分块的格式是 16 进制长度头 + 数据块<br><img src="/2020/01/05/m-HTTP协议/img7.png" alt="多段数据格式"><br><em>分块传输中数据里含有回车换行（\r\n）不影响分块处理，因为分块前有数据长度说明</em></p>
<h4 id="数据类型使用的头字段"><a href="#数据类型使用的头字段" class="headerlink" title="数据类型使用的头字段"></a>数据类型使用的头字段</h4><p>多用途互联网邮件扩展，Multipurpose Internet MailExtensions），简称为 MIME<br><strong>MIME type 分类(请求体或响应体的类型)</strong></p>
<ul>
<li>text 文本格式的可读数据</li>
<li>text/html 超文本文档</li>
<li>text/plain 纯文本</li>
<li>text/css 样式表</li>
<li>image 图片</li>
<li>image/gif</li>
<li>image/jpeg</li>
<li>image/png</li>
<li>audio/video 音频和视频数据</li>
<li>audio/mpeg</li>
<li>video/mp4</li>
<li>application 数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释</li>
<li>application/json</li>
<li>application/javascript</li>
<li>application/pdf</li>
<li>application/octet-stream 不透明的二进制数据</li>
</ul>
<p><strong>Encoding type(请求体或响应体的压缩格式)</strong></p>
<ul>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）</li>
</ul>
<p><strong>Accept</strong><br>客户端用 Accept 头告诉服务器希望接收什么样的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br></pre></td></tr></table></figure>
<p>多个 MIME type 以’,’做分隔符<br><strong>Accept-Encoding</strong><br>客户方支持的压缩格式，例如 gzip,deflate,br，同时支持多个用’,’拼接。<br>如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span><br></pre></td></tr></table></figure>
<p><strong>Content-Type</strong><br>服务器用 Content-Type 头告诉客户端实际发送了什么样的数据<br>POST 请求时，客户端告诉服务器 body 内容的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html</span><br><span class="line">Content-Type: image/png</span><br></pre></td></tr></table></figure>
<p>浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像<br><strong>Content-Encoding</strong><br>服务器实际的压缩格式。<br>如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
<h4 id="语言类型使用的头字段"><a href="#语言类型使用的头字段" class="headerlink" title="语言类型使用的头字段"></a>语言类型使用的头字段</h4><p><strong>Accept-Language</strong><br>标记客户端可以理解的自然语言，多个用’,’隔开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Language:zh-CN, zh, en</span><br></pre></td></tr></table></figure>
<p><strong>Content-Language</strong><br>告诉客户端实体数据使用的实际语言类型</p>
<p><strong>Accept-Charset</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset:gbk, utf-8</span><br></pre></td></tr></table></figure>
<p>客户端可以理解的字符集。<br>服务器中在 Content-Type 字段的数据类型后面用’charset=xxx’,来表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type:text/html;charset=utf-8</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/05/m-HTTP协议/img5.png" alt="数据类型和语言类型"></p>
<h4 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h4><p>Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以使用’q’（quality factor）参数表示权重来设定优先级，最大是 1，最小是 0.01，默认值是 1，如果是 0 就表示拒绝。格式就是在数据类型或语言代码后面加’;q=value’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept:text/html,application/xml;q=0.9,*/*;1=0.8</span><br><span class="line">//表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span><br></pre></td></tr></table></figure>
<h4 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h4><p><strong>Vary</strong><br>响应头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br><span class="line">//表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文</span><br></pre></td></tr></table></figure>
<h4 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h4><p><strong>Connection</strong><br>请求头和响应头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧“。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:close //这次请求后就可以关闭长连接。</span><br></pre></td></tr></table></figure>
<p><strong>Keep-Alive: timeout=value</strong><br>限定长连接的超时时</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>响应头字段：Set-Cookie，请求头字段：Cookie<br>cookie 都是 key=value 的形式，多个 cookie,响应头使用多个 Set-Cookie,请求头会把他们用’;‘连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//response</span><br><span class="line">Set-Cookie: name=123</span><br><span class="line">Set-cookie: age=111</span><br><span class="line">//request(下一次请求)</span><br><span class="line">Cookie: name=123;age=111</span><br></pre></td></tr></table></figure>
<p>Cookie 属性<br><img src="/2020/01/05/m-HTTP协议/img10.png" alt="Set-Cookie"></p>
<ul>
<li>有效期<ul>
<li>Expires 过期时间，截止日期，是一个绝对的时间点</li>
<li>Max-Age 相对时间，单位是秒，浏览器用收到报文的时间 点再加上 Max-Age，就可以得到失效的绝对时间<br>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。<br>如果不配置 Expires 和 Max-Age，Cookie 仅在浏览器运行时有效，一旦浏览器关闭就会失效。<br>如果 Max-Age 为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。<br>如果 Max-Age 为 0，表示删除该 cookie 。默认为 -1。</li>
</ul>
</li>
<li>作用域<ul>
<li>Domain 域名</li>
<li>Path 路径<br>浏览器发送 Cookie 前会从当前 URI 中提取 host 和 path,对比 Cookie 中的设置，如果不满足条件就不会在请求里面发送此 Cookie。<br>通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器 自己去挑。</li>
</ul>
</li>
<li>安全性<ul>
<li>HttpOnly 防止 XSS(跨站脚本攻击)<br>前端通过 JS 脚本获取 Cookie，会带来安全隐患。这个属性就是告诉浏览器此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问。</li>
<li>SameSite 防止 CSRF(跨站请求伪造) - SameSite=Strict，可以严格限定 Cookie 不能随着跳转链接跨站发送， - SameSite=Lax，则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。 - SameSite=Secure，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</li>
</ul>
</li>
</ul>
<p>Cookie 应用</p>
<ul>
<li>身份识别，保存用户的登录信息，实现会话事务</li>
<li>广告跟踪</li>
</ul>
<h2 id="HTTP-协议方法"><a href="#HTTP-协议方法" class="headerlink" title="HTTP 协议方法"></a>HTTP 协议方法</h2><ul>
<li>POST 传输内容</li>
<li>GET 获取内容</li>
<li>PUT 更新</li>
<li>HEAD 获取报文首部</li>
<li>DELETE 删除文件</li>
</ul>
<h2 id="POST-和-GET-请求的区别"><a href="#POST-和-GET-请求的区别" class="headerlink" title="POST 和 GET 请求的区别"></a>POST 和 GET 请求的区别</h2><ol>
<li>GET 请求的参数在 URL 上，POST 请求放在 request.body 里面</li>
<li>GET 请求回退无害，POST 请求会再次提交请求</li>
<li>GET 请求会被浏览器主动缓存，POST 不会，需手动设置</li>
<li>GET 请求比 POST 更不安全，参数直接暴露在 URL 上，不能传敏感信息</li>
<li>GET 请求的参数会保存在浏览器历史记录里面，POST 不会</li>
</ol>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><ul>
<li>1xx：指示请求，表示请求已接收，继续处理</li>
<li><p>2xx：请求正常接收</p>
<ul>
<li>200 OK</li>
<li>204 Not Content:与 200 基本相同但响应头后没有 body 数据</li>
<li>206 Partial Content : 客户端发送了一个带有 Range 请求头的 Get 请求，是表明自己只需要 url 上部分的资源，服务器完成了它。 比如：video audio 播放一个很大的视频/音频地址时，一般会返回 206。通常伴随头字段’Content-Range’，表示响应报文里 body 数据的具体范围，供客户端确认，列如：“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</li>
</ul>
</li>
<li><p>3xx：重定向</p>
<ul>
<li>301 Moved Permanently：永久重定向</li>
<li>302 Found：临时重定向<br>301 和 302 都会在响应头里使用 Location 指明后续要跳转的 URI，最终结果浏览器都会重新定向到新的 URI（可以是相对的也可以是绝对的），这个过程客户是无感知的。</li>
<li>303 See Other：类似 302，但是要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作。</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确。</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。</li>
<li>304 Not Modified：用于 If-Modified-Since 等条件请求，表示资源未修改，不跳转（重定向到已缓存的文件）</li>
</ul>
</li>
<li><p>4xx：客户端错误，请求报文有误，服务器无法处理</p>
<ul>
<li>400 Bad Request：客户端语法错误</li>
<li>401：请求未经授权</li>
<li>403 Forbidden：表示服务器禁止访问资源</li>
<li>404 Not Found：请求的资源在服务器上未找到</li>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET</li>
<li>406 Not Acceptable：资源无法满足客户请求的条件，例如请求中文但只要英文</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态</li>
<li>413 Request Entity Too Large：请求报文的 body 太大</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大</li>
<li>429 Too Many Request：客户端发送太多请求，通常是由于服务器的限连策略</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大</li>
</ul>
</li>
<li>5xx：服务端错误<ul>
<li>500 Internal Server Error：服务端不可预计的错误</li>
<li>501 Not Implemented：表示客户端请求的功能还不支持</li>
<li>502 Bad Gateway：常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误。</li>
<li>503 Service Unavailable: 服务器当前不能处理客户端的请求 临时过载和当机，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</li>
</ul>
</li>
</ul>
<h2 id="短连接-无连接-串行连接-short-lived-connections"><a href="#短连接-无连接-串行连接-short-lived-connections" class="headerlink" title="短连接/无连接/串行连接 short-lived connections"></a>短连接/无连接/串行连接 short-lived connections</h2><p>通信过程：请求-应答<br>底层数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后立即关闭连接。<br>TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。<br>HTTP 的一次简单“请求 - 响应”通常只需要 4 个包，如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是<code>3÷5=60%</code></p>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）</p>
<p>一定时间内，统一域名下的 HTTP 请求，只要两端都没有提出断开连接，则保持 TCP 连接状态，其他请求可以复用这个连接通道。</p>
<p><em>HTTP1.1</em>默认所有连接都是持久连接，不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接。<br>_优点_：减少了建立连接造成的网络资源和通信时间的浪费。</p>
<p><em>缺点 1</em>：阻塞模式，下次请求必须等到上次响应返回后才能发起。<br><em>缺点 2</em>：TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。<br><strong>关闭长连接</strong></p>
<ul>
<li>客户端加上请求头<code>Connection:close</code>关闭长连接。</li>
<li><p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接</li>
</ol>
</li>
<li><p>客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间<br><img src="/2020/01/05/m-HTTP协议/img9.png" alt="数据类型和语言类型"></p>
</li>
</ul>
<h2 id="队头阻塞-Head-of-line-blocking"><a href="#队头阻塞-Head-of-line-blocking" class="headerlink" title="队头阻塞 Head-of-line blocking"></a>队头阻塞 Head-of-line blocking</h2><p>由请求-应答模式导致的，与短连接或长连接无关。<br>HTTP 规定报文必须是”一发一收“，形成了一个先进先出的串行队列，如果队首的请求因为处理的太慢耽误时间，后续的请求也得一起等待，就承担了不应用的时间成本。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h3><p>同时对一个域名发起多个长连接，用数量来解决质量的问题<br>缺陷：每个客户端都想自己快，建立很多个连接，用户数 × 并发数就会是个天文数字。服务器的资源扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务。</p>
<h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><p>客户端使用多个域名指向一台服务器</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3><p><strong>Catch-Control</strong><br>服务器标记的资源有效使用日期。</p>
<ul>
<li><p>max-age=30： 生存时间，单位秒<br>时间的计算起点是响应报文的创建时刻，包含了在链路传输过程中所有节点所停留的时间。</p>
</li>
<li><p>no-store：不允许缓存，用于某些变化非常频繁的数据</p>
</li>
<li>no-cache：可以缓存，但是使用之前必须要跟服务器验证是否过期，是否有最新版本</li>
<li>must-revalidate：如果缓存不过期就可以继续使用，但是过期了如果想用就必须去服务器验证。<br><img src="/2020/01/05/m-HTTP协议/img11.png" alt="Catch-Control"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Catch-Control:max-age=10,must-revalidate;</span><br></pre></td></tr></table></figure>
<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><p><strong>Catch-Control</strong><br>请求头也可以使用。<code>Catch-Control:max-age=0</code>，表示浏览器不使用缓存。<br><code>Ctrl+F5</code>的强制刷新，其实是发起一个<code>Catch-Control:no-cache</code><br>浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。</p>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因 为缓存会失效，使用前还必须要去服务器验证是否是最新版。</p>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p><strong>Last-Modified</strong><br>文件的最后的修改时间<br><strong>ETag</strong><br>实体标签（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。<br>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值钱有个‘W/’标记，只要求资源在语义上没有变化，但是内部肯能会有部分发生了改变。</p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><strong>If-Modified-Since</strong><br>上次响应头返回的 Last-Modified<br><strong>If-None-Match</strong><br>上次响应头返回的 ETag<br>如果缓存有效服务器就会返回 304。</p>
<h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><p>服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份。<br>面向下游用户，表现为服务器，代表服务器响应客户端请求；<br>面向上游源服务器，又表现为客户端，代表客户端发送请求。<br>常用反向代理</p>
<h3 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h3><ul>
<li><p>负载均衡<br>在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，这样代理就可以根据负载均衡算法尽量把外部的流量合理分散到多台源服务器，提供系统的整体资源利用率和性能。</p>
</li>
<li><p>健康检查<br>使用”心跳“等机制监控后端服务器，发现有故障就及时剔除集群，保证服务质量。</p>
</li>
<li><p>安全防护<br>保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载。</p>
</li>
<li>加密卸载<br>对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本。</li>
<li>数据过滤<br>拦截上下行的数据，任意指定策略修改请求或响应</li>
<li>内容缓存<br>暂存、复用服务器响应。</li>
</ul>
<h3 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h3><p><strong>Via</strong><br>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息（代理主机名/域名）追加到字段的末尾。<br>但服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。</p>
<p>通常服务器需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析。</p>
<p><strong>X-Forwarded-For</strong><br>为谁转发，<br>每经过一个代理节点就会在字典里追加请求放的 IP 地址，所以最左边的 IP 地址就是客户端地址。<br><strong>X-Real-IP</strong><br>记录客户端 IP 地址，没有中间的代理信息。</p>
<h4 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h4><p>通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说 成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据， 会降低代理的转发性能，有些情况下是不允许甚至不可能的修改。<br>”代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。<br>v1 在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。<br>这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或 者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行(\r\n)结束。<br>不过代理协议并不支持“X-Forwarded-For”的链式地址形式，所以拿到客户端地址后再 如何处理就需要代理服务器与后端自行约定。</p>
<h3 id="缓存代理服务"><a href="#缓存代理服务" class="headerlink" title="缓存代理服务"></a>缓存代理服务</h3><p>缓存代理服务收到源服务器发来的响应数据后，把报文转发给客户端，同时把报文存入自己的 Cache。<br>这样下一次再有相同请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从原服务器获取，降低客户端的等待时间，节约了源服务器的网络带宽。</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><h4 id="服务器缓存控制"><a href="#服务器缓存控制" class="headerlink" title="服务器缓存控制"></a>服务器缓存控制</h4><p>Cache-Control: max-age,no-store,no-cache,must-revalidate</p>
<ol>
<li><p>上面的属性也可以约束代理。<br>客户端上的缓存和代理上的缓存可以使用两个新属性：</p>
<ul>
<li>private：表示缓存只能在客户端保存，是用户私有的，不能放在代理上与别人共享</li>
<li>public：缓存完全开放，谁都能用，默认值。</li>
</ul>
</li>
<li><p>缓存失效后重新验证也要分开（即使用条件请求“Last-Modified”和”ETag”）, “must-revalidate”是只要过期就必须回源服务器验证。<br>“proxy-revalidate”只要求代理实务缓存过期后必须验证，客户端不必回源，只验证到代理。</p>
</li>
<li><p>缓存的生存时间使用新的“s-maxage”(s 是 share 的意思，注意 maxage 中间没有“-”)，只限定在代理上能够存多久，而客户端仍然使用“max_age。</p>
</li>
<li><p>还有一个代理专用的属性“no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止这样做。</p>
</li>
</ol>
<p>源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。<br>下面的流程图是完整的服务器端缓存控制策略，可以同时控制客户端和代理。<br><img src="/2020/01/05/m-HTTP协议/img12.png" alt="服务器缓存"></p>
<h4 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h4><p><img src="/2020/01/05/m-HTTP协议/img13.png" alt="客户端缓存"></p>
<p>max-age,no-store,no-cache 也同样作用域代理和源服务器。<br>max-stale:如果代理上的缓存过期也可以接受，但不能过期太久，超时也不能用。<br>min-fresh:缓存必须有效，而且必须在 x 秒后依然有效。<br>only-if-cached：表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h3><ul>
<li><p>机密性 Secrecy/Confidentiality<br>是指对数据的保密，只能由可信的人访问，对其他人是不可见的机密，就是不能让不相关的人看到不该看的东西。</p>
</li>
<li><p>完整性 Integrity 一致性<br>是指数据在传输过程中没有被篡改。</p>
</li>
<li><p>身份认证 Authentication<br>是指确认对方的真实身份，保证消息只能发送给可信的人。</p>
</li>
<li><p>不可否认 Non-repudiation/Undeniable<br>不可抵赖。不能否认已经发生过的行为。</p>
</li>
</ul>
<p>默认端口号 443，<br>满足四大安全特性：机密性，完整性，不可否认，身份认证<a href="https://dorisfeng.github.io/2020/01/05/m-安全/">m-安全</a><br>HTTPS 下层的传输协议不是 TCP/IP 而是 SSL/TLS,HTTPS over SSL/TLS，收发报文不再使用 Socket API，而是调用专门的安全接口<br><img src="/2020/01/05/m-HTTP协议/img14.png" alt="https"></p>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>SSL，安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层）。<br>SSLv3 版本已经很完善，1999 年改名为 TLS(传输层安全，Transport Layer Security)，即 TSL1.0 就是 SSLv3.1。<br>目前应用最广泛的 TLS 是 1.2。<br>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。<br>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为‘密码套件’。<br>密码套件的命名规范：密钥交换算法+签名算法+对称加密算法+摘要算法<br>机密性：加密，完整性：接口签名算法，身份认证：数字签名<br><img src="/2020/01/05/m-HTTP协议/img15.png" alt="TLS"><br>上图显示环境使用的 TLS 是 1.2，客户端和服务器都支持非常多的密码套件，而最 后协商选定的是 ECDHE-RSA-AES256-GCM-SHA384。<br>握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和 产生随机数。<br>OpenSSL 是著名的开源密码学工具包，是 SSL/TLS 的具体实现。</p>
<h4 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h4><ul>
<li><p><strong>记录协议</strong> record Protocol<br>规定了 TLS 收发数据的基本单位：记录（record），所有的子协议都通过记录协议发出，多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</p>
</li>
<li><p><strong>警报协议</strong> Alert Protocol<br>向对方发出警报信息，有点像 HTTP 协议里的状态码。</p>
</li>
<li><p><strong>握手协议</strong> Handshake Protocol<br>浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到的会话密钥，用于后续的混合加密系统。</p>
</li>
<li><p><strong>变更密码规范协议</strong> Change Cipher Spec Protocol<br>通知对方，后续的数据都将使用加密保护，之前的数据都是明文。<br><img src="/2020/01/05/m-HTTP协议/img17.png" alt="ECDHE握手"></p>
</li>
</ul>
<h4 id="ECDHE-握手"><a href="#ECDHE-握手" class="headerlink" title="ECDHE 握手"></a>ECDHE 握手</h4><ol>
<li><p>Client Hello</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Client Hello</span><br><span class="line"> Version: TLS 1.2 (0x0303)</span><br><span class="line"> Random: 1cbf803321fd2623408dfe…</span><br><span class="line"> Cipher Suites (17 suites)</span><br><span class="line">     Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line">     Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span><br></pre></td></tr></table></figure>
<p>客户端向服务器发送客户端 TLS 版本号（Version），支持的密码套件（Cipher），随机数 Random（用于后续生成会话密钥）。</p>
</li>
<li><p>Server Hello</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Server Hello</span><br><span class="line"> Version: TLS 1.2 (0x0303)</span><br><span class="line"> Random: 0e6320f21bae50842e96…</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span><br></pre></td></tr></table></figure>
<p>确认 TLS 版本号，随机数，从客户端 Cipher 里面选择一个用于本次通信的密码套件</p>
</li>
<li><p>服务器把证书发送给服务器（Server Certificate），证明身份。</p>
</li>
<li><p>Server Key Exchange<br>因为服务器选择 ECDHE 算法，服务器发送椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Server Key Exchange</span><br><span class="line">EC Diffie-Hellman Server Params</span><br><span class="line">Curve Type: named_curve (0x03)</span><br><span class="line">Named Curve: x25519 (0x001d)</span><br><span class="line">Pubkey: 3b39deaf00217894e...</span><br><span class="line">Signature Algorithm: rsa_pkcs1_sha512 (0x0601)</span><br><span class="line">Signature: 37141adac38ea4...</span><br></pre></td></tr></table></figure>
</li>
<li><p>Server Hello Done<br>服务器消息完毕，第一个消息往返结束，两个 TCP 包，共享三个信息 Server Random、Server Random 和 Server Params.</p>
</li>
<li>客户端逐级验证，确认证书的真实性</li>
<li><p>Client Key Exchange<br>客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Client Key Exchange</span><br><span class="line">    EC Diffie-Hellman Client Params</span><br><span class="line">        Pubkey: 8c674d0e08dc27b5eaa…</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pre-Mater<br>客户端和服务器用两个公钥（Server Params、Client Params），利用 ECDHE 算出 Pre-Master，也是一个随机数。<br>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会 话的主密钥，叫“Master Secret”。<br>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</p>
</li>
<li><p>Change Cipher Spec<br>后面都改用对称算法加密通信了，用的 AES</p>
</li>
<li>Finished 消息<br>Finished 消息，之后把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。</li>
<li>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</li>
</ol>
<p>与传统的握手有两点不同：</p>
<ol>
<li>使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息。</li>
<li>因为使用了 ECDHE，客户端可以不用等到服务器发回“Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫“TLS False Start”，意思就是“抢跑”，和“TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</li>
</ol>
<h4 id="RAS-握手过程"><a href="#RAS-握手过程" class="headerlink" title="RAS 握手过程"></a>RAS 握手过程</h4><p><img src="/2020/01/05/m-HTTP协议/img18.png" alt="ECDHE握手"><br>大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</p>
<h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><p>双向认证的流程也没有太多变化，只是在“Server Hello Done”之后，“Client Key Exchange”之前，客户端要发送“Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</p>
<h4 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h4><p>三个主要改进目标:兼容、安全与性能。<br><img src="/2020/01/05/m-HTTP协议/img18.png" alt="TLS1.3握手"></p>
<ol>
<li><p>Client Hello<br>开头的版本号、支持的密码套件和随机数（Client Random）(32 个字节。<br>注意“Client Hello”里的扩展，“supported_versions”表示这是 TLS1.3，“supported_groups”是支持的曲线，“key_share”是曲线对应的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Client Hello</span><br><span class="line"> Version: TLS 1.2 (0x0303)</span><br><span class="line"> Random: cebeb6c05403654d66c2329…</span><br><span class="line"> Cipher Suites (18 suites)</span><br><span class="line">     Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span><br><span class="line">     Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)</span><br><span class="line">     Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)</span><br><span class="line"> Extension: supported_versions (len=9)</span><br><span class="line">     Supported Version: TLS 1.3 (0x0304)</span><br><span class="line">     Supported Version: TLS 1.2 (0x0303)</span><br><span class="line"> Extension: supported_groups (len=14)</span><br><span class="line">     Supported Groups (6 groups)</span><br><span class="line">         Supported Group: x25519 (0x001d)</span><br><span class="line">         Supported Group: secp256r1 (0x0017)</span><br><span class="line"> Extension: key_share (len=107)</span><br><span class="line">     Key Share extension</span><br><span class="line">         Client Key Share Length: 105</span><br><span class="line">         Key Share Entry: Group: x25519</span><br><span class="line">         Key Share Entry: Group: secp256r1</span><br></pre></td></tr></table></figure>
</li>
<li><p>Server Hello<br>给出一个随机数（Server Random）和选定密码套件。<br>supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handshake Protocol: Server Hello</span><br><span class="line">  Version: TLS 1.2 (0x0303)</span><br><span class="line">  Random: 12d2bce6568b063d3dee2…</span><br><span class="line">  Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span><br><span class="line">  Extension: supported_versions (len=2)</span><br><span class="line">      Supported Version: TLS 1.3 (0x0304)</span><br><span class="line">  Extension: key_share (len=36)</span><br><span class="line">      Key Share extension</span><br><span class="line">          Key Share Entry: Group: x25519, Key Exchange length: 32</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>主密钥<br>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random 和 Server Random、Client Params 和 Server Params，两边就可以各自用 ECDHE 算出“Pre-Master”，再用 HKDF 生成主密钥“Master Secret”，效率比 TLS1.2 提高了一大截。</p>
</li>
<li><p>Change Cipher Spec<br>服务器立刻发出“Change Cipher Spec”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。<br>这里 TLS1.3 还有一个安全强化措施，多了个“Certificate Verify”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和“Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</p>
</li>
</ol>
<h2 id="HTTP-2-多路复用"><a href="#HTTP-2-多路复用" class="headerlink" title="HTTP/2 多路复用"></a>HTTP/2 多路复用</h2><p>每个 HTTP 请求都有有个序列标识符，浏览器并发多个请求，服务器接收到数据后，根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个 TCP 连接，极大增加了服务器处理并发的上限。<br><img src="/2020/01/05/m-HTTP协议/img20.png" alt="对比"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-DOM事件</title>
    <url>/2020/01/05/m-DOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>DOM 事件</p>
<a id="more"></a>
<h2 id="DOM-事件的级别"><a href="#DOM-事件的级别" class="headerlink" title="DOM 事件的级别"></a>DOM 事件的级别</h2><ul>
<li><p>HTML 事件处理过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&apos;button&apos; value=&apos;click&apos; onclick=&quot;showMsg()&quot;/&gt;</span><br><span class="line">function showMsg()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.onclick=function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;,function()&#123;&#125;,false)</span><br></pre></td></tr></table></figure>
<p>第三个参数是冒泡阶段触发<code>false</code>（默认）或捕获阶段触发<code>true</code></p>
</li>
<li><p>DOM3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;,function()&#123;&#125;,false)</span><br></pre></td></tr></table></figure>
<p>在 2 的基础上新增许多事件类型</p>
<ul>
<li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li>
<li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li>
<li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li>
<li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>
<li>文本事件，当在文档中输入文本时触发，如：textInput</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>
<li>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</li>
<li>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</li>
<li>同时 DOM3 级事件也允许使用者自定义一些事件。</li>
</ul>
</li>
</ul>
<p><em>为什么没有 DOM1 级事件处理呢？因为 1 级 DOM 标准并没有定义事件相关的内容，所以没有所谓的 1 级 DOM 事件模型。</em></p>
<h2 id="DOM-事件模型"><a href="#DOM-事件模型" class="headerlink" title="DOM 事件模型"></a>DOM 事件模型</h2><p>冒泡：首先在最精确的元素上触发，然后向上传播，直到根节点。<br>捕获：最顶级的元素上触发，传播到最低级的元素上</p>
<h2 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h2><p>捕获-目标阶段-冒泡到 window 对象<br>DOM 的结构是一个树形，每当 HTML 元素产生事件时，该事件就会在树的根节点和元素节点之间传播，所有经过的节点都会收到该事件。</p>
<h2 id="DOM-事件捕获的具体流程（事件传播机制）"><a href="#DOM-事件捕获的具体流程（事件传播机制）" class="headerlink" title="DOM 事件捕获的具体流程（事件传播机制）"></a>DOM 事件捕获的具体流程（事件传播机制）</h2><ol>
<li>window 对象</li>
<li>document 对象</li>
<li>html(document.documentElement)</li>
<li>body</li>
<li>…</li>
<li>目标元素<br>冒泡过程相反</li>
</ol>
<h2 id="Event-事件的具体应用"><a href="#Event-事件的具体应用" class="headerlink" title="Event 事件的具体应用"></a>Event 事件的具体应用</h2><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let event = new Event(type,options);</span><br></pre></td></tr></table></figure>
<ul>
<li>type：字符串，事件名</li>
<li>options：对象，事件配置<ul>
<li>bubbles：布尔值，可选，默认 false，表示事件对象是否冒泡</li>
<li>cancelable：布尔值，可选，默认 false，表示事件是否可以被取消，即是否能用 Event.preventDefault()取消这个事件。</li>
<li>“composed”，可选，Boolean 类型，默认值为 false，指示事件是否会在影子 DOM 根节点之外触发侦听器。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//js</span><br><span class="line">var div = document.querySelector(&apos;div&apos;);</span><br><span class="line">var p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">var look = new Event(&apos;look&apos;);</span><br><span class="line">function callback(event) &#123;</span><br><span class="line">    var tag = event.currentTarget.tagName;</span><br><span class="line">    console.log(tag, event.bubbles)</span><br><span class="line">    console.log(tag, event.eventPhase)</span><br><span class="line">    console.log(&apos;Tag: &apos; + tag);</span><br><span class="line">&#125;</span><br><span class="line">div.addEventListener(&apos;look&apos;, callback);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>
<p>默认 look 事件不能冒泡。div 注册事件时默认冒泡阶段触发（<code>false</code>），指定在冒泡阶段执行回调函数，然后 p 标签触发事件，div 注册的事件将不会执行，只会输出<code>Tag:P</code>。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>event.bubbles<br>返回布尔值，表示当前事件是否冒泡，只读</li>
<li>event.eventPhase<br>返回整数，表示事件目前所处的阶段，只读<ul>
<li>0，事件目前没有发生</li>
<li>1，事件目前处于捕获阶段，即处于祖先节点向目标节点传播的过程</li>
<li>2，事件到达目标节点，即 event.target 属性指向的那个节点</li>
<li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程</li>
</ul>
</li>
<li>event.cancelable<br>返回布尔值，表示事件是否可以取消，只读<br>如果不能取消，调用 event.preventDefault()没有任何效果，</li>
<li>event.cancelBubble<br>布尔值，默认为 false，如果设为 true，相当于执行 event.stopPropagation()，阻止事件冒泡</li>
<li>event,defaultPrevented<br>返回布尔值，默认为 false，如果为 true，表示该事件是否调用过 event.preventDefault() 方法，只读</li>
<li>event.stopImmediatePropagation()<br>一个操作同时注册两个事件 a、b，如果在 a 中添加上面操作，b 就不会执行了。</li>
<li>event.target<br>触发事件的元素</li>
<li>event.currentTarget<br>绑定事件的元素</li>
<li>event.type<br>返回一个字符串，表示事件类型，事件的类型是在生成事件的时候指定的。该属性只读。</li>
<li>event.clientX：鼠标的横坐标</li>
<li>event.clientY：鼠标的纵坐标</li>
<li>event.timeStamp<br>返回毫秒时间戳，表示事件发生的时间，相对于网页加载成功开始计算</li>
<li>event.isTrusted<br>返回布尔值，表示事件是否由真实的用户行为产生。比如 click 时间就是用户点击产生的，用 Event 新建的时间则是脚本产生的。</li>
<li>event.detail<br>浏览器用户界面事件才具有。返回一个数值，表示事件的某种信息具体含义与事件类型相关。<br>比如 click 事件，1。单击，2。双击，3。三击<br>比如鼠标滚轮事件，表示正向滚动的距离，负值就是负向滚动的距离，返回值是 3 的倍数</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>event.preventDefault()<br>阻止事件的默认行为。<br>比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。<br>该方法生效的前提是，事件对象的 cancelable 属性为 true，如果为 false，调用该方法没有任何效果。</p>
<ol>
<li>选择框无法选中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//html</span><br><span class="line"> &lt;input type=&apos;checkbox&apos; id=&apos;my-checkbox&apos; /&gt;</span><br><span class="line"> //js</span><br><span class="line">  let cb = document.getElementById(&apos;my-checkbox&apos;);</span><br><span class="line">  cb.addEventListener(&apos;click&apos;, (e) =&gt; e.preventDefault())</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>文本输入框设置校验条件，如果输入不符合条件，将无法输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let input1 = document.getElementById(&apos;my-input&apos;);</span><br><span class="line">input1.addEventListener(&apos;keypress&apos;, checkName);</span><br><span class="line"></span><br><span class="line">function checkName(e) &#123;</span><br><span class="line">    if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>event.stopPropagation()<br>阻止冒泡，执行后事件不会再向父节点传递</p>
</li>
<li><p>event.stopImmediatePropagation()<br>阻止同一事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。<br>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了 Event.stopImmediatePropagation 方法，其他的监听函数就不会再执行了</p>
</li>
<li><p>event.composePath()<br>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div&gt;</span><br><span class="line">//   &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="line">// &lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&apos;div&apos;);</span><br><span class="line">var p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">console.log(e.composedPath());</span><br><span class="line">&#125;, false);</span><br><span class="line">// [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="添加默认参数"><a href="#添加默认参数" class="headerlink" title="添加默认参数"></a>添加默认参数</h3><p>添加自定义数据 CustomEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var div = document.querySelector(&apos;div&apos;);</span><br><span class="line">var p = document.querySelector(&apos;p&apos;);</span><br><span class="line">const look = new CustomEvent(&apos;look&apos;, &#123;</span><br><span class="line">    bubbles: true,</span><br><span class="line">    cancelable: true,</span><br><span class="line">    detail: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function callback(e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;</span><br><span class="line">div.addEventListener(&apos;look&apos;, callback)</span><br><span class="line"></span><br><span class="line">p.dispatchEvent(look)</span><br></pre></td></tr></table></figure>
<h2 id="事件代理，事件委托"><a href="#事件代理，事件委托" class="headerlink" title="事件代理，事件委托"></a>事件代理，事件委托</h2><p>原理：事件冒泡，将多个子组件的事件冒泡到父组件上<br>减少代码量，节省内存，减少事件注册，提高性能<br>动态增加子组件时，不要添加事件</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>m-CSS</title>
    <url>/2020/01/05/m-CSS/</url>
    <content><![CDATA[<p>CSS 的一些例子和面试题<br><a href="http://cavszhouyou.top/" target="_blank" rel="noopener">参考 1</a></p>
<a id="more"></a>
<h2 id="盒子水平垂直居中"><a href="#盒子水平垂直居中" class="headerlink" title="盒子水平垂直居中"></a>盒子水平垂直居中</h2><ul>
<li><p>position</p>
<ol>
<li>margin 盒子要固定宽高</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -25px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>margin:auto</code> 不用固定宽度，但是要有宽高</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>transform:translate(-50%,-50%)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>display:flex<br>兼容性存在问题，但是可以使用浏览器头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JS 性能不好</p>
</li>
<li><p>display:table-cell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer&#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    text-align: center;</span><br><span class="line">    //=&gt;宽高不能是百分比</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h2><p>组成：margin+border+padding+content</p>
<ul>
<li><strong>标准盒模型</strong> <code>box-sizing:content-box</code><br><img src="/2020/01/05/m-CSS/img3.png" alt="标准盒模型"></li>
<li><strong>IE 盒模型</strong> <code>box-sizing:border-box</code><br><img src="/2020/01/05/m-CSS/img4.png" alt="IE 盒模型"></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>标准模型的宽高=content 的宽高，内容的宽高<br>IE 模型的宽高=border 的宽高+padding 的宽高+content 的宽高，就是盒子的大小</p>
<p><strong>回答：</strong> 标准盒子模型，即 box-sizing:content-box，默认的盒子模型，这种情况下设置的宽高不是盒子的宽高而是 content 的，盒子的宽高是 content+padding+border，这样在项目里面如果要设置了宽高，后面要增加 padding 或 border，就要调整三个值，改动麻烦。<br>后面 CSS3 提供了 IE 盒模型，能够直接控制盒子大小，调整之后，会自动计算 content 宽高，以及我平时用的 antd 大部分样式也用到了 IE 盒模型。</p>
<h3 id="如何设置获取盒模型的宽高"><a href="#如何设置获取盒模型的宽高" class="headerlink" title="如何设置获取盒模型的宽高"></a>如何设置获取盒模型的宽高</h3><ul>
<li><code>dom.style.width/height</code><br>只能获取内联样式的宽高<br>返回字符串（含有 px）</li>
<li><code>dom.currentStyle.width/height</code><br>仅支持 IE 浏览器</li>
<li><code>window.getComputedStyle(dom).width/height</code><br>兼容性比上一个好<br>返回字符串（含有 px）</li>
<li><code>dom.getBoundingClientRect().width/height</code><br>返回数值</li>
</ul>
<h3 id="边界重叠"><a href="#边界重叠" class="headerlink" title="边界重叠"></a>边界重叠</h3><p>边界重叠是指两个或多个盒子（相邻或嵌套）的相邻边界（其间没有任何非空内容、补白、边框）重合在一起而形成一个单边界</p>
<ul>
<li><p>父子元素的边界重叠<br>父元素截取子元素的外边距，高度坍塌。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">      .parent &#123;</span><br><span class="line">          background-color: chocolate</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .parent .child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          margin-top: 10px;</span><br><span class="line">          background-color: aqua</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;div class=&apos;parent&apos;&gt;</span><br><span class="line">      &lt;div class=&apos;child&apos;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/05/m-CSS/img1.png" alt="边界重叠"><br>父元素的高度并没有包含子元素的外边距。<br>如果块元素的<code>margin-top</code>与它的第一个子元素的<code>margin-top</code>之间没有<code>border</code>,<code>padding</code>,<code>inline</code>,<code>content</code>,<code>clearance</code>等来分隔，那么父元素的<code>margin-top</code>和第一个子元素的<code>margin-top</code>重叠，取较大值。<br><code>margin-bottom</code>的道理一样</p>
</li>
<li><p>兄弟元素的边界重叠</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class=&apos;box&apos;&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">      .box &#123;</span><br><span class="line">          background-color: antiquewhite</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .box&gt;div &#123;</span><br><span class="line">          height: 50px;</span><br><span class="line">          margin: 20px auto 30px;</span><br><span class="line">          background-color: aqua</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/05/m-CSS/img2.png" alt="边界重叠"></p>
<p>外边距并不是 30+20，而是取较大的值</p>
</li>
<li><p>空元素边界重叠<br>一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;section &gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        ​​​​​​p &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        div &#123;</span><br><span class="line">            margin-top: 13px;</span><br><span class="line">            margin-bottom: 87px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;上边界范围是 87 ...&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;... 上边界范围是 87&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>无内容<br><img src="/2020/01/05/m-CSS/img6.png" alt="无内容"><br>有内容<br><img src="/2020/01/05/m-CSS/img7.png" alt="有内容"><br>实际占用位置是较大的那个外边距</p>
<h2 id="CSS-选择符有哪些"><a href="#CSS-选择符有哪些" class="headerlink" title="CSS 选择符有哪些"></a>CSS 选择符有哪些</h2><ul>
<li><code>id</code>选择器 - <code>#id</code></li>
<li>类选择器 - <code>.class</code></li>
<li>标签选择器 - <code>div</code></li>
<li>后代选择器 - <code>h1 p</code></li>
<li>相邻后代选择器（子）选择器 - <code>ul&gt;li</code></li>
<li>兄弟选择器 - <code>li~a</code></li>
<li>相邻兄弟选择器 - <code>li+a</code></li>
<li>属性选择器 - <code>a[rel=&#39;externam&#39;]</code></li>
<li>伪类选择器 - <code>a:hover,li:nth-child</code></li>
<li>伪元素选择器 - <code>::afther ::before</code></li>
<li>通配符选择器 - <code>*</code></li>
</ul>
<h2 id="新增伪类"><a href="#新增伪类" class="headerlink" title="新增伪类"></a>新增伪类</h2><ul>
<li><code>ele:nth-child(n)</code><br>父元素下标签名为 ele 的第 n 个子元素，n 可以是数值也可以接收函数</li>
<li><code>ele:nth-last-child(n)</code><br>从后开始第 n 个元素</li>
<li><code>ele:last-child(n)</code><br>最后一个子元素</li>
<li><code>ele:only-child</code><br>父元素下的唯一的标签为 ele 的子元素</li>
<li><code>ele:nth-of-type(n)</code><br>父元素下的第 n 个类型为 ele 的子元素</li>
<li><code>ele:first-of-type</code><br>父元素下的第一个类型为 ele 的子元素</li>
<li><code>ele:last-of-type</code><br>父元素下的最后一个类型为 ele 的子元素</li>
<li><code>ele:only-of-type</code><br>父元素下的唯一的一个类型为 ele 的子元素</li>
<li><code>ele:empty</code><br>不包含子元素和内容的 elem 类型的元素</li>
<li><code>ele:target</code><br>当前活动的 elem 元素</li>
<li><code>:enabled</code><br>控制表单控件的禁用状态</li>
<li><code>:disabled</code><br>控制表单控件的禁用状态</li>
<li><code>:checked</code><br>单选框或复选框被选中</li>
</ul>
<h2 id="BFC（解决边距重叠）"><a href="#BFC（解决边距重叠）" class="headerlink" title="BFC（解决边距重叠）"></a><code>BFC</code>（解决边距重叠）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>Block Formatting Context</code><br>块级格式化上下文<br>(IFC，内联元素格式化上下文)</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><code>BFC</code> 中的元素会在垂直方向发生边距重叠</li>
<li><code>BFC</code> 是一个独立的容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
<li>计算 <code>BFC</code> 的高度时，考虑所有子元素，包括浮动元素</li>
<li>浮动元素的盒不会叠加到 <code>BFC</code> 上</li>
</ul>
<h3 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 <code>BFC</code></h3><ul>
<li>根元素，（html）</li>
<li>浮动元素， float 的值不是 none</li>
<li>绝对定位，position 的值 absolute、fixed</li>
<li>行内块元素，display:inline-block</li>
<li>表格单元格，display:table-cell</li>
<li>表格标题，display:table-caption</li>
<li>弹性布局，display 为 flex、inline-flex 元素的直接子元素</li>
<li>网格元素，display 为 grid、inline-grid 元素的直接子元素</li>
<li>overflow 的值不为 visible,如:hidden/auto</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>解决垂直方向边距重叠<br>父元素创建<code>BFC</code>（overflow:hidden）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">      .parent &#123;</span><br><span class="line">          background-color: chocolate;</span><br><span class="line">          overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .parent .child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          margin-top: 10px;</span><br><span class="line">          background-color: aqua</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;div class=&apos;parent&apos;&gt;</span><br><span class="line">      &lt;div class=&apos;child&apos;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/01/05/m-CSS/img5.png" alt="边界重叠"></p>
<ul>
<li><p>浮动布局，行高不固定，侵占左侧<br>左侧元素创建<code>BFC</code>， <code>BFC</code> 不会与 float 元素发生重叠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section id=&quot;layout1&quot;&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">      #layout1 &#123;</span><br><span class="line">          background: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #layout1 .left &#123;</span><br><span class="line">          float: left;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          background: pink;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #layout1 .right &#123;</span><br><span class="line">          height: 110px;</span><br><span class="line">          background: #ccc;</span><br><span class="line">          overflow: auto</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;!--左边宽度固定，右边自适应--&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除浮动<br>为父元素创建<code>BFC</code>，浮动子元素的高度也会参与到父元素的高度计算</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .clear &#123;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .clear&gt;div &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            float: left;</span><br><span class="line">            background-color: antiquewhite</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div class=&apos;clear&apos;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            清除浮动</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<h2 id="IFC-是什么"><a href="#IFC-是什么" class="headerlink" title="IFC 是什么"></a>IFC 是什么</h2><p>行级格式化上下文</p>
<ol>
<li>行级上下文内部的盒子会在水平方向上，一个接一个的放置</li>
<li>当一行不够的时候会自动切换到下一行</li>
<li>行级上下文的高度由内部最高的内联盒子高度决定</li>
</ol>
<h2 id="使用-css，让一个-div-消失在视野中"><a href="#使用-css，让一个-div-消失在视野中" class="headerlink" title="使用 css，让一个 div 消失在视野中"></a>使用 css，让一个 div 消失在视野中</h2><ol>
<li><code>display:none</code><br>不占页面空间，元素消失。会引起浏览器的重排和重绘。无法点击</li>
<li><code>visible:hidden</code><br>占页面空间。所以只引起重绘不会引起重排。无法点击<br>适用于元素隐藏后不改变页面布局。<br>transition 无效。(会延迟 n 秒后 hidden，但不会渐变)</li>
<li><code>opacity:0</code><br>元素完全透明，可以点击。<br>会被子元素继承,且子元素无法反隐藏。</li>
<li><code>position:absolute;top:-999em</code>,<code>position:relative;top:-999em</code><br>不占页面空间，利用元素位置，将元素移出视野，会引起浏览器的重排和重绘，不可点击。</li>
<li><code>position: absolute; visibility: hidden;</code><br>不占据空间，无法点击</li>
<li><code>overflow:hidden;width:0;height:0;box-sizing:border-box;</code><br>点击事件可以触发</li>
<li><code>transform:translateX(-999px)</code>,<code>transform:translateY(-999px)</code>,<code>transform:translate(-999px,-999px)</code><br>占用页面空间，可以点击</li>
<li><code>transform: scale(0)</code><br>不占据空间，无法点击</li>
<li><code>z-index:-1</code><br>只有元素脱离文档流时，才有效果。即拥有 relative, absolute, fixed 属性的 position 元素。<br>商业转载请联系作者获得授权,非商业转载请注明出处。<br>原文: <a href="https://www.w3cplus.com/css/how-z-index-works.html" target="_blank" rel="noopener">https://www.w3cplus.com/css/how-z-index-works.html</a> © w3cplus.com<br>本质是改变当前 dom 的层叠上下文，把元素隐藏在其他元素之下。<br>部分重排<br>被其他元素遮挡部分，无法响应事件。</li>
<li><code>margin-top: -999px;</code><br>父元素</li>
</ol>
<h2 id="z-index-的工作原理，适用范围"><a href="#z-index-的工作原理，适用范围" class="headerlink" title="z-index 的工作原理，适用范围"></a>z-index 的工作原理，适用范围</h2><ul>
<li>堆叠顺序<br>HTML 文档的元素存在于三维中，<code>z-index</code>控制元素在<code>z</code>轴上的位置，垂直于屏幕。<br><code>&lt;html&gt;</code>元素位于层叠上下文的 root 级别，根层叠，默认情况下，所有元素都说是属于此根层叠上下文，但是任何元素节点也可以是其”局部层叠上下文“中的根层叠。<br>position 属性值为 relative 或 absolute 或 fixed 的对象</li>
</ul>
<p><img src="/2020/01/05/m-CSS/img8.png" alt="z-index"></p>
<ul>
<li>如果父元素 z-index 有效，那么子元素无论是否设置 z-index 都和父元素一致，会在父元素上方。如图元素#3 和元素#5</li>
<li>如果兄弟元素的 z-index 生效，那么其子元素覆盖关系有父元素决定。如图元素#1 和元素#4</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>定位 弹框</li>
<li>文档流</li>
</ul>
<h2 id="div-里面的文字垂直居中，且该文字的大小根据屏幕大小自适应"><a href="#div-里面的文字垂直居中，且该文字的大小根据屏幕大小自适应" class="headerlink" title="div 里面的文字垂直居中，且该文字的大小根据屏幕大小自适应"></a>div 里面的文字垂直居中，且该文字的大小根据屏幕大小自适应</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .inner &#123;</span><br><span class="line">        width: 10rem;</span><br><span class="line">        height: 5rem;</span><br><span class="line">        line-height: 5rem;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 1px solid #000;</span><br><span class="line">        font-size: 1rem;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;inner&apos;&gt; 文字垂直居中&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let body = document.documentElement;</span><br><span class="line"></span><br><span class="line">    let width = body.clientWidth;</span><br><span class="line">    let font = width / 40;</span><br><span class="line">    body.style.fontSize = font + &apos;px&apos;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="一个自适应矩形，水平垂直居中，且宽高比为-2：1"><a href="#一个自适应矩形，水平垂直居中，且宽高比为-2：1" class="headerlink" title="一个自适应矩形，水平垂直居中，且宽高比为 2：1"></a>一个自适应矩形，水平垂直居中，且宽高比为 2：1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        margin: auto;</span><br><span class="line"></span><br><span class="line">        width: 10%;</span><br><span class="line">        height: 0;</span><br><span class="line">        padding-top: 20%;</span><br><span class="line">        background: tomato</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三角型"><a href="#三角型" class="headerlink" title="三角型"></a>三角型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.triangle &#123;</span><br><span class="line">      width: 0;</span><br><span class="line">      height: 0;</span><br><span class="line">      border-width: 100px;</span><br><span class="line">      border-style: solid;</span><br><span class="line">      border-color: tomato transparent transparent transparent;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="正方形"><a href="#正方形" class="headerlink" title="正方形"></a>正方形</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  .square &#123;</span><br><span class="line">      width: 10%;</span><br><span class="line">      height: 10vw;</span><br><span class="line">      background-color: tomato</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .square &#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    height: 0;</span><br><span class="line">    padding-top: 20%;</span><br><span class="line">    background-color: tomato</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现单行、多行文本溢出的省略"><a href="#实现单行、多行文本溢出的省略" class="headerlink" title="实现单行、多行文本溢出的省略"></a>实现单行、多行文本溢出的省略</h2><ul>
<li><p>单行文本溢出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本溢出<br>适合 WebKit 浏览器或移动端</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      text-overflow: ellipsis;</span><br><span class="line">      display: -webkit-box;</span><br><span class="line">      -webkit-line-clamp: 2;</span><br><span class="line">      -webkit-box-orient: vertical;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位</p>
<p>问题：</p>
<ul>
<li>单行文本也会出现…，</li>
<li>可能只遮挡半个文字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">   position:relative;</span><br><span class="line">   line-height:1.5em;</span><br><span class="line">   /* 高度为需要显示的行数*行高，比如这里我们显示两行，则为3 */</span><br><span class="line">   height:3em;</span><br><span class="line">   overflow:hidden;</span><br><span class="line">   word-break: break-all;</span><br><span class="line">&#125;</span><br><span class="line">p:after &#123;</span><br><span class="line">   content:&quot;...&quot;;</span><br><span class="line">   position:absolute;</span><br><span class="line">   bottom:0;</span><br><span class="line">   right:0;</span><br><span class="line">   padding: 0 5px;</span><br><span class="line">   background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐藏元素的-background-image-到底加不加载"><a href="#隐藏元素的-background-image-到底加不加载" class="headerlink" title="隐藏元素的 background-image 到底加不加载"></a>隐藏元素的 background-image 到底加不加载</h2><ul>
<li>元素的背景图片<ul>
<li>元素本身设置<code>display:none</code>，会请求图片</li>
<li>父元素设置<code>display:none</code>,不会请求图片</li>
<li><code>background-image</code>没有使用，不会请求</li>
<li><code>hover</code>伪类设置的背景图片，触发时请求</li>
</ul>
</li>
<li><code>img</code>标签图片在任何情况下都会请求图片</li>
</ul>
<h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h2><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60*1000ms ＝ 16.7ms</p>
<h2 id="如何去除inline-block元素间距"><a href="#如何去除inline-block元素间距" class="headerlink" title="如何去除inline-block元素间距"></a>如何去除<code>inline-block</code>元素间距</h2><p>移除空格使用<code>margin</code>负值，使用<code>font-size:0</code>，<code>letter-spacing</code>，<code>word-spacing</code>。</p>
<h2 id="overflow-scroll-时不能平滑滚动的问题怎么处理"><a href="#overflow-scroll-时不能平滑滚动的问题怎么处理" class="headerlink" title="overflow:scroll 时不能平滑滚动的问题怎么处理"></a><code>overflow:scroll</code> 时不能平滑滚动的问题怎么处理</h2><p>以下代码可解决这种卡顿的问题：<code>-webkit-overflow-scrolling:touch</code>,是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p>
<h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp" class="headerlink" title=".png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp"></a>.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp</h2><p>（1）第一种是 BMP 格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。</p>
<p>（2）第二种是 GIF 格式，它是无损压缩的使用索引色的点阵图。由于使用了 LZW 压缩方法，因此文件的体积很小。并且 GIF 还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</p>
<p>（3）第三种是 JPEG 格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于 GIF 格式来说更大。</p>
<p>（4）第四种是 PNG-8 格式，它是无损压缩的使用索引色的点阵图。它是 GIF 的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于 GIF 格式更小。一般来说如果不是需要动画的情况，我们都可以使用 PNG-8 格式代替 GIF 格式。</p>
<p>（5）第五种是 PNG-24 格式，它是无损压缩的使用直接色的点阵图。PNG-24 的优点是它使用了压缩算法，所以它的体积比 BMP 格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</p>
<p>（6）第六种格式是 svg 格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站 logo 或者图标之类的图片。</p>
<p>（7）第七种格式是 webp 格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用 webp 格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</p>
<h2 id="浏览器如何判断是否支持-webp-格式图片"><a href="#浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="浏览器如何判断是否支持 webp 格式图片"></a>浏览器如何判断是否支持 webp 格式图片</h2><ul>
<li><p>宽高判断法<br>通过创建<code>image</code>对象，将其<code>src</code>属性设置<code>webp</code>格式的图片，然后在<code>onload</code>事件中获取图片宽高，如果能够获取，则说明浏览器支<code>webp</code> 格式图片。如果不能获取或者触发了<code>onerror</code>函数，那么就说明浏览器不支持<code>webp</code>格式的图片。</p>
</li>
<li><p><code>canvas</code>判断法<br>动态创建一个<code>canvas</code>对象，将<code>canvas</code>的<code>toDataURL</code>设置 <code>webp</code>格式，然后判断返回值中是否含有<code>image/webp</code>字段，如果包含则说明支持<code>WebP02</code>，反之则不支持。</p>
</li>
</ul>
<h2 id="画一个宽度-0-5px-的线"><a href="#画一个宽度-0-5px-的线" class="headerlink" title="画一个宽度 0.5px 的线"></a>画一个宽度 0.5px 的线</h2><ul>
<li><code>transform</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scaleY(0.5);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>linear-gradient</code></p>
</li>
<li><p><code>viewport</code></p>
</li>
</ul>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5&quot;&gt;</code></p>
<ul>
<li><code>border-image</code></li>
</ul>
<h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a><code>transition</code>和<code>animation</code>的区别</h2><p><code>transition</code>关注的是<code>CSS property</code>的变化，<code>property</code>值和时间的关系是一个三次贝塞尔曲线<br><code>animation</code>作用于元素本身而不是样式属性，可以使用关键帧，实现更自由的动画效果。</p>
<h2 id="浏览器兼容性问题"><a href="#浏览器兼容性问题" class="headerlink" title="浏览器兼容性问题"></a>浏览器兼容性问题</h2><ul>
<li>png24 位的图片在 IE6 浏览器上出现背景<br>换成 png8，或者引用一段脚本处理</li>
<li><p>浏览器默认的<code>margin</code>和<code>padding</code>不同<br>加一个全局的<code>*{margin:0;padding:0}</code>来统一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//淘宝的样式初始化代码：</span><br><span class="line"></span><br><span class="line">body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend</span><br><span class="line">,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;</span><br><span class="line">body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\5b8b\4f53;&#125;</span><br><span class="line">h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;</span><br><span class="line">address,cite,dfn,em,var&#123;font-style:normal;&#125;</span><br><span class="line">code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;</span><br><span class="line">small&#123;font-size:12px;&#125;</span><br><span class="line">ul,ol&#123;list-style:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">a:hover&#123;text-decoration:underline;&#125;</span><br><span class="line">sup&#123;vertical-align:text-top;&#125;</span><br><span class="line">sub&#123;vertical-align:text-bottom;&#125;</span><br><span class="line">legend&#123;color:#000;&#125;</span><br><span class="line">fieldset,img&#123;border:0;&#125;</span><br><span class="line">button,input,select,textarea&#123;font-size:100%;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="base64-编码的优缺点"><a href="#base64-编码的优缺点" class="headerlink" title="base64 编码的优缺点"></a>base64 编码的优缺点</h2><p>base64 编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的 url 属性。<br>优点：减少一个 HTTP 请求<br>缺点：</p>
<ol>
<li>编码后的文件会比原文件的 1/3，如果把大图片编码到<code>html/css</code>中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。</li>
<li>base64 不能直接缓存，只能缓存包含 base64 的文件，比如 HTML 或者 CSS，相比于直接缓存图片的效果差很多</li>
<li>兼容性问题，iE8 以前的浏览器不支持。</li>
</ol>
<h2 id="display、position和float的相互关系"><a href="#display、position和float的相互关系" class="headerlink" title="display、position和float的相互关系"></a><code>display</code>、<code>position</code>和<code>float</code>的相互关系</h2><ol>
<li><p>如果<code>display</code>属性为<code>none</code>，则<code>position</code>和<code>float</code>属性的值不影响元素最后的表现。</p>
</li>
<li><p>如果<code>display</code>属性为<code>absolute</code>或<code>fixed</code>，则<code>float</code>属性失效，并且<code>display</code>的值被设置为<code>table</code>或者<code>block</code>，具体转换为需要看初始转换值。</p>
</li>
<li><p>如果<code>display</code>属性不是<code>absolute</code>或<code>fixed</code>，则判断<code>float</code>属性的值是否为<code>none</code>，如果不是，则<code>display</code>的值则按上面的规则转换。注意，如果<code>position</code>的值为<code>relative</code>并且<code>float</code>属性的值存在，则<code>relative</code>相对于浮动后的最终位置定位。</p>
</li>
<li><p>如果<code>float</code>的值为<code>none</code>,则判断元素是否为根元素，如果是根元素则<code>display</code>属性按照上面的规则转换，如果不是，则保持指定的<code>display</code>属性值不变。</p>
</li>
</ol>
<p><code>position:absolute</code>和<code>position:fixed</code>优先级最高，此时<code>float</code>不起作用，<code>display</code>的值也需要调整；其次，元素的<code>float</code>的特性值不是<code>none</code>的时候或者它的根元素的时候，调整<code>display</code>的值，最后，非根元素，并且非浮动元素，并且非绝对定位的元素，<code>display</code>特性值同时设置值。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>angular学习记录</title>
    <url>/2019/12/13/angular%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>angular</p>
<a id="more"></a>
<ol>
<li>新建组件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng generate component heroes</span><br></pre></td></tr></table></figure>
<p>同理还能新建服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng generate serve heroes</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>父传子<br>//父</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;child [data]=&apos;data&apos;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<p>//子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line">export class ChildComponent implements OnInit&#123;</span><br><span class="line">    @OnInit() data;</span><br><span class="line">    @OnInit(values) data;//取别名，不推荐使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建路由文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng generate module app-routing --flat --module=ap</span><br></pre></td></tr></table></figure>
<ul>
<li>–flat 把这个文件放进 src/app 中，而不是单单的目录文件</li>
<li>–module=app 告诉 CLI 把它注册到 AppModule 的 imports 数组中</li>
</ul>
</li>
<li><p>给当前模板 html（没设置跟标签），跟标签绑定类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;  HostBinding &#125; from &quot;@angular/core&quot;;</span><br><span class="line">   @HostBinding(&quot;class&quot;) get themeClass() &#123;</span><br><span class="line">  return &quot;theme-light&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css<br>不能直接使用.theme-light 定义样式，但是可以使用:host-context()判断当前根组件是否具有该类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:host-context(.theme-light) h2 &#123;</span><br><span class="line"> background-color: #eef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="angularjs-构建项目"><a href="#angularjs-构建项目" class="headerlink" title="angularjs 构建项目"></a>angularjs 构建项目</h1><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global yo bower grunt-cli</span><br></pre></td></tr></table></figure>
<h2 id="安装-AngularJS-的生成器"><a href="#安装-AngularJS-的生成器" class="headerlink" title="安装 AngularJS 的生成器"></a>安装 AngularJS 的生成器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g generator-webapp</span><br><span class="line">//或</span><br><span class="line"> npm install --global generator-angular</span><br></pre></td></tr></table></figure>
<p>搭建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//搭建angularjs项目</span><br><span class="line">yo angular</span><br><span class="line">//搭建webapp</span><br><span class="line">yo webapp</span><br></pre></td></tr></table></figure>
<p>我使用 angular<br><img src="/2019/12/13/angular学习记录/img1.jpg" alt="图1"><br>然后选择要安装的模块，我按照默认的来的<br>然后安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">bower install</span><br></pre></td></tr></table></figure>
<p>bower 是个坑，官方文档没提这个，所以直接运行后，浏览器提示<code>angular is not defined</code></p>
<p>然后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt serve</span><br></pre></td></tr></table></figure>
<p>如果选的是 gulp(运行会报错，没找到原因，还是用 grunt)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp serve</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>react-性能优化2</title>
    <url>/2019/12/09/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/</url>
    <content><![CDATA[<p>收集几种 react 性能优化方案，应用到自己的代码中，减少不必要的开销，提高代码运行效率。<br>参考：<br><a href="https://mp.weixin.qq.com/s/kEExKE-Chr40z-mCc6AZ7Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kEExKE-Chr40z-mCc6AZ7Q</a><br><a href="https://www.infoq.cn/article/KVE8xtRs-uPphptq5LUz" target="_blank" rel="noopener">https://www.infoq.cn/article/KVE8xtRs-uPphptq5LUz</a></p>
<a id="more"></a>
<h1 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h1><h2 id="1-减少重新-render-的次数"><a href="#1-减少重新-render-的次数" class="headerlink" title="1. 减少重新 render 的次数"></a>1. 减少重新 render 的次数</h2><p>花时间最长的就是重新渲染</p>
<ul>
<li><code>React.memo</code>组件记忆<br>使用 React.memo，在给定相同的 props 情况下渲染相同的结果，并通过记忆组件渲染结果的方式提高组件的性能表现<br>使用方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Component(props) &#123;&#125;</span><br><span class="line"></span><br><span class="line">const MyComponent = React.memo(Component);</span><br></pre></td></tr></table></figure>
<p>就是使用<code>React.memo</code>包裹一下组件。<br>通过<code>React.memo</code>包裹的组件在 props 不变的情况下不会重新渲染，这跟类组件中的<code>pureComponent</code>效果相似。</p>
<p><strong><code>React.memo高级用法</code></strong><br>默认情况下只会对 props 的复杂对象做浅层对比，只对比前后两次 props 对象的引用地址是否相同，不会比较对象里面的内容是否相同。如果你需要控制对比过程，需要将自定义的比较函数通过第二个参数传入来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Component(props) &#123;&#125;</span><br><span class="line">function areEqual(prevProps, nextProps) &#123;</span><br><span class="line">  /*</span><br><span class="line">  如果把 nextProps 传入 render 方法的返回结果与</span><br><span class="line">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span><br><span class="line">  否则返回 false</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line">const MyComponent = React.memo(Component,areEqual);</span><br></pre></td></tr></table></figure>
<p>与<code>shouldComponentUpdate</code>用法类似，不过返回值正好相反。</p>
<ul>
<li><p><code>useCallback</code><br>子组件调用用父组件的函数，导致子组件重新渲染<br>点击子组件的修改副标题，子组件再次打印 name<br>//子组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Child &#125; from &quot;../../components/child&quot;;</span><br><span class="line">import &quot;./index.less&quot;;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  titleInitial?: string;</span><br><span class="line">  countInitial?: number;</span><br><span class="line">  subTitleInitial?: string;</span><br><span class="line">&#125;</span><br><span class="line">export const App: React.FC&lt;IProps&gt; = (&#123;</span><br><span class="line">  titleInitial = &quot;title&quot;,</span><br><span class="line">  countInitial = 0,</span><br><span class="line">  subTitleInitial = &quot;subTitle&quot;</span><br><span class="line">  &#125;) =&gt; &#123;</span><br><span class="line">  const [title, setTitle] = useState(titleInitial);</span><br><span class="line">  let [count, setCount] = useState(countInitial);</span><br><span class="line">  let [subTitle, setSubTitle] = useState(subTitleInitial);</span><br><span class="line">  const callback = () =&gt; setSubTitle(&quot;new subTitle&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;title：&#123;title&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h1&gt;count：&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h1&gt;subTitle：&#123;subTitle&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setTitle(&quot;title111&quot;)&#125;&gt;改名字&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;改count&lt;/button&gt;</span><br><span class="line">      &lt;Child name=&quot;taotao&quot; count=&#123;count&#125; callback=&#123;callback&#125;&gt;&lt;/Child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>typescript</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; FunctionComponent &#125; from &quot;react&quot;;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">name: string;</span><br><span class="line">count: number;</span><br><span class="line">callback: () =&gt; any;</span><br><span class="line">&#125;</span><br><span class="line">const Index: FunctionComponent&lt;IProps&gt; = (&#123; name, count, callback &#125;): any =&gt; &#123;</span><br><span class="line">console.log(name);</span><br><span class="line">return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; callback()&#125;&gt;修改符标题&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br><span class="line">const areEqual = (prevProps: IProps, nextProps: IProps) =&gt; &#123;</span><br><span class="line">if (prevProps.count === nextProps.count) &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">export const Child = React.memo(Index);</span><br></pre></td></tr></table></figure>
<p>一个组件重新重新渲染，一般三种情况：</p>
<ul>
<li>组件自己的状态改变</li>
<li>父组件重新渲染，props 没有改变，子组件重新渲染</li>
<li><p>父组件重新渲染，props 改变，子组件重新渲染</p>
<p>结合当前情况，子组件没变，第一条不符合，用了<code>React.memo</code>，props 不改变，子组件不会重新渲染，第二条也不对，所以只能是第三条。<br>props 传递<code>name</code>,<code>count</code>,<code>callback</code>，前两个是常量不会改变，那只能是 callback 变了，函数式组件每次重新渲染，都会从头开始执行，那么两次创建的 callback 内存地址肯定发生变化，所以子组件重新渲染。<br><strong>解决方法：</strong><br>在函数没有改变的时候，重新渲染的时候保持两个函数的引用一致。</p>
</li>
</ul>
<p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const callback=(a,b)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const memoizedCallback = useCallback(callback, [a, b])</span><br></pre></td></tr></table></figure>
<p>将父组件修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useCallback &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Child &#125; from &quot;../../components/child&quot;;</span><br><span class="line">import &quot;./index.less&quot;;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  titleInitial?: string;</span><br><span class="line">  countInitial?: number;</span><br><span class="line">  subTitleInitial?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const App: React.FC&lt;IProps&gt; = (&#123;</span><br><span class="line">  titleInitial = &quot;title&quot;,</span><br><span class="line">  countInitial = 0,</span><br><span class="line">  subTitleInitial = &quot;subTitle&quot;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  const [title, setTitle] = useState(titleInitial);</span><br><span class="line">  let [count, setCount] = useState(countInitial);</span><br><span class="line">  let [subTitle, setSubTitle] = useState(subTitleInitial);</span><br><span class="line">  const callback = () =&gt; setSubTitle(&quot;new subTitle&quot;);</span><br><span class="line">  const memoizedCallback = useCallback(callback, []);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;title：&#123;title&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h1&gt;count：&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h1&gt;subTitle：&#123;subTitle&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setTitle(&quot;title111&quot;)&#125;&gt;改名字&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;改count&lt;/button&gt;</span><br><span class="line">      &lt;Child name=&quot;taotao&quot; count=&#123;count&#125; callback=&#123;memoizedCallback&#125;&gt;&lt;/Child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>如果<code>callback</code>传递了参数，当参数变化的时候需要它重新添加一个缓存，可以将参数放在 useCallbac 第二个参数数组里面。</p>
<h2 id="2-减少计算量"><a href="#2-减少计算量" class="headerlink" title="2. 减少计算量"></a>2. 减少计算量</h2><p>主要是减少重复计算，对于函数组件来说，每次 render 都会重新开始在执行函数调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  numInitial: number;</span><br><span class="line">&#125;</span><br><span class="line">const App: React.FC&lt;IProps&gt; = (&#123; numInitial = 0 &#125;) =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(numInitial);</span><br><span class="line">  function expensiveFn(): number &#123;</span><br><span class="line">    let result: number = 0;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      result += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  const base = expensiveFn();</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;count：&#123;num&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setNum(num + base)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>每次点击+1 都会重新渲染组件，执行 expensiveFn 函数，并输出<code>49995000</code>，想办法把计算出来的值缓存起来，每次调用函数返回缓存值就可以了。</p>
<ul>
<li>useMemo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function computeExpensiveValue() &#123;</span><br><span class="line">  // 计算量很大的代码</span><br><span class="line">  return xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const memoizedValue = useMemo(computeExpensiveValue, [a, b]);</span><br></pre></td></tr></table></figure>
<p>useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值。<br>优化后代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IProps &#123;</span><br><span class="line">  numInitial: number;</span><br><span class="line">&#125;</span><br><span class="line">const App: React.FC&lt;IProps&gt; = (&#123; numInitial = 0 &#125;) =&gt; &#123;</span><br><span class="line">  const [num, setNum] = useState(numInitial);</span><br><span class="line">  function expensiveFn(): number &#123;</span><br><span class="line">    let result: number = 0;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">      result += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  const memoizedValue = useMemo(expensiveFn, []);</span><br><span class="line">  const base = memoizedValue;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;count：&#123;num&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setNum(num + base)&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>useMemo 主要用来缓存计算量比较大的函数结果，避免不必要的重复计算。<br><strong>注意</strong></p>
<ul>
<li>如果没有提供第二个数组参数，<code>useMemo</code> 每次渲染都会计算新的值。</li>
<li>计算量如果很小的计算函数，不建议使用<code>useMemo</code>，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。</li>
</ul>
<h1 id="类组优化方法"><a href="#类组优化方法" class="headerlink" title="类组优化方法"></a>类组优化方法</h1><h2 id="使用PureComponent基类"><a href="#使用PureComponent基类" class="headerlink" title="使用PureComponent基类"></a>使用<code>PureComponent</code>基类</h2><p>PureComponent 的 shouldComponentUpdate 对它的状态和 props 进行浅层比较。<br>浅层比较：值类型是否相等（比如 1=1），对象引用地址是否相同。<br>浅层比较的开销比组件视图更新要低。<br><strong>使用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;PureComponent&#125; from &apos;react&apos;;</span><br><span class="line">class PureChildComponent extends PureComponent &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-shouldComponentUpdate-生命周期事件"><a href="#使用-shouldComponentUpdate-生命周期事件" class="headerlink" title="使用 shouldComponentUpdate 生命周期事件"></a>使用 shouldComponentUpdate 生命周期事件</h2><p>自定义渲染逻辑<br>返回<code>true</code>更新，<code>false</code>不更新</p>
<h2 id="避免-componentWillMount-中的异步请求"><a href="#避免-componentWillMount-中的异步请求" class="headerlink" title="避免 componentWillMount()中的异步请求"></a>避免 componentWillMount()中的异步请求</h2><p>由于 API 调用时异步的，因此组件在调用 render 函数之前不会等待 API 返回数据，于是在初始渲染组件时，没有任何数据。<br><strong>注意：React 16.3 不推荐使用 componentWillMount。如果你使用的是最新版本的 React，请避免使用这个生命周期事件。</strong></p>
<h2 id="在-constructor-的早期绑定函数"><a href="#在-constructor-的早期绑定函数" class="headerlink" title="在 constructor 的早期绑定函数"></a>在 constructor 的早期绑定函数</h2><p>使用<code>bind</code>关键字将函数绑定到当前上下文。绑定可以在构造函数中完成，也可以在 DOM 元素上完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Click&quot; onClick=&#123;this.handleButtonClick.bind(this)&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">   this.state = &#123;&#125;</span><br><span class="line">   this.handleButtonClick = this.handleButtonClick.bind(this)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h2><p>添加箭头函数，该函数被添加到对象实例，而不是类的原型属性如果多次复用组件，那么在组件外创建的每个对象都会有这些函数的多个实例。<br>因此箭头函数确实有其缺点。在类组件中实现这些函数的最佳方法是在构造函数中绑定函数。</p>
<h2 id="优化-render-中的条件渲染"><a href="#优化-render-中的条件渲染" class="headerlink" title="优化 render 中的条件渲染"></a>优化 render 中的条件渲染</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  render() &#123;</span><br><span class="line">    if(this.state.name == &quot;Mayank&quot;) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt;</span><br><span class="line">          &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次 render,都会执行 if else 语句，diffing 算法会运行一个检查，比较每个位置的元素类型。这样写会看到 AdminHeaderComponent 不可用，并且需要渲染第一个组件 HeaderComponent。React 将观察元素的位置，它看到位置 1 位置 2 的组件已经更改并将卸载组件。组件 HeaderComponent 和 ContentComponent 将在位置 1 和位置 2 卸载并重新安装。<br>优化方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; this.state.name == &quot;Mayank&quot; &amp;&amp; &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt; &#125;</span><br><span class="line">        &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">        &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这样写，开始 DOM diffing 时，位置 1 的元素从 AdminHeaderComponent 变为 null，但是位置 2 和位置 3 的组件保持不变。这样组件就不会卸载，减少不必要的操作。</p>
<h2 id="不要在-render-方法导出数据"><a href="#不要在-render-方法导出数据" class="headerlink" title="不要在 render 方法导出数据"></a>不要在 render 方法导出数据</h2><p>render 函数应该作为纯函数。不能调用 setState 和执行任何 DOM 操作。</p>
<h2 id="为组件创建错误边界"><a href="#为组件创建错误边界" class="headerlink" title="为组件创建错误边界"></a>为组件创建错误边界</h2><p>错误边界是一个 React 组件，可以捕获子组件的 JS 错误，包含错误记录，并为 UI 组件故障提供回退机制。<br>错误边界基于高阶组件的概念<br>包含以下方法：</p>
<ul>
<li>static getDerivedStateFromError()<br>指定回退机制，并从收到的错误中获取组件的新状态</li>
<li>componentDidCatch()<br>用来将错误信息记录到应用中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      error: null,</span><br><span class="line">      errorInfo: null</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    // Catch errors in any child components and re-renders with an error message</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      error: error,</span><br><span class="line">      errorInfo: errorInfo</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.error) &#123;</span><br><span class="line">      // Fallback UI if an error occurs</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;&#123;&quot;Oh-no! Something went wrong&quot;&#125;&lt;/h2&gt;</span><br><span class="line">          &lt;p className=&quot;red&quot;&gt;</span><br><span class="line">            &#123;this.state.error &amp;&amp; this.state.error.toString()&#125;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">          &lt;div&gt;&#123;&quot;Component Stack Error Details: &quot;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;p className=&quot;red&quot;&gt;&#123;this.state.errorInfo.componentStack&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    // component normally just renders children</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">&lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure>
<h1 id="函数式组件和类组件共有方法"><a href="#函数式组件和类组件共有方法" class="headerlink" title="函数式组件和类组件共有方法"></a>函数式组件和类组件共有方法</h1><h2 id="使用-React-Fragment-避免额外标记"><a href="#使用-React-Fragment-避免额外标记" class="headerlink" title="使用 React Fragment 避免额外标记"></a>使用 React Fragment 避免额外标记</h2><p>每个字组件只能由单个父标签，所以顶部要有一个公共标签，除了充当组件的父标签之外，这个额外的 div 没有其他用途。这是可以使用<code>Fragment</code>代替 div。该代码片段不会像组件引入任何额外标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Index: FunctionComponent&lt;IProps&gt; = (&#123; name, count, callback &#125;): any =&gt; &#123;</span><br><span class="line">  console.log(name);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; callback()&#125;&gt;修改符标题&lt;/button&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h2><p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component, lazy, Suspense &#125; from &quot;react&quot;;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  username: string;</span><br><span class="line">&#125;</span><br><span class="line">interface IState &#123;&#125;</span><br><span class="line">class CallingLazyComponents extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.props.username !== &quot;&quot;) &#123;</span><br><span class="line">      const WelcomeComponent = lazy(() =&gt; import(&quot;./welcomeComponent&quot;));</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">            &lt;WelcomeComponent /&gt;</span><br><span class="line">          &lt;/Suspense&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const GuestComponent = lazy(() =&gt; import(&quot;./guestComponent&quot;));</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">            &lt;GuestComponent /&gt;</span><br><span class="line">          &lt;/Suspense&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Lazy extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;CallingLazyComponents username=&quot;&quot; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Lazy;</span><br></pre></td></tr></table></figure>
<p>上面的代码没有预加载 WelcomeComponent 和 GuestComponent,而是进行条件检查，根据用户名判断加载哪个组件。<br><strong>优点</strong></p>
<ul>
<li>主包体积变小，消耗网络传输时间少，</li>
<li>动态单独加载的包比较小，可迅速加载完成</li>
</ul>
<h2 id="不要使用内联函数定义"><a href="#不要使用内联函数定义" class="headerlink" title="不要使用内联函数定义"></a>不要使用内联函数定义</h2><p>使用内联函数，每次<code>render</code>函数执行都会创建一个新的函数实例，增加了 React 应用的工作量。</p>
<h2 id="避免使用内联样式属性"><a href="#避免使用内联样式属性" class="headerlink" title="避免使用内联样式属性"></a>避免使用内联样式属性</h2><p>使用内联样式属性需要花费更多时间来处理脚本和渲染，因为它必须映射传递给实际 CSS 属性的所有样式规则</p>
<h2 id="列表中使用唯一键"><a href="#列表中使用唯一键" class="headerlink" title="列表中使用唯一键"></a>列表中使用唯一键</h2><p>键可以用来标识已更改，添加或删除项目，键为元素提供稳定的标识，一个键对应列表中的唯一一个元素。<br>index 作为键不会出现标识不一致的情况。<br>以下情况可以使用 index 作为键:</p>
<ul>
<li>列表是静态的，项目不随时间变化</li>
<li>数据结构中没有提供 ID</li>
<li>list 永不重新排序或过滤</li>
<li>不会从顶部或中间添加或删除项目</li>
</ul>
<p>使用 index 作为键，如果在列表中添加项目，会加大错误率并降低应用的性能。因为在表头添加新项目后面所有的列表项的键值都会+1，导致性能下降。<br>总结：</p>
<ul>
<li>Key 不仅影响性能，更重要的作用是标识，随机分配和更改的值不能算作标识</li>
<li>根据建模方式提供合适的键值，如果没有 ID，建议使用 hash 函数生成 ID</li>
<li>数组已经有了内部键，但是插入新元素时，这些键就会变化<br>可以使用全局定义一个<code>var localCounter = 1;</code>来添加稳定且唯一的 key 值。</li>
</ul>
<h2 id="事件节流和防抖"><a href="#事件节流和防抖" class="headerlink" title="事件节流和防抖"></a>事件节流和防抖</h2><p>用来限制指定时间内调用事件处理程序的数量。</p>
<ul>
<li>节流：延迟函数的执行<br>比如页面滚动，不会频繁的触发滚动事件，而是将事件延迟一段时间以便将多个事件堆叠在一起执行。<br>确保函数在特定时间段内至少调用一次。<br>在处理无限滚动并且当用户接近页面底部必须获取数据的时候可以使用节流，否则滚动到底部触发多个事件，触发多次网络调用，从而导致性能问题。</li>
<li>防抖：在调用停止一段时间之前忽略时间处理程序的调用<br>比如用户停止输入 3 秒钟之后触发查询事件</li>
</ul>
<h2 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h2><p>这些 CDN 是可以在你的应用中使用的外部资源，也可以创建私有 CDN 并托管我们的文件和资源。</p>
<ul>
<li>不同的域名，浏览器限制了单个域名的并发连接数量，资源在不同域名下面，提高并发能力。</li>
<li>文件可以已被缓存。很多网站使用这些 CDN，可能你需要的资源已经被缓存在浏览器中了</li>
<li>高容量基础设施。大公司托管，遍布全球，可以向最近的数据中心请求服务，从而减小延迟</li>
</ul>
<h2 id="使用-css-动画代替-JS-动画"><a href="#使用-css-动画代替-JS-动画" class="headerlink" title="使用 css 动画代替 JS 动画"></a>使用 css 动画代替 JS 动画</h2><ul>
<li>如果 CSS 可以实现某些 JS 功能，那就用 CSS。</li>
<li>如果 HTML 可以实现某些 JS 功能，那就用 HTML。<br>原因如下：</li>
<li>破损的 CSS 规则和样式不会导致网页损坏，但是 JS 会</li>
<li>解析 CSS 非常便宜，它是声明性的，我们可以为样式并行创建内存中的表达，可以推迟样式属性的计算，直到元素绘制完成。</li>
<li>动画加载 JavaScript 库的成本相对较高，消耗更多网络带宽和计算时间。</li>
<li>虽然 JavaScript 可以提供比 CSS 更多的优化，但优化过的 JavaScript 代码也可能卡住 UI 并导致 Web 浏览器崩溃。</li>
</ul>
<h2 id="在-web-服务器上启用-gzip-压缩"><a href="#在-web-服务器上启用-gzip-压缩" class="headerlink" title="在 web 服务器上启用 gzip 压缩"></a>在 web 服务器上启用 gzip 压缩</h2><p>压缩是节省网络带宽和加速应用的最简单方法。<br>Gzip 是一种能够快速压缩和解压文件的数据压缩算法。<br>可以压缩几乎所有类型的文件，例如图像、文本、JavaScript 文件、样式文件等。<br>当 Web 服务器收到请求，会提取文件数据并查找 Accept-Encoding 标头以确定如何压缩应用。<br>如果服务器支持 gzip 压缩，资源会被压缩后通过网络发送。每份资源的压缩副本（添加了 Content-Encoding 标头）指定使用 gzip 解压。<br>压缩和解压缩文件属于 CPU 密集型任务，但我们还是建议对网页使用 gzip 压缩。</p>
<h2 id="使用-Web-Workers-处理-CPU-密集任务（还待研究）"><a href="#使用-Web-Workers-处理-CPU-密集任务（还待研究）" class="headerlink" title="使用 Web Workers 处理 CPU 密集任务（还待研究）"></a>使用 Web Workers 处理 CPU 密集任务（还待研究）</h2><p>JS 是单线程应用，但是在渲染网页时需要执行多个任务。处理 UI 交互、处理响应数据、操纵 DOM 元素、启用动画等。<br>Worker 在后台运行，可以在不中断主线程的情况下执行多个脚本和 JS 任务。</p>
<h2 id="React-组件的服务端渲染（还待研究）"><a href="#React-组件的服务端渲染（还待研究）" class="headerlink" title="React 组件的服务端渲染（还待研究）"></a>React 组件的服务端渲染（还待研究）</h2><p>服务端渲染可以减少初始页面加载延迟。<br>服务端渲染是指第一个组件显示的内容是从服务器本身发送的，而不是浏览器级别操作。<br>优点：</p>
<ul>
<li>性能：初始页面内容和数据是从服务器本身加载，不需要添加加载器和下拉列表，而是等待初始页面加载完毕后再加载初始组件。</li>
<li>SEO（搜索引擎优化）：爬虫在应用初始加载时查找页面内容。在客户端渲染时初始 Web 页面不包含所需的组件，这些组件需要等 React 脚本等文件加载完毕后才渲染出来。</li>
</ul>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
  </entry>
  <entry>
    <title>Babel</title>
    <url>/2019/12/06/Babel/</url>
    <content><![CDATA[<p>Babel7 概念和用法<br><a href="https://github.com/YvetteLau/Blog" target="_blank" rel="noopener">https://github.com/YvetteLau/Blog</a></p>
<a id="more"></a>
<p><strong>参考</strong><br><a href="https://mp.weixin.qq.com/s/xTfjMG2graIrfGGqhue_Jg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xTfjMG2graIrfGGqhue_Jg</a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Babel 是一个 JS 编译器。<br>主要将 ECMAScript2015+版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境。</p>
<ul>
<li>语法转换</li>
<li>通过<code>Polyfill</code>方式在目标环境中添加缺失特性（<code>@babel/polyfill</code>模块）</li>
<li>源码转换</li>
</ul>
<h1 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h1><p>@babel/core 使用 babel 必须安装</p>
<h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><p>@babel/cli 适合安装在项目里<br>@babel/node 适合全局安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli</span><br></pre></td></tr></table></figure>
<p>命令配置，package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;compiler&quot;: &quot;babel src --out-dir lib --watch&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>npm run compiler</code>就可以编译了<br>现在运行不会有编译任何文件，如果需要<code>Babel</code>做一些实际工作，就需要为其添加插件(<code>plugin</code>)</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul>
<li><code>babel.config.js</code><br>以编程的方式配置文件或者希望编<code>node_modules</code>目录下的模块<br>根目录下创建<code>babel.config.js</code></li>
</ul>
<p>具体规则参考：<a href="https://babeljs.io/docs/en/config-files#root-babelconfigjs-babelconfigcjs-and-babelconfigjson-files" target="_blank" rel="noopener">文档</a></p>
<ul>
<li><p><code>.babelrc</code><br>简单的并且用于单个软件包的配置<br>根目录下创建<code>.babelrc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>具体规则参考：<a href="https://babeljs.io/docs/en/config-files#root-babelconfigjs-babelconfigcjs-and-babelconfigjson-files" target="_blank" rel="noopener">文档</a></p>
<ul>
<li>package.json<br>可以将<code>.babelrc</code>中的配置信息作为<code>babel</code>key 添加到<code>package.json</code>文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;my-package&quot;,</span><br><span class="line">    &quot;babel&quot;: &#123;</span><br><span class="line">        &quot;presets&quot;: [],</span><br><span class="line">        &quot;plugins&quot;: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.babelrc.js<br>配置与<code>.babelrc</code>相同，但是可以使用 js 编写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//可以在其中调用 Node.js 的API</span><br><span class="line">const presets = [];</span><br><span class="line">const plugins = [];</span><br><span class="line"></span><br><span class="line">module.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li><p>语法插件<br>解析特定类型的语法</p>
</li>
<li><p>转换插件<br>转换插件会启用相应的语法插件，先解析，再转换</p>
</li>
</ul>
<h2 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h2><p>根目录新建<code>.babelrc</code>文件，直接使用插件名字，<code>Babel</code>会自动检查  是否已安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>npm run compiler</code>,<code>index.js</code> 编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a = function () &#123;</span><br><span class="line">  console.log(&apos;test&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>箭头函数转为正常函数了，如果想将其他新的 JS 特性转换成低版本，需要对应的<code>plugin</code>，如果一个一个配置太麻烦，可以使用预设</p>
<h1 id="预设"><a href="#预设" class="headerlink" title="预设"></a>预设</h1><p>创建一个<code>preset</code>，可以使用一组插件</p>
<ul>
<li>@babel/preset-env</li>
<li>@babel/preset-flow</li>
<li>@babel/preset-react</li>
<li>@babel/preset-typescript<br><strong>注意，babel7 开始，所有针对标准天阶段的功能所编写的预设（stage preset）已经被弃用，以及移除<code>@babel/preset-stage-x</code></strong></li>
</ul>
<h2 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h2><p>作用：对我们所使用的并且目标浏览器缺失的功能进行代码转换和加载<code>polyfill</code>。不进行任何配置时，<code>@babel/preset-env</code>所包含的插件将支持所有最新的 JS 特性（ES2015/es6,ES2016/es7 等，不包括 stage 阶段），将其转换成 ES5 代码。如果使用了 stage 阶段的语法，编译时会报错，需要安装对应的插件。<br><code>@babel/preset-env</code>会很具配置的目标环境，来生成插件列表来编译，对于基于浏览的项目，可以使用<code>.browserslistrc</code>文件来指定目标环境。也可以在 package.json 里面添加 key 为<code>browserslist</code>配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//create-react-app默认配置</span><br><span class="line">&quot;browserslist&quot;: &#123;</span><br><span class="line">    &quot;production&quot;: [</span><br><span class="line">      &quot;&gt;0.2%&quot;, //包括浏览器市场份额超过0.2％的用户所需的 polyfill 和代码转换</span><br><span class="line">      &quot;not dead&quot;,</span><br><span class="line">      &quot;not op_mini all&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;development&quot;: [</span><br><span class="line">      &quot;last 1 chrome version&quot;,</span><br><span class="line">      &quot;last 1 firefox version&quot;,</span><br><span class="line">      &quot;last 1 safari version&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>新建<code>.browserslistrc</code>，配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">last 2 Chrome versions</span><br></pre></td></tr></table></figure>
<p>index 编译后箭头函数还在，因为 chrome 最新的两个版本已经支持箭头函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">const a = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;test&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>如果不是要兼容所有的浏览器和环境，推荐你指定目标环境，编译代码能够保持最小。</em></p>
<h2 id="内置函数、实例方法"><a href="#内置函数、实例方法" class="headerlink" title="内置函数、实例方法"></a>内置函数、实例方法</h2><p>修改<code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>语法转换只是将高版本的语法转换为低版本的，但是新的内置函数和实例方法无法转换。<br><code>polyfill</code>垫平不同浏览器或者不同环境下的差异，让新的内置函数、实例方法等在低版本浏览器中也可以使用。</p>
<h1 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h1><p>包括<code>core-js</code>和一个自定义的<code>regenerator runtime</code>模块，可以模拟完整的 es2015+环境（不包括第 4 阶段前的提议）</p>
<p>内置组件：<code>Promise</code>,<code>WeakMap</code>等<br>静态方法：<code>Array.from</code>,<code>Object.assign</code>等<br>实例方法：<code>Array.prototype.includes</code>等<br>生成器函数（还需要<code>@babel/plugin-transform-regenerator</code>插件）<br>为了实现以上功能，polyfill 将添加到全局范围和类似 String 的内置原型中（会造成全局污染）</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure>
<p><strong>注意：不使用 –save-dev，因为这是一个需要在源码之前运行的垫片。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;;</span><br><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;@babel/polyfill&quot;);</span><br><span class="line"></span><br><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>@babel/polyfill</code>需要在其他代码之前引入，在<code>webpack</code>中可以进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    require.resolve(&apos;./polyfills&apos;),</span><br><span class="line">    path.resolve(&apos;./index&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.polyfills.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当然，还可能有一些其它的 polyfill，例如 stage 4之前的一些 polyfill</span><br><span class="line">import &apos;@babel/polyfill&apos;;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;@babel/polyfill&quot;);</span><br><span class="line"></span><br><span class="line">var isHas = [1, 2, 3].includes(2);</span><br><span class="line">var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在的代码在高版本或低版本或 node 环境都能运行了。但是会引入整个<code>@babel/polyfill</code>包，会导致打包的体积增大，我们期望按需加载。</p>
<ul>
<li>参数<code>useBuiltIns</code>参数，设置值为<code>usage</code>时，就只会包含代码需要的<code>polyfill</code></li>
<li>必须同时设置<code>core.js</code>，默认’core.js’:2<br>注意：需要安装<code>@babel/polyfill</code>，默认安装 corejs@2<br>使用 core-js@3 的原因 core-js@2 分支已经不会添加新特性，新特性都会添加到 core-js@3。例如 Array.prototype.flat()<br>安装依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save core-js@3</span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">        &quot;corejs&quot;: 3</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.array.includes&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.object.to-string&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.promise&quot;);</span><br><span class="line"></span><br><span class="line">var isHas = [1, 2, 3].includes(2);</span><br><span class="line">var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 useBuiltIns 参数值为 usage 时，仍然需要安装 @babel/polyfill，<br>如果使用到了 async/await，那么编译出来的代码需要 require(“regenerator-runtime/runtime”)，在 @babel/polyfill 的依赖中。也可以只安装 regenerator-runtime/runtime 取代安装 @babel/polyfill。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;;</span><br><span class="line"></span><br><span class="line">async function a() &#123;</span><br><span class="line">  await console.log(1);</span><br><span class="line">  console.log(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.object.to-string&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.promise&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;regenerator-runtime/runtime&quot;);</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  return regeneratorRuntime.async(function a$(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch (_context.prev = _context.next) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          _context.next = 2;</span><br><span class="line">          return regeneratorRuntime.awrap(console.log(1));</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">          console.log(0);</span><br><span class="line"></span><br><span class="line">        case 3:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title="@"></a>@</h2><p>Babel 会使用很小的辅助函数来实现类似 _createClass 等公共方法。默认情况下，它将被添加(inject)到需要它的每个文件中。<br>修改 index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  getX() &#123;</span><br><span class="line">    return this.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp = new Point(25, 6);</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.object.define-property&quot;);</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</span><br><span class="line"></span><br><span class="line">function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;</span><br><span class="line"></span><br><span class="line">function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;</span><br><span class="line"></span><br><span class="line">var Point =</span><br><span class="line">/*#__PURE__*/</span><br><span class="line">function () &#123;</span><br><span class="line">  function Point(x, y) &#123;</span><br><span class="line">    _classCallCheck(this, Point);</span><br><span class="line"></span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Point, [&#123;</span><br><span class="line">    key: &quot;getX&quot;,</span><br><span class="line">    value: function getX() &#123;</span><br><span class="line">      return this.x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  return Point;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var cp = new Point(25, 6);</span><br></pre></td></tr></table></figure>
<p>如果多个文件使用了 class，<code>_classCallCheck</code>,<code>_defineProperties</code>,<code>_createClass</code>，这些方法就会被多次<code>inject</code>，导致包变大。</p>
<h1 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h1><p>一个可以重复使用<code>Babel</code>注入的帮助程序，以节省代码大小的插件。<br><code>@babel/plugin-transform-runtime</code>需要配合<code>@babel/runtime</code>使用。<br>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure>
<p>除了减少编译后代码的体积外，<code>@babel/plugin-tranform-runtime</code>还会创建一个沙盒环境，如果使用<code>@babel/polyfill</code>及其提供的内置程序会污染全局，虽然这对于应用程序或命令行工具可能是可以的，但是如果你的代码是要发布供他人使用的库，或者无法完全控制代码运行的环境，则将成为一个问题。</p>
<p><code>@babel/plugin-transform-runtime</code>会将这些内置别名为<code>core-js</code>的别名，因此可以无缝使用它们，无需<code>polyfill</code>。<br>修改配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">        &quot;corejs&quot;: 3</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译 index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _interopRequireDefault = require(&quot;@babel/runtime/helpers/interopRequireDefault&quot;);</span><br><span class="line"></span><br><span class="line">var _classCallCheck2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/classCallCheck&quot;));</span><br><span class="line"></span><br><span class="line">var _createClass2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/createClass&quot;));</span><br><span class="line"></span><br><span class="line">var Point =</span><br><span class="line">/*#__PURE__*/</span><br><span class="line">function () &#123;</span><br><span class="line">  function Point(x, y) &#123;</span><br><span class="line">    (0, _classCallCheck2.default)(this, Point);</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (0, _createClass2.default)(Point, [&#123;</span><br><span class="line">    key: &quot;getX&quot;,</span><br><span class="line">    value: function getX() &#123;</span><br><span class="line">      return this.x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line">  return Point;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">var cp = new Point(25, 6);</span><br></pre></td></tr></table></figure>
<p>帮助函数不是被直接<code>inject</code>到代码中，而是从<code>@babel/runtime</code>中引入。</p>
<h2 id="如何避免全局污染"><a href="#如何避免全局污染" class="headerlink" title="如何避免全局污染"></a>如何避免全局污染</h2><p>index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;@babel/polyfill&quot;;</span><br><span class="line"></span><br><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.array.includes&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.object.to-string&quot;);</span><br><span class="line"></span><br><span class="line">require(&quot;core-js/modules/es.promise&quot;);</span><br><span class="line"></span><br><span class="line">var isHas = [1, 2, 3].includes(2);</span><br><span class="line">var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在的配置，Array.prototype 上新增了 includes 方法，并且新增了全局的 Promise 方法，污染了全局环境。<br>如果希望<code>@babel/plugin-transform-runtime</code>不仅处理帮助函数，同时也能加载<code>polyfill</code>，需要增加配置信息。<br>新增依赖<code>@babel/runtimr-corejs3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel/runtime-corejs3 --save</span><br></pre></td></tr></table></figure>
<p>需要改配置文件，移除@babe/preset-env 的 useBuitIns 的配置，不然就重复了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</span><br><span class="line">        &quot;corejs&quot;: 3</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;corejs&quot;: 3 &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isHas = [1, 2, 3].includes(2);</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);</span><br><span class="line"></span><br><span class="line">var _promise = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/promise&quot;));</span><br><span class="line"></span><br><span class="line">var _includes = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/includes&quot;));</span><br><span class="line"></span><br><span class="line">var _context;</span><br><span class="line"></span><br><span class="line">var isHas = (0, _includes.default)(_context = [1, 2, 3]).call(_context, 2);</span><br><span class="line">var p = new _promise.default(function (resolve, reject) &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>没有直接去修改 Array.prototype，或者是新增 Promise 方法，避免了全局污染。如果上面 @babel/plugin-transform-runtime 配置的 core-js 是 “2”，其中不包含实例的 polyfill 需要单独引入。</p>
<h1 id="插件-预设补充知识"><a href="#插件-预设补充知识" class="headerlink" title="插件/预设补充知识"></a>插件/预设补充知识</h1><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul>
<li>插件在预设前运行</li>
<li>插件从前往后调用</li>
<li>预设从后往前调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]</span><br><span class="line">    &quot;plugins&quot;: [&quot;@babel/plugin-proposal-class-properties&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先执行 @babel/plugin-proposal-class-properties，后执行 @babel/plugin-syntax-dynamic-import<br>先执行 @babel/preset-react， 后执行 @babel/preset-env。</p>
<h2 id="参数结构"><a href="#参数结构" class="headerlink" title="参数结构"></a>参数结构</h2><p>插件和预设都可以接受参数，参数由插件名和参数对象组成一个数组。</p>
<h2 id="插件短名称"><a href="#插件短名称" class="headerlink" title="插件短名称"></a>插件短名称</h2><p>如果插件名称为 @babel/plugin-XXX，可以使用短名称@babel/XXX<br>如果插件名称为 babel-plugin-XXX，可以使用端名称 XXX，该规则同样适用于带有 scope 的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;newPlugin&quot;, //同 &quot;babel-plugin-newPlugin&quot;</span><br><span class="line">        &quot;@scp/myPlugin&quot; //同 &quot;@scp/babel-plugin-myPlugin&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="stage1-2-3-阶段的编译插件"><a href="#stage1-2-3-阶段的编译插件" class="headerlink" title="stage1,2,3 阶段的编译插件"></a>stage1,2,3 阶段的编译插件</h1><p>解决方法：<a href="https://segmentfault.com/a/1190000020237923" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020237923</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">    // Stage 0</span><br><span class="line">    &quot;@babel/plugin-proposal-function-bind&quot;,</span><br><span class="line"></span><br><span class="line">    // Stage 1</span><br><span class="line">    &quot;@babel/plugin-proposal-export-default-from&quot;,</span><br><span class="line">    &quot;@babel/plugin-proposal-logical-assignment-operators&quot;,</span><br><span class="line">    [&quot;@babel/plugin-proposal-optional-chaining&quot;, &#123; &quot;loose&quot;: false &#125;],</span><br><span class="line">    [&quot;@babel/plugin-proposal-pipeline-operator&quot;, &#123; &quot;proposal&quot;: &quot;minimal&quot; &#125;],</span><br><span class="line">    [&quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;, &#123; &quot;loose&quot;: false &#125;],</span><br><span class="line">    &quot;@babel/plugin-proposal-do-expressions&quot;,</span><br><span class="line"></span><br><span class="line">    // Stage 2</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],</span><br><span class="line">    &quot;@babel/plugin-proposal-function-sent&quot;,</span><br><span class="line">    &quot;@babel/plugin-proposal-export-namespace-from&quot;,</span><br><span class="line">    &quot;@babel/plugin-proposal-numeric-separator&quot;,</span><br><span class="line">    &quot;@babel/plugin-proposal-throw-expressions&quot;,</span><br><span class="line"></span><br><span class="line">    // Stage 3</span><br><span class="line">    &quot;@babel/plugin-syntax-dynamic-import&quot;,</span><br><span class="line">    &quot;@babel/plugin-syntax-import-meta&quot;,</span><br><span class="line">    [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot;: false &#125;],</span><br><span class="line">    &quot;@babel/plugin-proposal-json-strings&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>TypeScript+React</title>
    <url>/2019/12/04/TypeScript-React/</url>
    <content><![CDATA[<p>搭建 react+webpack+typescript</p>
<a id="more"></a>
<p>参考：<a href="https://typescript.bootcss.com/tutorials/react-&amp;-webpack.html" target="_blank" rel="noopener">https://typescript.bootcss.com/tutorials/react-&amp;-webpack.html</a></p>
<h1 id="使用-react-webpack-ts-搭建项目"><a href="#使用-react-webpack-ts-搭建项目" class="headerlink" title="使用 react+webpack+ts 搭建项目"></a>使用 react+webpack+ts 搭建项目</h1><ol>
<li>新建项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir react-webpack-ts</span><br><span class="line">cd react-webpack-ts</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>工程目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-webpack-ts/</span><br><span class="line">├─ dist/</span><br><span class="line">└─ src/</span><br><span class="line">   └─ components/</span><br><span class="line">   └─ index.tsx</span><br><span class="line">   └─ index.html</span><br></pre></td></tr></table></figure>
<p><code>dist</code>目录打包时自动生成</p>
<ol start="2">
<li>安装依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save react react-dom @types/react @types/react-dom</span><br><span class="line">npm install --save-dev typescript awesome-typescript-loader source-map-loader</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>添加 ts 配置文件</li>
</ol>
<p>根目录新建 tsconfig.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;./dist/&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;noImplicitAny&quot;: true,</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;jsx&quot;: &quot;react&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;./src/**/*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>代码</li>
</ol>
<ul>
<li>src/components/Hello.tsx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export interface HelloProps &#123; compiler: string; framework: string; &#125;</span><br><span class="line"></span><br><span class="line">export const Hello = (props: HelloProps) =&gt; &lt;h1&gt;Hello from &#123;props.compiler&#125; and &#123;props.framework&#125;!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>src/index.tsx</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import * as ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">import &#123; Hello &#125; from &quot;./components/Hello&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Hello compiler=&quot;TypeScript&quot; framework=&quot;React&quot; /&gt;,</span><br><span class="line">    document.getElementById(&quot;example&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>src/index.html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">        &lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Dependencies(打包时排除了这些固定依赖文件，所有需要手动引入) --&gt;</span><br><span class="line">        &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Main --&gt;</span><br><span class="line">        &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>配置 webpack<br>根目录新建 webpack.config.json</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &quot;./src/index.tsx&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;bundle.js&quot;,</span><br><span class="line">        path: __dirname + &quot;/dist&quot;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // Enable sourcemaps for debugging webpack&apos;s output.</span><br><span class="line">    devtool: &quot;source-map&quot;,</span><br><span class="line"></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        // Add &apos;.ts&apos; and &apos;.tsx&apos; as resolvable extensions.</span><br><span class="line">        extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.json&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            // All files with a &apos;.ts&apos; or &apos;.tsx&apos; extension will be handled by &apos;awesome-typescript-loader&apos;.</span><br><span class="line">            &#123; test: /\.tsx?$/, loader: &quot;awesome-typescript-loader&quot; &#125;,</span><br><span class="line"></span><br><span class="line">            // All output &apos;.js&apos; files will have any sourcemaps re-processed by &apos;source-map-loader&apos;.</span><br><span class="line">            &#123; enforce: &quot;pre&quot;, test: /\.js$/, loader: &quot;source-map-loader&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // When importing a module whose path matches one of the following, just</span><br><span class="line">    // assume a corresponding global variable exists and use that instead.</span><br><span class="line">    // This is important because it allows us to avoid bundling all of our</span><br><span class="line">    // dependencies, which allows browsers to cache those libraries between builds.</span><br><span class="line">    externals: &#123; //不打包</span><br><span class="line">        &quot;react&quot;: &quot;React&quot;,</span><br><span class="line">        &quot;react-dom&quot;: &quot;ReactDOM&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>打包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<h1 id="使用-create-react-app-新建-ts-项目"><a href="#使用-create-react-app-新建-ts-项目" class="headerlink" title="使用 create-react-app 新建 ts 项目"></a>使用 create-react-app 新建 ts 项目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-ts --typescript</span><br><span class="line"># or</span><br><span class="line">yarn create react-app react-ts  --typescript</span><br></pre></td></tr></table></figure>
<p><strong>兼容 ie11</strong></p>
<ol>
<li><p>package.json<br>“browserslist”: {<br>“production”: [<br>“&gt;0.2%”,<br>“not dead”,<br>“not op_mini all”<br>],<br>“development”: [<br>“ie 11”,<br>“last 1 chrome version”,<br>“last 1 firefox version”,<br>“last 1 safari version”<br>]<br>}</p>
</li>
<li><p>删除 node_modules 里面的 .cache i</p>
</li>
<li>重新运行项目<br>如果系统解析其他 ES6 等模块在 src/index.js 第一行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;react-app-polyfill/ie11&quot;;</span><br><span class="line">import &quot;react-app-polyfill/stable&quot;;</span><br></pre></td></tr></table></figure>
<p>暴露脚手架配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn eject</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果之前全局安装过 create-react-app(<code>sudo npm install -g create-react-app</code>)，请使用<code>sudo npm uninstall -g create-react-app</code>卸载，以确保使用最新版的脚手架</strong><br>项目会自动安装 ts 和 node、react、react-dom、jest 的声明文件依赖</p>
<h2 id="与原来的-react-项目的不同"><a href="#与原来的-react-项目的不同" class="headerlink" title="与原来的 react 项目的不同"></a>与原来的 react 项目的不同</h2><ol>
<li>文件扩展名：<code>.js</code>变成<code>.ts</code>、<code>.jsx</code>变成了<code>.tsx</code>。</li>
<li>.ts 是普通 ts 文件，.d.ts 是声明文件</li>
<li>全局变量或者自定义的 window 对象属性，统一在项目根目录的 global.d.ts 中进行定义声明</li>
<li>对于项目中常用到的接口数据对象，在 types/目录下定义好其结构化类型声明</li>
<li>根目录的 tsconfig.json 可以配置 TypeScript 的编译选项<br>jsx 工作模式匹配</li>
</ol>
<ul>
<li>preserve:生成代码保留 JSX，输出文件是.jsx</li>
<li>react:直接编译成<code>React.createElement</code></li>
<li>react-native:相当于 preserve，它也保留了所有的 JSX，但是输出文件的扩展名是.js</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>输入</th>
<th>输出</th>
<th>输出文件扩展名</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>preserve</code></td>
<td><code>&lt;div/&gt;</code></td>
<td><code>&lt;div/&gt;</code></td>
<td><code>.jsx</code></td>
</tr>
<tr>
<td><code>react</code></td>
<td><code>&lt;div/&gt;</code></td>
<td><code>React.createElement(&#39;div&#39;)</code></td>
<td><code>.js</code></td>
</tr>
<tr>
<td><code>react-native</code></td>
<td><code>&lt;div/&gt;</code></td>
<td><code>&lt;div/&gt;</code></td>
<td><code>.js</code></td>
</tr>
</tbody>
</table>
<ol start="6">
<li>@types/xxx<br>是<code>xxx</code>依赖的声明文件，统一放在<code>node_modules/@types</code>文件夹下，TypeScript 会自动从这里获取模块内相关类型定义<br><a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">搜索依赖对应文件声明库</a></li>
<li><p>as 运算符<br>类型断言。默认是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo1=&lt;foo&gt;bar</span><br></pre></td></tr></table></figure>
<p>与 jsx 语法冲突，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo1=bar as foo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="各种类型的定义"><a href="#各种类型的定义" class="headerlink" title="各种类型的定义"></a>各种类型的定义</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>泛型参数定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface IState &#123;</span><br><span class="line">  color: &quot;red&quot; | &quot;blue&quot;;</span><br><span class="line">&#125;</span><br><span class="line">class AddTodo extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      color: &quot;red&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数组件定义"><a href="#函数组件定义" class="headerlink" title="函数组件定义"></a>函数组件定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Props &#123;</span><br><span class="line">  tasks: Task[];</span><br><span class="line">  onDelete: (task: Task) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">export const TaskListItem: FunctionComponent&lt;Props&gt; = (&#123; task, onDelete &#125;) =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br><span class="line">export const TaskListItem: React.RF&lt;Props&gt; = (&#123; task, onDelete &#125;) =&gt; &#123;</span><br><span class="line">  return ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="input-事件"><a href="#input-事件" class="headerlink" title="input 事件"></a>input 事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private handleTaskChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private handleClick = (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.im/post/5bed5f03e51d453c9515e69b" target="_blank" rel="noopener">https://juejin.im/post/5bed5f03e51d453c9515e69b</a></p>
<h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter: FunctionComponent&lt;&#123; initial?: number &#125;&gt; = (&#123; initial = 0 &#125;) =&gt; &#123;</span><br><span class="line">  const [clicks, setClicks] = useState(initial);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Clicks:&#123;clicks&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setClicks(clicks + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setClicks(clicks - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MyArrayComponent = () =&gt;</span><br><span class="line">  (Array(5).fill(&lt;div&gt;11&lt;/div&gt;) as any) as JSX.Element;</span><br><span class="line">const el2 = &lt;MyArrayComponent /&gt;; // throws an error</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/piotrwitek/react-redux-typescript-guide#reactfcprops--reactfunctioncomponentprops" target="_blank" rel="noopener">https://github.com/piotrwitek/react-redux-typescript-guide#reactfcprops--reactfunctioncomponentprops</a><br><a href="https://github.com/typescript-cheatsheets/react-typescript-cheatsheet" target="_blank" rel="noopener">https://github.com/typescript-cheatsheets/react-typescript-cheatsheet</a></p>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript进阶</title>
    <url>/2019/11/29/TypeScript%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>进阶<br>参考：<a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></p>
<a id="more"></a>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>给一个类型起一个新名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">  if (typeof n === &quot;string&quot;) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return n();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 type 创建类型别名<br>类型别名常用于联合类型</p>
<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type TouchEvent=React.TouchEvent&amp;React.MouseEvent</span><br></pre></td></tr></table></figure>
<p>将多种类型合并为一种类型，新的类型能访问到多个类型的<code>所有属性</code>。</p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Source=10|20|30;</span><br><span class="line">let a:Source=10;</span><br></pre></td></tr></table></figure>
<p>a 的值只能是 10，20，30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const attr:number|string=20;</span><br><span class="line">if(typeof attr === &apos;number&apos;)&#123;</span><br><span class="line">    //attr可以使用number的所有方法</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //attr可以使用string的所有方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将多种类型合并为一种类型，新的类型能访问到多个类型的<code>共有属性</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Bird&#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line">interface Fish&#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line">function getSmallPet():Fish|Bird&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let pet=getSmallPet()</span><br><span class="line">pet.layEggs();</span><br><span class="line">pet.fly();//报错</span><br></pre></td></tr></table></figure>
<p>联合类型的类型保护<br>自定义类型保护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let pet=getSmallPet()</span><br><span class="line">pet.layEggs();</span><br><span class="line">if(isFish(pet))&#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br><span class="line">function isFish(pet:Fish|Bird):pet is Fish&#123;</span><br><span class="line">  return (pet as Fish).swim!==undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typeof 类型保护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isNumber(x: any): x is number &#123;</span><br><span class="line">  return typeof x === &quot;string&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instanceof 类型保护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isFish(pet:Fish|Bird):pet is Fish&#123;</span><br><span class="line">  return pet instanceof Fish</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不为 null 的类型断言<code>!</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name!.indexOf(&apos;a&apos;)</span><br></pre></td></tr></table></figure>
<p>自定义属性类型保护</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Square &#123;</span><br><span class="line">  kind: &quot;square&quot;;</span><br><span class="line">  size: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Rectangle &#123;</span><br><span class="line">  kind: &quot;rectangle&quot;;</span><br><span class="line">  width: number;</span><br><span class="line">  height: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">  kind: &quot;circle&quot;;</span><br><span class="line">  r: number;</span><br><span class="line">&#125;</span><br><span class="line">type Shape = Square | Rectangle | Circle;</span><br><span class="line">function area(s: Shape) &#123;</span><br><span class="line">  switch (s.kind) &#123;</span><br><span class="line">    case &quot;square&quot;:</span><br><span class="line">      return s.size * s.size;</span><br><span class="line">    case &quot;rectangle&quot;:</span><br><span class="line">      return s.width * s.height;</span><br><span class="line">    case &quot;circle&quot;:</span><br><span class="line">      return Math.PI * s.r ** 2;</span><br><span class="line">    default:</span><br><span class="line">      return ((e: never) =&gt; &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">      &#125;)(s); //判断s是否为never类型，如果是，说明s不存在Shape中，否则说明上面的case有遗漏</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(area(&#123; kind: &quot;circle&quot;, r: 10 &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p><code>keyof T</code>，返回 T 中所有属性的联合类型<br><code>T[k]</code>，返回 T 中 K 元素的类型<br><code>T extends U</code>,T 继承至 U</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &apos;2&apos;,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]):T[K][] &#123;</span><br><span class="line">    return keys.map(key=&gt;obj[key])</span><br><span class="line">&#125;</span><br><span class="line">console.log(getValues(obj, [&apos;a&apos;, &apos;b&apos;]))</span><br></pre></td></tr></table></figure>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Obj&#123;</span><br><span class="line">    a: string,</span><br><span class="line">    b: string,</span><br><span class="line">    c: number</span><br><span class="line">&#125;</span><br><span class="line">type ReadonlyObj = Readonly&lt;Obj&gt;//只读</span><br><span class="line">type PartialObj = Partial&lt;Obj&gt;//可选</span><br><span class="line">type PickObj=Pick&lt;Obj,&apos;a&apos;|&apos;c&apos;&gt;//抽取部分属性</span><br><span class="line">type RecordObj = Record&lt;&apos;x&apos; | &apos;y&apos;, Obj&gt;//创建新类型，参数类型为Obj</span><br></pre></td></tr></table></figure>
<h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type TypeName &lt; T &gt;=</span><br><span class="line">    T extends string ? &apos;string&apos; :</span><br><span class="line">    T extends number ? &apos;number&apos; :</span><br><span class="line">    T extends boolean ? &apos;boolean&apos; :</span><br><span class="line">    T extends undefined ? &apos;undefined&apos; :</span><br><span class="line">    T extends Function ? &apos;function&apos; :</span><br><span class="line">    &quot;object&quot;</span><br><span class="line"></span><br><span class="line">type T1 = TypeName&lt;string&gt;</span><br><span class="line">type T2 = TypeName&lt;string[]&gt;</span><br><span class="line">//(A|B) extends U?x:y</span><br><span class="line">//A extends U ? x : y | B extends U ? x : y</span><br><span class="line">type T3 = TypeName&lt;string | string[]&gt;</span><br><span class="line"></span><br><span class="line">type Diff&lt;T, U&gt; = T extends U ? never : T</span><br><span class="line">type T4 =  Diff&lt;&apos;a&apos; | &apos;b&apos; | &apos;c&apos;, &apos;a&apos; | &apos;e&apos;&gt;</span><br><span class="line">//Diff&lt;&apos;a&apos;,&apos;a&apos;|&apos;e&apos;&gt; | Diff&lt;&apos;b&apos;,&apos;a&apos;|&apos;e&apos;&gt;| Diff&lt;&apos;c&apos;,&apos;a&apos;|&apos;e&apos;&gt;</span><br><span class="line">// &apos;never&apos;|&apos;b&apos;|&apos;c&apos;</span><br><span class="line">//&apos;b&apos;|&apos;c&apos;</span><br><span class="line"></span><br><span class="line">type NotNull&lt;T&gt; = Diff&lt;T, undefined | null&gt;</span><br><span class="line">type TS = NotNull&lt;string | number | undefined | null&gt;</span><br></pre></td></tr></table></figure>
<p>内置条件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exclude&lt;T,U&gt;//同上diff</span><br><span class="line">NotNullable&lt;T&gt;//同上NotNull</span><br><span class="line">Extract&lt;T,U&gt;//与Exclude相反，返回T中继承至U的类型</span><br><span class="line">ReturnType&lt;fun&gt;//返回函数返回值类型</span><br></pre></td></tr></table></figure>
<h1 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h1><p>用来约束取值只能是某几个字符串中的一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type EventNames = &quot;click&quot; | &quot;scroll&quot; | &quot;mousemove&quot;;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123;&#125;</span><br><span class="line">handleEvent(document.getElementById(&quot;hello&quot;), &quot;scroll&quot;);</span><br><span class="line">handleEvent(document.getElementById(&quot;world&quot;), &quot;dbclick&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>注意，类型别名与字符串字面量类型都是使用<code>type</code>进行定义</strong></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>数组合并了相同类型的对象，元组（Tuple）合并了不同类型的对象。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jerry: [string, number] = [&quot;jerry&quot;, 25];</span><br></pre></td></tr></table></figure>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jerry: [string, number];</span><br><span class="line">jerry=[&apos;jerry&apos;,22]</span><br></pre></td></tr></table></figure>
<p>直接对元组赋值，需要提供所有元组类型中指定的项。</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jerry[0].slice(1);</span><br><span class="line">jerry[1].slice(2);//报错</span><br></pre></td></tr></table></figure>
<h2 id="越界元素"><a href="#越界元素" class="headerlink" title="越界元素"></a>越界元素</h2><p>当添加越界的元素时，它的类型被限制为元组中每个类型的联合类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let jerry: [string, number];</span><br><span class="line">jerry = [&quot;jerry&quot;, 22];</span><br><span class="line">jerry.push(&quot;female&quot;);//成功</span><br><span class="line">jerry.push(true);// error TS2345: Argument of type &apos;true&apos; is not assignable to parameter of type &apos;string | number&apos;.</span><br></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>Enum<br>定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Days &#123;</span><br><span class="line">  sun,</span><br><span class="line">  Mon,</span><br><span class="line">  Tue,</span><br><span class="line">  Web,</span><br><span class="line">  Thu,</span><br><span class="line">  Fri,</span><br><span class="line">  Sat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射。<br>编译结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Web&quot;] = 3] = &quot;Web&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Days[&quot;Sun&quot;] === 0); //true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); //true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); //true</span><br><span class="line">console.log(Days[&quot;Web&quot;] === 3); //true</span><br><span class="line"></span><br><span class="line">console.log(Days[4] === &quot;Thu&quot;); //true</span><br><span class="line">console.log(Days[5] === &quot;Fri&quot;); //false</span><br><span class="line">console.log(Days[6] === &quot;Sat&quot;); //true</span><br></pre></td></tr></table></figure>
<p>手动赋值枚举项，可以不是数字，但是需要使用让 tsc 无视类型检查，但是后面的枚举项也需要手动赋值，否则无法获取初始值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Days &#123;</span><br><span class="line">  Sun = 7,</span><br><span class="line">  Mon,</span><br><span class="line">  Tue,</span><br><span class="line">  Web,</span><br><span class="line">  Thu,</span><br><span class="line">  Fri,</span><br><span class="line">  Sat = &lt;any&gt;&quot;s&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); //true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 8); //true</span><br><span class="line"></span><br><span class="line">console.log(Days[11] === &quot;Thu&quot;); //true</span><br><span class="line">console.log(Days[12] === &quot;Fri&quot;); //true</span><br><span class="line">console.log(Days[&quot;s&quot;] === &quot;Sat&quot;); //true</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 8] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 9] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Web&quot;] = 10] = &quot;Web&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 11] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 12] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = &quot;s&quot;] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure>
<p>手动赋值的枚举项也可以是小数或负数，后面项的递增步长是 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Days &#123;</span><br><span class="line">  Sun = 7,</span><br><span class="line">  Mon = 1.5,</span><br><span class="line">  Tue,</span><br><span class="line">  Web,</span><br><span class="line">  Thu,</span><br><span class="line">  Fri,</span><br><span class="line">  Sat = &lt;any&gt;&quot;s&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); //true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1.5); //true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2.5); //true</span><br><span class="line">console.log(Days[&quot;Web&quot;] === 3.5); //true</span><br></pre></td></tr></table></figure>
<h2 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h2><p>前面的例子都是常数项<br>计算所得项例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue = &quot;blue&quot;.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子不会报错，但是如果后面还有未手动赋值的项，就会因无法获得初始值而报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  Red = &quot;red&quot;.length,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line">//error TS1061: Enum member must have initializer.</span><br><span class="line"></span><br><span class="line">//236   Green,</span><br><span class="line">//error TS1061: Enum member must have initializer.</span><br><span class="line"></span><br><span class="line">//237   Blue</span><br></pre></td></tr></table></figure>
<p>当满足以下条件时，枚举成员被当作常数：</p>
<ul>
<li>不具有初始化函数并且之前的枚举成员是常数，后面的枚举成员就是前面的值+1，第一个枚举成员默认初始值为 0；</li>
<li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，可以在编译阶段求值，当一个表达式满足下面条件之一时，就是一个常数枚举表达式：<ul>
<li>数字字面量</li>
<li>引用之前定义的常数枚举成员</li>
<li>带括号的常数枚举表达式，如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li>
<li><code>+</code>，<code>-</code>，<code>~</code>一元运算符应用于常数枚举表达式</li>
<li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>，<code>&amp;</code>，<code>|</code>，<code>^</code>二元运算符，常数枚举表达式作为其一个操作对象。若常数枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错。</li>
</ul>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<h2 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h2><p><code>const enum</code>定义的枚举类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">let directions = [</span><br><span class="line">  Directions.Up,</span><br><span class="line">  Directions.Down,</span><br><span class="line">  Directions.Left,</span><br><span class="line">  Directions.Right</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>编译为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var directions = [</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>常数枚举与普通枚举的区别在编译阶段被删除，并且不能包含计算成员<br>假如包含了计算成员，则会在编译阶段报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const enum Colors &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue = &quot;blue&quot;.length</span><br><span class="line">&#125;</span><br><span class="line">//error TS2474: const enum member initializers can only contain literal values and other computed enum values.</span><br></pre></td></tr></table></figure>
<h2 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h2><p>使用<code>declare</code>声明枚举类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">let directions = [</span><br><span class="line">  Directions.Up,</span><br><span class="line">  Directions.Down,</span><br><span class="line">  Directions.Left,</span><br><span class="line">  Directions.Right</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var directions = [</span><br><span class="line">    Directions.Up,</span><br><span class="line">    Directions.Down,</span><br><span class="line">    Directions.Left,</span><br><span class="line">    Directions.Right</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>外部枚举与声明语句一样，常出现在声明文件中。<br>同时使用<code>declare</code>和<code>const</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">let directions = [</span><br><span class="line">  Directions.Up,</span><br><span class="line">  Directions.Down,</span><br><span class="line">  Directions.Left,</span><br><span class="line">  Directions.Right</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var directions = [</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h2><ul>
<li>类（Class）：定义一件事物的抽象特定，包含属性和方法</li>
<li>对象（Object）：类的实例，通过 new 生成</li>
<li>面向对象（OOP）的三大特点：封装、继承、多态</li>
<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。调用端不需要知道细节，只能通过对外接口来访问该对象，同时也保证外界无法任意更改对象内部的数据</li>
<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。</li>
<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>
<li>修饰器（Modifiers）：修饰符是关键字，用以限定成员或类型的性质。比如 public 表示公有属性或方法</li>
<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。</li>
</ul>
<h2 id="ES6-中类的用法"><a href="#ES6-中类的用法" class="headerlink" title="ES6 中类的用法"></a>ES6 中类的用法</h2><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    return `My name is $&#123;this.name&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(a.sayHi()); //My name is Jack</span><br></pre></td></tr></table></figure>
<p>使用<code>class</code>定义类，使用<code>constructor</code>定义构造函数。<br>使用<code>new</code>实例化</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name); //调用父类的constructor(name)</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    return &quot;Meow,&quot; + super.sayHi(); //调用父类的sayHi()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let c = new Cat(&quot;Tom&quot;); //Tom</span><br><span class="line">console.log(c.sayHi());//Meow,My name is Tom</span><br></pre></td></tr></table></figure>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get name() &#123;</span><br><span class="line">    return &quot;Jack&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    console.log(&quot;setter:&quot; + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Kitty&quot;); //setter:Kitty</span><br><span class="line">a.name = &quot;Tom&quot;; //setter:Tom</span><br><span class="line">console.log(a.name); //Jack</span><br></pre></td></tr></table></figure>
<p>使用 getter 和 setter 改变属性的赋值和读取行为</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>使用<code>static</code>修饰符修饰的方法称为静态方法，不需要实例化，而是直接通过类来调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  static isAnimal(a) &#123;</span><br><span class="line">    return a instanceof Animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Kitty&quot;); //setter:Kitty</span><br><span class="line">console.log(Animal.isAnimal(a)); //true</span><br><span class="line">a.isAnimal(a);//a.isAnimal is not a function</span><br></pre></td></tr></table></figure>
<h2 id="ES7-中类的用法"><a href="#ES7-中类的用法" class="headerlink" title="ES7 中类的用法"></a>ES7 中类的用法</h2><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>ES6 中实例的属性只能通过构造函数中的<code>this.xxx</code>来定义，ES7 提案中可以在类中定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name = &quot;Jack&quot;;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal();</span><br><span class="line">console.log(a.name);//Jack</span><br></pre></td></tr></table></figure>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>ES7 提案中，可以使用<code>static</code>定义一个静态属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    static num = 42;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Animal.num); // 42</span><br></pre></td></tr></table></figure>
<h1 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h1><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul>
<li><code>public</code>修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是<code>public</code>的</li>
<li><code>private</code>修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code>修饰的属性或方法是受保护的，和<code>private</code>类似，区别在于它的子类中也允许被访问</li>
</ul>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let an = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(an.name); //Jack</span><br><span class="line">an.name = &quot;Tom&quot;;</span><br><span class="line">console.log(an.name); //Tom</span><br></pre></td></tr></table></figure>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>希望有的属性无法直接存取的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  private name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let an = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(an.name);</span><br><span class="line">//error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</span><br><span class="line">an.name = &quot;Tom&quot;;</span><br><span class="line">//error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</span><br></pre></td></tr></table></figure>
<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var an = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(an.name);</span><br><span class="line">an.name = &quot;Tom&quot;;</span><br></pre></td></tr></table></figure>
<p>注意，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。</p>
<p><code>private</code>修饰的属性或方法，在子类中也是不允许访问的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  private name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//error TS2341: Property &apos;name&apos; is private and only accessible within class &apos;Animal&apos;.</span><br></pre></td></tr></table></figure>
<p>当构造函数修饰为<code>private</code>时，该类不允许被继承或实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  private constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Jack&quot;);</span><br><span class="line">//error TS2451: Cannot redeclare block-scoped variable &apos;a&apos;</span><br><span class="line">//error TS2673: Constructor of class &apos;Animal&apos; is private and only accessible within the class declaration.</span><br></pre></td></tr></table></figure>
<p>修饰符还可以使用在构造函数参数中，等同于类中定义该属性，使代码更简洁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  // public name: string;</span><br><span class="line">  public constructor(public name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>如果使用<code>protected</code>修饰属性，则允许在子类中访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  protected name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>protected</code>修饰构造函数时，该类只允许被继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  protected constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Jack&quot;);</span><br><span class="line">//error TS2674: Constructor of class &apos;Animal&apos; is protected and only accessible within the class declaration.</span><br></pre></td></tr></table></figure>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>只读关键字属性，只允许出现在属性声明或索引签名中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  readonly name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let an = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(an.name); //Jack</span><br><span class="line">a.name = &quot;Tom&quot;;</span><br><span class="line">//error TS2540: Cannot assign to &apos;name&apos; because it is a read-only property.</span><br></pre></td></tr></table></figure>
<p><strong>注意，如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public constructor(public readonly name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code>用于定义抽象类和其中的抽象方法</p>
<ol>
<li>抽象类不允许被实例化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal(&quot;Jack&quot;);</span><br><span class="line">// error TS2511: Cannot create an instance of an abstract class.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>抽象类中的抽象方法必须被子类实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  public eat() &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125;is eating.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat(&quot;Tom&quot;);</span><br><span class="line">//error TS2515: Non-abstract class &apos;Cat&apos; does not implement inherited abstract member &apos;sayHi&apos; from class &apos;Animal&apos;.</span><br></pre></td></tr></table></figure>
<p>继承抽象类，实现抽象方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  public name;</span><br><span class="line">  public constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  public sayHi() &#123;</span><br><span class="line">    console.log(`Meow，My name is $&#123;this.name&#125;.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<p>编译结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var Cat = (function (_super) &#123;</span><br><span class="line">    __extends(Cat, _super);</span><br><span class="line">    function Cat() &#123;</span><br><span class="line">        return _super !== null &amp;&amp; _super.apply(this, arguments) || this;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.sayHi = function () &#123;</span><br><span class="line">        console.log(&quot;Meow\uFF0CMy name is &quot; + this.name + &quot;.&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return Cat;</span><br><span class="line">&#125;(Animal));</span><br><span class="line">var cat = new Cat(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类</strong></p>
<h2 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h2><p>给类加上 TypeScript 的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi(): string &#123;</span><br><span class="line">    return `My name is $&#123;this.name&#125;.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let an: Animal = new Animal(&quot;Jack&quot;);</span><br><span class="line">console.log(an.sayHi());//My name is Jack.</span><br></pre></td></tr></table></figure>
<h2 id="在-TypeScript-使用泛型创建工厂函数时，需要引用构造函数的类类型"><a href="#在-TypeScript-使用泛型创建工厂函数时，需要引用构造函数的类类型" class="headerlink" title="在 TypeScript 使用泛型创建工厂函数时，需要引用构造函数的类类型"></a>在 TypeScript 使用泛型创建工厂函数时，需要引用构造函数的类类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123;//这边的new()不好理解</span><br><span class="line">    return new c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入一个参数，此参数实例化后生成是 T 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BeeKeeper &#123;</span><br><span class="line">    hasMask: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ZooKeeper &#123;</span><br><span class="line">    nametag: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    numLegs: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bee extends Animal &#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lion extends Animal &#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;</span><br><span class="line">    return new c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;  // typechecks!</span><br><span class="line">createInstance(Bee).keeper.hasMask;   // typechecks!</span><br></pre></td></tr></table></figure>
<p>createInstance 函数的参数是构造函数没有参数的 A 类的类型。</p>
<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><h2 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h2><p>不同类之间共有特性，把特性提取成接口，用<code>implements</code>关键字实现。提高了面向对象的灵活性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">  alert();</span><br><span class="line">&#125;</span><br><span class="line">class Door &#123;&#125;</span><br><span class="line">class SecurityDoor extends Door implements Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    console.log(&quot;SecurityDoor alert&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Car implements Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    console.log(&quot;Car alert&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类实现多个接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">  alert();</span><br><span class="line">&#125;</span><br><span class="line">interface Light &#123;</span><br><span class="line">  lightOn();</span><br><span class="line">  lightOff();</span><br><span class="line">&#125;</span><br><span class="line">class Door &#123;&#125;</span><br><span class="line">class Car implements Alarm &#123;</span><br><span class="line">  alert() &#123;</span><br><span class="line">    console.log(&quot;Car alert&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  lightOn() &#123;</span><br><span class="line">    console.log(&quot;Car light on&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  lightOff() &#123;</span><br><span class="line">    console.log(&quot;Car light off&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">  alert();</span><br><span class="line">&#125;</span><br><span class="line">interface Light &#123;</span><br><span class="line">  lightOn();</span><br><span class="line">  lightOff();</span><br><span class="line">&#125;</span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">  lightOn();</span><br><span class="line">  lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">  z: number;</span><br><span class="line">&#125;</span><br><span class="line">let Point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>使用接口定义一个函数需要符合的形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  return source.search(subString) !== 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数还可以有自己的属性和方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">  let counter = &lt;Counter&gt;function(start: number) &#123;&#125;;</span><br><span class="line">  counter.interval = 123;</span><br><span class="line">  counter.reset = function() &#123;&#125;;</span><br><span class="line">  return counter;</span><br><span class="line">&#125;</span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>定义函数、接口或类的时候，先不指定具体的类型，而在使用的时候再指定类型</p>
<h2 id="例子-简单"><a href="#例子-简单" class="headerlink" title="例子-简单"></a>例子-简单</h2><p>创建一个指定长度的数组，同时将每一项填充默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createArray(length: number, value: any): Array&lt;any&gt; &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">createArray(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<p>返回值为数组泛型，并没有准确定义。实际上每一项的类型就是<code>value</code>的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(createArray&lt;string&gt;(3, &quot;x&quot;));</span><br></pre></td></tr></table></figure>
<p>函数名字后的 T 定义任意输入类型，后面的参数<code>value:T</code>和输出<code>Array&lt;T&gt;</code>中即可使用。<br>调用的时候可以在函数名称后面指定类型，也可以不指定，而让类型推论自动推算。</p>
<h2 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h2><p>一次定义多个泛型参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">  return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line">swap([7, &quot;seven&quot;]);</span><br></pre></td></tr></table></figure>
<p>交换元组</p>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>在函数内部使用泛型变量，由于不知道它是哪种类型，所以不能随意操作它的属性或方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line">// error TS2339: Property &apos;length&apos; does not exist on type &apos;T&apos;.</span><br></pre></td></tr></table></figure>
<p>可以对泛型进行约束，只允许传入那些包含<code>length</code>属性的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>extends</code>约束泛型<code>T</code>，必须符合接口<code>Lengthwise</code>的形状，也就是必须包含<code>length</code>属性<br>如果传入的参数不符合类型约束，编译阶段就会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loggingIdentity(7);</span><br><span class="line">//error TS2345: Argument of type &apos;7&apos; is not assignable to parameter of type &apos;Lengthwise&apos;.</span><br></pre></td></tr></table></figure>
<p>多个类型参数之间也能相互约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">  for (let id in source) &#123;</span><br><span class="line">    target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line">let t = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line">copyFields(t, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure>
<p>使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可以使用接口的方式来定义一个函数需要符合的形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">  &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(createArray(3, &quot;x&quot;)); //[&apos;x&apos;,&apos;x&apos;,&apos;x&apos;]</span><br></pre></td></tr></table></figure>
<p>可以把泛型接口提前到接口名上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt;&#123;</span><br><span class="line">  (length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line">let createArray: CreateArrayFunc&lt;any&gt;;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &apos;x&apos;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</strong></p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h2><p>TypeScript2.3 以后，可以为泛型中的类型参数指定默认类 U 型，当使用泛型时没有在代码中直接指定类型参数，从实际参数中也无法推测出时，默认类型就会起作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h1><p>如果定义了两个相同名字的函数、接口或类，会合并成一个类型。</p>
<h2 id="接口的声明合并"><a href="#接口的声明合并" class="headerlink" title="接口的声明合并"></a>接口的声明合并</h2><p>1.非函数成员<br><strong>注意，合并属性的类型必须是唯一的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number,</span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    y: number;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 1,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.函数成员<br><strong>函数重载顺序：接口内部安装书写顺序，正序（先写的在前），接口之间，先写的在后</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    foo(bar: number): number;//3</span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    y: number;</span><br><span class="line">    foo(bar: string): string;//1</span><br><span class="line">    foo(bar: number[]):number[]//2</span><br><span class="line">&#125;</span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 1,</span><br><span class="line">    foo(bar: any) &#123;</span><br><span class="line">        return bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数参数是字符串字面量，该函数声明会提升到最前面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    foo(bar: number): number;//5</span><br><span class="line">    foo(bar: &apos;a&apos;): number//2</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    y: number;</span><br><span class="line">    foo(bar: string): string;//3</span><br><span class="line">    foo(bar: number[]): number[];//4</span><br><span class="line">    foo(bar: &apos;b&apos;): number;//1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 1,</span><br><span class="line">    foo(bar:any):any &#123;</span><br><span class="line">        return bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间和其他类型的合并"><a href="#命名空间和其他类型的合并" class="headerlink" title="命名空间和其他类型的合并"></a>命名空间和其他类型的合并</h2><p>就相当于在原数据上增加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Lib() &#123; &#125;</span><br><span class="line">namespace Lib&#123;</span><br><span class="line">    export let version=&apos;1.0&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Lib.version)//1.0</span><br><span class="line"></span><br><span class="line">class C &#123; &#125;</span><br><span class="line">namespace C&#123;</span><br><span class="line">    export let state=1</span><br><span class="line">&#125;</span><br><span class="line">console.log(C.state)//1</span><br><span class="line"></span><br><span class="line">enum Color&#123;</span><br><span class="line">    Green,</span><br><span class="line">    Red,</span><br><span class="line">    Yellow</span><br><span class="line">&#125;</span><br><span class="line">namespace Color&#123;</span><br><span class="line">    export function mix() &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color.mix())//1</span><br></pre></td></tr></table></figure>
<h2 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h2><p>重载定义多个函数类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &apos;number&apos;) &#123;</span><br><span class="line">        return Number(x.toString().split(&apos;&apos;).reverse().join(&apos;&apos;));</span><br><span class="line">    &#125; else if (typeof x === &apos;string&apos;) &#123;</span><br><span class="line">        return x.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的合并"><a href="#类的合并" class="headerlink" title="类的合并"></a>类的合并</h2><p>与接口的合并规则一致</p>
<h1 id="模块导入与导出"><a href="#模块导入与导出" class="headerlink" title="模块导入与导出"></a>模块导入与导出</h1><p>ES6 模块导出，commonJS 模块导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//导出 es6/d.ts</span><br><span class="line">export =function()&#123;</span><br><span class="line">  console.log(&quot;I&apos;m default&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//不能有其他导出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导入 node/c.ts</span><br><span class="line">import fun =require(&apos;../es6/d&apos;)</span><br><span class="line">//如果项目tsconfig配置“esModuleInterop”:true</span><br><span class="line">//可以写成</span><br><span class="line">import fun from &apos;../ed6/d&apos;</span><br></pre></td></tr></table></figure>
<h1 id="编写声明文件"><a href="#编写声明文件" class="headerlink" title="编写声明文件"></a>编写声明文件</h1><h2 id="global-库"><a href="#global-库" class="headerlink" title="global 库"></a>global 库</h2><p>//global-lib.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function globalLib(options) &#123;</span><br><span class="line">  console.log(options);</span><br><span class="line">&#125;</span><br><span class="line">globalLib.version = &quot;1.0.0&quot;;</span><br><span class="line">globalLib.doSomething = function () &#123;</span><br><span class="line">  console.log(&quot;globalLib do somethings&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>global-lib.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function globalLib(options: globalLib.Options): void;</span><br><span class="line">  declare namespace globalLib &#123;</span><br><span class="line">    const version: string;</span><br><span class="line">    function doSomething(): void;</span><br><span class="line">    interface Options &#123;</span><br><span class="line">    [key: string]: any;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<br>引入<code>&lt;script src=&#39;src/lib/global-lib.js&#39;&gt;&lt;/script&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">globalLib(&#123; x: 1 &#125;);</span><br><span class="line">globalLib.doSomething();</span><br></pre></td></tr></table></figure>
<h2 id="module-库"><a href="#module-库" class="headerlink" title="module 库"></a>module 库</h2><p>module-lib.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const version = &quot;1.0.0&quot;;</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  console.log(&quot;moduleLib do something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function moduleLib(options) &#123;</span><br><span class="line">  console.log(options);</span><br><span class="line">&#125;</span><br><span class="line">moduleLib.version = version;</span><br><span class="line">moduleLib.doSomething = doSomething;</span><br><span class="line">module.exports = moduleLib;</span><br></pre></td></tr></table></figure>
<p>module-lib.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function moduleLib(options: Options): void;</span><br><span class="line">interface Options &#123;</span><br><span class="line">  [key: string]: any;</span><br><span class="line">&#125;</span><br><span class="line">declare namespace moduleLib &#123;</span><br><span class="line">  export const version: string;</span><br><span class="line">  function doSomething(): void;</span><br><span class="line">&#125;</span><br><span class="line">export = moduleLib;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import moduleLib from &quot;./module-lib&quot;;</span><br><span class="line">moduleLib(&#123; x: 2 &#125;);</span><br><span class="line">moduleLib.doSomething();</span><br></pre></td></tr></table></figure>
<h2 id="umd-库"><a href="#umd-库" class="headerlink" title="umd 库"></a>umd 库</h2><p>umd-lib.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (root, factory) &#123;</span><br><span class="line">  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">    module.exports = factory();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root.umdLib = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(this, function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    version: &quot;1.0.0&quot;,</span><br><span class="line">    doSomething() &#123;</span><br><span class="line">      console.log(&quot;umdLib do something&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>umd-lib.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace umdLib &#123;</span><br><span class="line">  const version: string;</span><br><span class="line">  function doSomething(): void;</span><br><span class="line">&#125;</span><br><span class="line">export as namespace umdLib;</span><br><span class="line">export = umdLib;</span><br></pre></td></tr></table></figure>
<p>使用 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import umdLib from &quot;./umd-lib.js&quot;;</span><br><span class="line">umdLib.doSomething();</span><br></pre></td></tr></table></figure>
<p>使用 2<br>引入<code>&lt;script src=&#39;src/lib/umd-lib.js&#39;&gt;&lt;/script&gt;</code><br>需要 ts 配置<code>&quot;allowUmdGlobalAccess&quot;: true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umdLib.doSomething();</span><br></pre></td></tr></table></figure>
<h2 id="为库增加属性"><a href="#为库增加属性" class="headerlink" title="为库增加属性"></a>为库增加属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import m from &quot;moment&quot;;</span><br><span class="line">declare module &quot;moment&quot; &#123;</span><br><span class="line">  export function myFunction(): void;</span><br><span class="line">&#125;</span><br><span class="line">m.myFunction = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="为全局类库增加方法-不建议使用"><a href="#为全局类库增加方法-不建议使用" class="headerlink" title="为全局类库增加方法(不建议使用)"></a>为全局类库增加方法(不建议使用)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  namespace globalLib &#123;</span><br><span class="line">    function doAnything(): void;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">globalLib.doAnything = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="ts-配置选项"><a href="#ts-配置选项" class="headerlink" title="ts 配置选项"></a>ts 配置选项</h1><p>默认配置：<code>ts -- init</code>生成 ts 默认配置文件</p>
<h2 id="文件选项"><a href="#文件选项" class="headerlink" title="文件选项"></a>文件选项</h2><h3 id="files-：指定-ts-编译的文件，数组"><a href="#files-：指定-ts-编译的文件，数组" class="headerlink" title="files ：指定 ts 编译的文件，数组"></a>files ：指定 ts 编译的文件，数组</h3><p><code>&quot;files&quot;: [&quot;src/a.ts&quot;]</code></p>
<h3 id="include-：指定-ts-编译的路径或文件"><a href="#include-：指定-ts-编译的路径或文件" class="headerlink" title="include ：指定 ts 编译的路径或文件"></a>include ：指定 ts 编译的路径或文件</h3><p><code>&quot;include&quot;: [&quot;src/a.ts&quot;,&quot;src/lib&quot;]</code><br>支持通配符<br><code>&quot;src&quot;</code>：包括 src 里面所有的文件<br><code>&quot;src/*&quot;</code>：仅包括 src 一级目录的文件<br><code>&quot;src/*/*&quot;</code>：仅包括 src 二级目录的文件</p>
<p>编译配置拆分<br>tsconfig.base.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [&quot;src/a.ts&quot;],</span><br><span class="line">  &quot;include&quot;: [&quot;src&quot;], //通配符 src/*仅src一级目录，src/*/*仅src二级目录</span><br><span class="line">  &quot;exclude&quot;: [&quot;src/lib&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tsconfig.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;./tsconfig.base.json&quot;,</span><br><span class="line">  &quot;exclude&quot;: []//覆盖base里面属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [&quot;src&quot;],</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    // &quot;incremental&quot;: true /* 增量编译，生成编译文件 */,</span><br><span class="line">    // &quot;diagnostics&quot;: true /*打印诊断信息*/,</span><br><span class="line">    // &quot;tsBuildInfoFile&quot;: &quot;./buildFile/&quot; /* 指定增量编译文件的名字 */,</span><br><span class="line"></span><br><span class="line">    &quot;target&quot;: &quot;es5&quot; /* Specify ECMAScript target version: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;, &apos;ES2018&apos;, &apos;ES2019&apos; or &apos;ESNEXT&apos;. */,</span><br><span class="line">    // &quot;module&quot;: &quot;amd&quot; /* Specify module code generation: &apos;none&apos;, &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos;, &apos;es2015&apos;, or &apos;ESNext&apos;. */,</span><br><span class="line">    // &quot;outFile&quot;: &quot;./app.js&quot; /* 多个相互依赖的文件编译成一个文件，用于AMD模块中 &quot;module&quot;: &quot;amd&quot;*/,</span><br><span class="line"></span><br><span class="line">    // &quot;lib&quot;: [</span><br><span class="line">    //   &quot;dom&quot;,</span><br><span class="line">    //   &quot;es5&quot;,</span><br><span class="line">    //   &quot;ScriptHost&quot;,</span><br><span class="line">    //   &quot;ES2019.Array&quot;</span><br><span class="line">    // ] /*TS需要引用的库，即声明文件，。es5默认&quot;dom&quot;,&quot;es5&quot;,&quot;ScriptHost&quot; */,</span><br><span class="line"></span><br><span class="line">    // &quot;allowJs&quot;: true /* 允许编译js文件 (.js,jsx) 要指定输出目录，否则报错覆盖原文件*/,</span><br><span class="line">    // &quot;checkJs&quot;: true /* 允许报告.js文件中的错误，与allowJs配合使用 */,</span><br><span class="line">    // &quot;outDir&quot;: &quot;./dest&quot; /* 指定输出目录 */,</span><br><span class="line">    // &quot;rootDir&quot;: &quot;./src&quot; /* 指定输入文件目录（用于控制输出目录结构) ./：输出dest包含src目录，./src:输出dest不包含src目录*/,</span><br><span class="line"></span><br><span class="line">    // &quot;declaration&quot;: true /* 生成声明文件 &apos;.d.ts&apos; */,</span><br><span class="line">    // &quot;declarationDir&quot;: &quot;./types&quot; /* 声明文件的目录 相对于根目录*/,</span><br><span class="line">    // &quot;emitDeclarationOnly&quot;: true /*只生成声明文件*/,</span><br><span class="line"></span><br><span class="line">    // &quot;sourceMap&quot;: true /* 生成source map文件*/,</span><br><span class="line"></span><br><span class="line">    // &quot;inlineSourceMap&quot;: true /*行内source map文件*/,</span><br><span class="line">    // &quot;declarationMap&quot;: true /* 声明文件的source map文件 */,</span><br><span class="line"></span><br><span class="line">    //  &quot;typeRoots&quot;: [] /* 声明文件目录。默认node_modules/@types */,</span><br><span class="line">    // &quot;types&quot;: [] /* 指定需要加载的声明文件包*/</span><br><span class="line"></span><br><span class="line">    // &quot;removeComments&quot;: true /* 删除注释 */,</span><br><span class="line"></span><br><span class="line">    // &quot;noEmit&quot;: true /* 不输出任何文件 */,</span><br><span class="line">    // &quot;noEmitOnError&quot;: true /* 出错时不输出任何文件 */,</span><br><span class="line"></span><br><span class="line">    // &quot;noEmitHelpers&quot;: true /* 不生成helper函数， 安装ts-helpers*/,</span><br><span class="line">    // &quot;importHelpers&quot;: true /* 通过tslib引入helper函数，文件必须是模块 */,</span><br><span class="line"></span><br><span class="line">    // &quot;downlevelIteration&quot;: true /*降级遍历器实现(es3/es5)*/,</span><br><span class="line"></span><br><span class="line">    /* Strict Type-Checking Options */</span><br><span class="line">    &quot;strict&quot;: true /* 开启所有严格的类型检查，为true时，下面所有配置都为true */,</span><br><span class="line">    // &quot;noImplicitAny&quot;: true,                 /* 不允许隐式的any类型 */</span><br><span class="line">    // &quot;strictNullChecks&quot;: true,              /* 不允许把null、undefined赋值给其他类型的变量 */</span><br><span class="line">    // &quot;strictFunctionTypes&quot;: true,           /* 不允许函数参数双向协变*/</span><br><span class="line">    // &quot;strictBindCallApply&quot;: false /* 严格的&apos;bind&apos;, &apos;call&apos;, and &apos;apply&apos; 检查,参数类型不再默认转换*/,</span><br><span class="line">    // &quot;strictPropertyInitialization&quot;: true,  /* 类的实例属性必须初始化 */</span><br><span class="line">    // &quot;noImplicitThis&quot;: false /* 不允许this隐式的&apos;any&apos; 类型. */,</span><br><span class="line">    // &quot;alwaysStrict&quot;: true,                  /* 在代码中注入&quot;use strict&quot;*/</span><br><span class="line"></span><br><span class="line">    /* Additional Checks warning*/</span><br><span class="line">    // &quot;noUnusedLocals&quot;: true,                /*不允许出现声明但未使用的局部变量 */</span><br><span class="line">    // &quot;noUnusedParameters&quot;: true,            /* 检查未使用的函数参会时 */</span><br><span class="line">    // &quot;noImplicitReturns&quot;: true,             /* 每个分支都要有返回值*/</span><br><span class="line">    // &quot;noFallthroughCasesInSwitch&quot;: true,    /* 防止switch语句贯穿 */</span><br><span class="line"></span><br><span class="line">    // &quot;esModuleInterop&quot;: true /*允许export=导出，由import from 导入 */,</span><br><span class="line">    // &quot;allowUmdGlobalAccess&quot;: true,          /* 允许在模块中访问UMD全局变量 */</span><br><span class="line">    // &quot;moduleResolution&quot;: &quot;node&quot;,            /* 模块解析策略 */</span><br><span class="line">    // &quot;baseUrl&quot;: &quot;./&quot;,                       /* 解析非相对模块的基地址 */</span><br><span class="line">    // &quot;paths&quot;: &#123;</span><br><span class="line">    // &quot;jquery&quot;:[&quot;node_modules/jquery/jquery/dist/jquery.min.js&quot;]</span><br><span class="line">    // &#125;,                           /* 路径映射，相对于 &apos;baseUrl&apos;. */</span><br><span class="line">    // &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;],                        /* 项目运行时将多个目录放到一个虚拟目录下 */</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot; /*  &apos;preserve&apos;生成代码保留jsx格式,扩展名jsx,可以被babel使用, &apos;react-native&apos;生成代码保留jsx格式，扩展名.js, or &apos;react&apos;生成代码js语法 */,</span><br><span class="line">    &quot;listEmittedFiles&quot;: true /* 打印编译后的输出文件路径*/,</span><br><span class="line">    &quot;listFiles&quot;: true /*打印编译文件，（包括引用的声明文件）*/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="babel-配置"><a href="#babel-配置" class="headerlink" title="babel 配置"></a>babel 配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loader: &quot;ts-loader&quot;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    transpileOnly: true, //只做语言转换，不做类型检查</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>提高打包效率<br>可以另外安装插件类型检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i fork-ts-checker-webpack-plugin -D</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new ForkTsCheckerWebpackPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript基础</title>
    <url>/2019/11/10/TypeScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>TypeScript 基础<br>参考：<a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></p>
<a id="more"></a>
<h1 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h1><p>布尔值、数值、字符串、null、undefined、以及 ES6 中的新类型 Symbol</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br></pre></td></tr></table></figure>
<p><em>注意，使用构造函数<code>Boolean</code>创造的对象不是布尔值</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br></pre></td></tr></table></figure>
<p>编译报错<br><img src="/2019/11/10/TypeScript基础/img1.png" alt="boolean"><br><code>new Boolean()</code>返回的是一个<code>Boolean</code>对象<br>直接调用<code>Boolean()</code>也可以返回一个<code>boolean</code>类型，将参数转化为 Boolean 值。</p>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>number</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">//ES6中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">//ES6中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br></pre></td></tr></table></figure>
<p>编译结果：<br>二进制和八进制会编译成十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">//ES6中的二进制表示法</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">//ES6中的八进制表示法</span><br><span class="line">var octalLiteral = 484;</span><br><span class="line">var notANumber = NaN;</span><br><span class="line">var infinityNumber = Infinity;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>string</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myName: string = &quot;Tom&quot;;</span><br><span class="line">let myAge: number = 25;</span><br><span class="line">//模板字符串</span><br><span class="line">let sentence: string = `Hello, my name is $&#123;myName&#125;.I&apos;ll be $&#123;myAge +</span><br><span class="line">  1&#125; years old next month.`;</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myName = &quot;Tom&quot;;</span><br><span class="line">var myAge = 25;</span><br><span class="line">//模板字符串</span><br><span class="line">var sentence = &quot;Hello, my name is &quot; + myName + &quot;.I&apos;ll be &quot; + (myAge +</span><br><span class="line">    1) + &quot; years old next month.&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型是用固定数量的元素组成的数组，元素的类型是已知的，但不一定是相同的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x: [string, number];</span><br><span class="line">x = [&quot;hello&quot;, 5];  //ok</span><br><span class="line">x = [5, &quot;hello&quot;]; //error</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/10/TypeScript基础/img3.png" alt="基础1"><br>通过下标可以访问元素，访问不存在的下标会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(x[0]);</span><br><span class="line">console.log(x[2]);</span><br></pre></td></tr></table></figure>
<h2 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h2><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射。<br>值是只读的，无法修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color[&quot;Red&quot;] === 0); //true</span><br><span class="line">console.log(Color[&quot;Green&quot;] === 1); //true</span><br><span class="line">console.log(Color[&quot;Blue&quot;] === 2); //true</span><br><span class="line">console.log(Color[0] === &quot;Red&quot;); //true</span><br><span class="line">console.log(Color[1] === &quot;Green&quot;); //true</span><br><span class="line">console.log(Color[2] === &quot;Blue&quot;); //true</span><br></pre></td></tr></table></figure>
<p>可以设置其中一个成员的值,后面的值随之递增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//枚举</span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green = 3,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color[&quot;Red&quot;]);   //0</span><br><span class="line">console.log(Color[&quot;Green&quot;]);   //3</span><br><span class="line">console.log(Color[&quot;Blue&quot;]);   //4</span><br><span class="line">console.log(Color[&apos;4&apos;] === &quot;Blue&quot;)  //true</span><br></pre></td></tr></table></figure>
<p>也可以同时设置所有的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  Red = 1,</span><br><span class="line">  Green = 3,</span><br><span class="line">  Blue = 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Color[&quot;Red&quot;]); //1</span><br><span class="line">console.log(Color[&quot;Green&quot;]); //3</span><br><span class="line">console.log(Color[&quot;Blue&quot;]);//5</span><br></pre></td></tr></table></figure>
<p>如果一个枚举的值为 string，后面的值都要设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以使用 void 表示没有任何返回值的函数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function alterName(): void &#123;</span><br><span class="line">  alert(&quot;My name is Tom&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void 类 U 型的变量只能赋值 undefined 和 null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let unusable:void = undefined;</span><br></pre></td></tr></table></figure>
<h2 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h2><p>使用<code>null</code>和<code>undefined</code>来定义原始数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null</span><br></pre></td></tr></table></figure>
<p>与<code>void</code>的区别，<code>undefined</code>和<code>null</code>是所有类型的子类型。也就是说<code>undefined</code>类型的变量，可以赋值给<code>number</code>类型的变量.</p>
<p>当指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和他们各自。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num: number = undefined;</span><br><span class="line">let u:undefined;</span><br><span class="line">let num:number = u;</span><br></pre></td></tr></table></figure>
<h1 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h1><h2 id="what"><a href="#what" class="headerlink" title="what"></a>what</h2><p>Any 用来表示允许赋值为任意类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber: string = &quot;seven&quot;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure>
<p>报错:hello.ts:36:1 - error TS2322: Type ‘7’ is not assignable to type ‘string’.</p>
<p>如果类型为 any，就被允许赋值为任意值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber1: any = &quot;seven&quot;;</span><br><span class="line">myFavoriteNumber1 = 7;</span><br></pre></td></tr></table></figure>
<h2 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let anyThing: any = &quot;hello&quot;;</span><br><span class="line">console.log(anyThing.myName);</span><br><span class="line">//undefined</span><br></pre></td></tr></table></figure>
<p>也允许调用任何方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let anyThing: any = &quot;hello&quot;;</span><br><span class="line">anyThing.toFixed();</span><br><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.toFixed();</span><br><span class="line">//prettySure.toFixed()编译会报错anyThing.toFixed()不会</span><br></pre></td></tr></table></figure>
<p>声明一个变量为任意值后，对它的任何操作，返回的内容的类型都是任意值。</p>
<h2 id="未声明类型的变量"><a href="#未声明类型的变量" class="headerlink" title="未声明类型的变量"></a>未声明类型的变量</h2><p>如果在声明的时候未指定其类型，就会被识别为任意值类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let something;</span><br><span class="line">something = &quot;seven&quot;;</span><br><span class="line">something = 7;</span><br><span class="line">something.setName(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="Nerver"><a href="#Nerver" class="headerlink" title="Nerver"></a>Nerver</h1><h2 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h2><p>表示那些用不存在的值的类型</p>
<ol>
<li>总是会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型。</li>
<li>变量被永不为真的类型所保护时，也可以是 never 类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 有无法到达的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">  throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function infiniteLoop(): never &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//推断返回值是never</span><br><span class="line">function fail() &#123;</span><br><span class="line">  error(&quot;fail&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>never 是任何类型的子类型，并且可以赋值给任何类型</li>
<li>除了 never 类型本身以外没有类型可以赋值给 never 类型</li>
<li>在一个没有返回值标注的函数表达式或箭头函数中, 如果函数没有 return 语句, 或者仅有表达式类型为 never 的 return 语句, 并且函数的终止点无法被执行到 (按照控制流分析), 则推导出的函数返回值类型是 never.</li>
<li>在一个明确指定了 never 返回值类型的函数中, 所有 return 语句 (如果有) 表达式的值必须为 never 类型, 且函数不应能执行到终止点.</li>
</ul>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>非原始类型，除了<code>number</code>,<code>string</code>,<code>boolean</code>,<code>symbol</code>,<code>null</code>,<code>undefined</code>之外的类型。<br>使用<code>Object</code>类型就可以更好的表示像<code>Object.create</code>这样的 API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line">create(&#123; prop: 0 &#125;);</span><br><span class="line">create(null);</span><br><span class="line">create(undefined);</span><br><span class="line"></span><br><span class="line">create(42)//error</span><br><span class="line">create(&quot;string&quot;); //error</span><br><span class="line">create(false); //error</span><br></pre></td></tr></table></figure>
<h1 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h1><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果没有明确的指定类型，TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。<br>推论发生在初始化变量和成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber = &quot;seven&quot;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">let h=[1]</span><br><span class="line">let foo=(x=1)=&gt;x+1</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/10/TypeScript基础/_posts/TypeScript基础/img4.png" alt="推论"><br>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber:string = &quot;seven&quot;;</span><br><span class="line">myFavoriteNumber:number = 7;</span><br><span class="line">let h:number[]=[1]</span><br><span class="line">let foo=(x:number=1):number=&gt;x+1</span><br></pre></td></tr></table></figure>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断为<code>any</code>类型，而类型完全不被类型检查</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber1;</span><br><span class="line">myFavoriteNumber1 = &quot;seven&quot;;</span><br><span class="line">myFavoriteNumber1 = 7;//不报错</span><br></pre></td></tr></table></figure>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x =[0,1,null]</span><br></pre></td></tr></table></figure>
<p>考虑所有元素的类型，推论 x 的类型为<code>(number|null)[]</code>。<br>如果没有找到最佳通用类型，类型判断结果为联合数组类型<br>注：需要在 tsconfig.js 配置<code>strictNullChecks&quot;: false</code>，将<code>null</code>,<code>undefined</code>视为其他类型的子类型，x 被推断为<code>number[]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let zoo =[new Rhino(), new Elephant(), new Snake()]</span><br></pre></td></tr></table></figure>
<p>没法直接推断 zoo 的类型为 Animal[]类型，只能联合数组类型[Rhino|Elephant|Snake]</p>
<h3 id="上下文归类"><a href="#上下文归类" class="headerlink" title="上下文归类"></a>上下文归类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onmousedown = function(mouseEvent) &#123;</span><br><span class="line">  console.log(mouseEvent.button);  //ok</span><br><span class="line">  console.log(mouseEvent.kangaroo); //error</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TypeScript 类型检查器会使用 Window.onmousedown 函数的类型来推断右边函数表达式的类型。 所以它能够推断出 mouseEvent 参数的类型中包含了 button 属性而不包含 kangaroo 属性。<br><strong>可能是我编写测试代码环境有问题，编译的时候没报错</strong><br>上下文类型也会作为最佳通用类型的候选类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createZoo(): Animal[]&#123;</span><br><span class="line">    return [new Rhino(), new Elephant(), new Snake()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，最佳通用类型有 4 个候选者：Animal，Rhino，Elephant 和 Snake。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>Type Assertion<br>用来手动指定一个值的类型</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line">//或</span><br><span class="line">值 as 类型</span><br></pre></td></tr></table></figure>
<p><strong>在 tsx 语法（React 的 jsx 语法的 ts 版中必须用后一种</strong></p>
<h3 id="例子：将一个联合类型的变量指定为一个更加具体的类型"><a href="#例子：将一个联合类型的变量指定为一个更加具体的类型" class="headerlink" title="例子：将一个联合类型的变量指定为一个更加具体的类型"></a>例子：将一个联合类型的变量指定为一个更加具体的类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,22): error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//   Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br></pre></td></tr></table></figure>
<p>有时候我们确实需要在还不确定类型的时候访问其中一个类型的属性或方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">  if (something.length) &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br><span class="line">//Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//Property &apos;length&apos; does not exist on type &apos;number&apos;</span><br></pre></td></tr></table></figure>
<p>此时可以使用类型断言，将 something 断言成 string：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">  if ((something as string).length) &#123;</span><br><span class="line">    return (something as string).length;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//或</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">  if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">    return (&lt;string&gt;something).length;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return something.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function toBoolean(something: string | number): boolean &#123;</span><br><span class="line">  return &lt;boolean&gt;something;</span><br><span class="line">&#125;</span><br><span class="line">//error TS2352: Conversion of type &apos;string | number&apos; to type &apos;boolean&apos; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &apos;unknown&apos; first.</span><br><span class="line">//Type &apos;number&apos; is not comparable to type &apos;boolean&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>类型 Y 可以被赋值给类型 X，则称类型 X 兼容类型 Y<br>结构之间兼容：成员少的兼容成员多的<br>函数之间兼容：参数多的兼容参数少的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s: string = &apos;a&apos;</span><br><span class="line">s=null</span><br><span class="line">//strictFunctionTypes=false，string可以兼容null</span><br></pre></td></tr></table></figure>
<h4 id="接口兼容"><a href="#接口兼容" class="headerlink" title="接口兼容"></a>接口兼容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface X&#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b :number</span><br><span class="line">&#125;</span><br><span class="line">interface Y&#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b: number;</span><br><span class="line">    c: number;</span><br><span class="line">&#125;</span><br><span class="line">let x: X = &#123; a: 1, b: 2 &#125;</span><br><span class="line">let y: Y = &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">x = y</span><br><span class="line">y = x //Type &apos;X&apos; is not assignable to type &apos;Y&apos;.Property &apos;c&apos; is missing in type &apos;X&apos;.</span><br></pre></td></tr></table></figure>
<p>所以 X 兼容 Y，Y 不兼容 X</p>
<h4 id="函数兼容性"><a href="#函数兼容性" class="headerlink" title="函数兼容性"></a>函数兼容性</h4><p>1）参数个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Handler = (a: number, b: number) =&gt; void</span><br><span class="line">function hof(handler: Handler) &#123;</span><br><span class="line">    return handler</span><br><span class="line">&#125;</span><br><span class="line">let handler1 = (a: number) =&gt; &#123; &#125;</span><br><span class="line">hof(handler1)</span><br><span class="line">let handler2 = (a: number, b: number, c: number) =&gt; &#123; &#125;</span><br><span class="line">//hof(handler2) //handler2有三个参数hof无法处理</span><br></pre></td></tr></table></figure>
<p>可选参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a = (p1: number, p2: number) =&gt; &#123; &#125;</span><br><span class="line">let b = (p1?: number, p2?: number) =&gt; &#123; &#125;</span><br><span class="line">let c = (...args: number[]) =&gt; &#123; &#125;</span><br><span class="line">a = b</span><br><span class="line">a = c</span><br><span class="line">//b = c//strictFunctionTypes=false时兼容</span><br><span class="line">//b = a//strictFunctionTypes=false时兼容</span><br><span class="line">c = a</span><br><span class="line">c = b</span><br></pre></td></tr></table></figure>
<p>2）参数类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let handler3 = (a: string) =&gt; &#123; &#125;</span><br><span class="line">//hof(handler3)//无法传入</span><br></pre></td></tr></table></figure>
<p>对象参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Point3D&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Point2D&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p3d = (point: Point3D) =&gt; &#123; &#125;</span><br><span class="line">let p2d = (point: Point2D) =&gt; &#123; &#125;</span><br><span class="line">p3d = p2d</span><br><span class="line">//p2d = p3d 不兼容，参数多的兼容参数少的，strictFunctionTypes=false,p2兼容p3d</span><br></pre></td></tr></table></figure>
<p>3）返回值类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let f = () =&gt; (&#123; name: &apos;Alice&apos; &#125; );</span><br><span class="line">let g = () =&gt; (&#123; name: &apos;Alice&apos;, location: &apos;Beijing&apos; &#125;);</span><br><span class="line">f = g //返回值少的兼容返回值多的</span><br></pre></td></tr></table></figure>
<p>重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function overload(a: number, b: number): number;</span><br><span class="line">function overload(a: string, b: string): string;</span><br><span class="line">function overload(a: any, b: any): any &#123; &#125;</span><br><span class="line">//function overload(a: any, b: any, c:any): any &#123; &#125;</span><br><span class="line">//function overload(a: any, b: any, c:any) &#123; &#125;</span><br><span class="line">//都不兼容</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型兼容性"><a href="#枚举类型兼容性" class="headerlink" title="枚举类型兼容性"></a>枚举类型兼容性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Fruit&#123; Apple, Banana &#125;</span><br><span class="line">enum Color&#123;Red,Yellow&#125;</span><br><span class="line">//枚举类型与数字类型兼容</span><br><span class="line">let fruit: Fruit.Apple = 3;</span><br><span class="line">let no: number = Fruit.Apple</span><br><span class="line"></span><br><span class="line">//枚举类型之间不兼容</span><br><span class="line">//let color:Color.Red=Fruit.Apple</span><br></pre></td></tr></table></figure>
<h4 id="类兼容性"><a href="#类兼容性" class="headerlink" title="类兼容性"></a>类兼容性</h4><p>构造函数和静态属性不参与兼容比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    constructor(p: number, q: number) &#123; &#125;</span><br><span class="line">    id:number=1</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">    static s = 1;</span><br><span class="line">    constructor(p: number) &#123; &#125;</span><br><span class="line">    id:number=2</span><br><span class="line">&#125;</span><br><span class="line">let aa = new A(1, 2);</span><br><span class="line">let bb = new B(1)</span><br><span class="line">aa = bb</span><br><span class="line">bb = aa</span><br></pre></td></tr></table></figure>
<p>如果含有私有属性，不兼容其他类。兼容其子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class C extends A&#123;</span><br><span class="line">    constructor(p: number, q: number, name: string) &#123;</span><br><span class="line">        super(1, 2),</span><br><span class="line">            name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cc = new C(1, 2,&apos;333&apos;)</span><br><span class="line">aa = cc</span><br><span class="line">cc = aa</span><br></pre></td></tr></table></figure>
<h4 id="泛型兼容性"><a href="#泛型兼容性" class="headerlink" title="泛型兼容性"></a>泛型兼容性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Empty&lt;T&gt;&#123;</span><br><span class="line">    value:T</span><br><span class="line">&#125;</span><br><span class="line">//let obj1: Empty&lt;number&gt; = &#123;&#125;</span><br><span class="line">//let obj2: Empty&lt;string&gt; = &#123;&#125;</span><br><span class="line">// obj1=obj2</span><br><span class="line">//不兼容</span><br></pre></td></tr></table></figure>
<p>泛型函数,参数多的兼容参数少的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let log1 = &lt;T&gt;(x: T): T =&gt; &#123;</span><br><span class="line">    console.log(&apos;x&apos;)</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line">let log2 = &lt;T&gt;(y: T): T =&gt; &#123;</span><br><span class="line">    console.log(&apos;y&apos;)</span><br><span class="line">    let a: T;</span><br><span class="line"></span><br><span class="line">    return y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log1 = log2</span><br><span class="line">log2 = log1</span><br></pre></td></tr></table></figure>
<h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>TS 能够在特定的区块中保证变量属于某种确定的类型<br>可以在此区块中放心的引用此类型的属性或者调用此类型的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Type&#123; Strong, Week &#125;</span><br><span class="line">class Java&#123;</span><br><span class="line">    helloJava() &#123;</span><br><span class="line">        console.log(&apos;hello Java&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaScript&#123;</span><br><span class="line">    helloJavaScript() &#123;</span><br><span class="line">        console.log(&apos;Hello JavaScript&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === Type.Strong ? new Java() : new JavaScript()</span><br><span class="line">     if ((lang as Java).helloJava) &#123;</span><br><span class="line">       (lang as Java).helloJava()</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       (lang as JavaScript).helloJavaScript()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === Type.Strong ? new Java() : new JavaScript()</span><br><span class="line"></span><br><span class="line">    if (lang instanceof Java) &#123;</span><br><span class="line">        lang.helloJava()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lang.helloJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    return lang</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Type&#123; Strong, Week &#125;</span><br><span class="line">class Java&#123;</span><br><span class="line">    helloJava() &#123;</span><br><span class="line">        console.log(&apos;hello Java&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    java:any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JavaScript&#123;</span><br><span class="line">    helloJavaScript() &#123;</span><br><span class="line">        console.log(&apos;Hello JavaScript&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    javaScript:any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === Type.Strong ? new Java() : new JavaScript()</span><br><span class="line">    if (&apos;java&apos; in lang) &#123;</span><br><span class="line">       lang.helloJava()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       lang.helloJavaScript()</span><br><span class="line">   &#125;</span><br><span class="line">    return lang</span><br></pre></td></tr></table></figure>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(x:string|number)&#123;</span><br><span class="line"> if (typeof x === &apos;string&apos;) &#123;</span><br><span class="line">       x.length</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       x.toFixed(2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型保护函数"><a href="#类型保护函数" class="headerlink" title="类型保护函数"></a>类型保护函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isJava(lang:Java|JavaScript):lang is Java&#123;</span><br><span class="line">  return (lang as Java).helloJava!==undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p>Union Types 表示取值可以为多种类型中的一种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: string | number;</span><br><span class="line">a = &quot;seven&quot;;//true</span><br><span class="line">a = 7;//true</span><br><span class="line">a = true;  //error</span><br></pre></td></tr></table></figure>
<p>分隔符:<code>|</code></p>
<h2 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h2><p>TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里的<code>共有属性或方法</code>；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(st: string | number): number &#123;</span><br><span class="line">  return st.length;</span><br><span class="line">&#125;</span><br><span class="line">//error TS2339: Property &apos;length&apos; does not exist on type &apos;string | number&apos;.</span><br><span class="line">//Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br></pre></td></tr></table></figure>
<p>length 不是 string 和 number 的共有属性所以会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(st: string | number): string &#123;</span><br><span class="line">  return st.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString 是 String 和 Number 的共有属性。</p>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推出一个类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let b: string | number;</span><br><span class="line">b = &quot;seven&quot;;</span><br><span class="line">console.log(b.length); //5</span><br><span class="line">b = 7;</span><br><span class="line">console.log(b.length);//error</span><br><span class="line">// error TS2339: Property &apos;length&apos; does not exist on type &apos;number&apos;.</span><br></pre></td></tr></table></figure>
<p>第二行<code>b</code>被推断成 string，访问它的<code>length</code>属性不会报错。第四行<code>b</code>被推断为<code>number</code>，访问<code>length</code>报错。</p>
<h1 id="对象的类型–接口"><a href="#对象的类型–接口" class="headerlink" title="对象的类型–接口"></a>对象的类型–接口</h1><p>面向对象语言中，接口（Interfaces)是一个很重要的概念，是对行为的抽象，具体如何行动需要由类去实现。<br>TypeScript 中的接口可用于对类的一部分行为进行抽象，也常用于对对象的形状进行描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">  name: &quot;Tom&quot;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。<br>定义的变量比接口少了一些属性是不允许的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tom: Person = &#123;</span><br><span class="line">  name: &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br><span class="line">// error TS2741: Property &apos;age&apos; is missing in type &apos;&#123; name: string; &#125;&apos; but required in type &apos;Person&apos;.</span><br></pre></td></tr></table></figure>
<p>多了一些属性也是不允许的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tom: Person = &#123;</span><br><span class="line">  name: &quot;Tom&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  weight: 10</span><br><span class="line">&#125;;</span><br><span class="line">//error TS2322: Type &apos;&#123; name: string; age: number; weight: number; &#125;&apos; is not assignable to type &apos;Person&apos;.</span><br><span class="line">//  Object literal may only specify known properties, and &apos;weight&apos; does not exist in type &apos;Person&apos;.</span><br></pre></td></tr></table></figure>
<p><strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong></p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>不需要完全匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">  name: &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let jerry: Person = &#123;</span><br><span class="line">  name: &quot;Jerry&quot;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>但是非可选属性必须存在，也不允许添加未定义属性。</strong></p>
<h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>希望接口允许有任意属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line">let jerry: Person = &#123;</span><br><span class="line">  name: &quot;Jerry&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  weight: 50</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意，一旦定义了任意属性，那么确定属性和可选属性的类型必须是它的类型子集</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line">let jerry: Person = &#123;</span><br><span class="line">  name: &quot;Jerry&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  weight: 50</span><br><span class="line">&#125;;</span><br><span class="line">//Property &apos;age&apos; of type &apos;number&apos; is not assignable to string index type &apos;string&apos;.</span><br><span class="line">//Type &apos;&#123; name: string; age: number; gender: string; &#125;&apos; is not assignable to type &apos;Person&apos;.</span><br><span class="line">//Property &apos;age&apos; is incompatible with index signature.</span><br><span class="line">//Type &apos;number&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure>
<p>任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>对象的属性只能在对象创建的时候被赋值，可以使用 readonly 定义只读属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tom: Person = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &quot;Tom&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  gender: &quot;male&quot;</span><br><span class="line">&#125;;</span><br><span class="line">tom.id=345;</span><br><span class="line">// error TS2540: Cannot assign to &apos;id&apos; because it is a read-only property.</span><br></pre></td></tr></table></figure>
<p><strong>注意：只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  readonly id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">  name: &quot;Tom&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  gender: &quot;male&quot;</span><br><span class="line">&#125;;</span><br><span class="line">tom.id = 345;</span><br><span class="line">//error TS2741: Property &apos;id&apos; is missing in type &apos;&#123; name: string; age: number; gender: string; &#125;&apos; but required in type &apos;Person&apos;.</span><br><span class="line">//error TS2540: Cannot assign to &apos;id&apos; because it is a read-only property.</span><br></pre></td></tr></table></figure>
<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h1><ol>
<li>元素类型后面加上[]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list = [1, 2, 3];</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用数组泛型，Array&lt;元素类型&gt;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list:Array&lt;number&gt; = [1,2,3]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用接口表示数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">  [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 2, 3, 4, 5];</span><br></pre></td></tr></table></figure>
<p><code>NumberArray</code>表示：只要索引的类型是数字，值的类型必须为数字<br>虽然接口可以用来描述数组，但是这种结果太复杂，一般不使用。</p>
<ol start="4">
<li>类数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  let args: number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line">//error TS2740: Type &apos;IArguments&apos; is missing the following properties from type &apos;number[]&apos;: pop, push, concat, join, and 15 more.</span><br></pre></td></tr></table></figure>
<p>arguments 实际是一个类数组，不能用普通的数组的方式来描述。而用接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: &#123;</span><br><span class="line">        [index: number]: number;</span><br><span class="line">        length: number;</span><br><span class="line">        callee: Function;</span><br><span class="line">    &#125; = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约定索引的类型和值的类型必须是数字外，也约束了 length 和 callee 两个属性。<br>事实上常用的类数组都有自己的接口定义，如<code>IArguments</code>,<code>NodeList</code>,<code>HTMLCollection</code>等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 IArguments 是 TypeScript 中定义好的类型，它实际上就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IArguments&#123;</span><br><span class="line">    [index: number]: any;</span><br><span class="line">        length: number;</span><br><span class="line">        callee: Function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>any 在数组中的应用<br>一个比较常见的做法是，用 any 表示数组中允许出现任意类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list: any[] = [&quot;string&quot;, 24, &#123; websites: &quot;http://www.ss.com&quot; &#125;];</span><br></pre></td></tr></table></figure>
<h1 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//函数声明</span><br><span class="line">function sum(x,y)&#123;</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br><span class="line">//函数表达式</span><br><span class="line">let muSum = function(x,y)&#123;</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript 中对函数的输入输出进行约束，其中函数声明的类型定义较简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，输入多余或少于要求的参数，是不被允许的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum(1)</span><br><span class="line">//error TS2375: Duplicate number index signature.</span><br><span class="line">//error TS2554: Expected 2 arguments, but got 1.</span><br></pre></td></tr></table></figure>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mySum = function(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述定义，可以编译通过，但是只对等号右边的匿名函数进行类型定义，而等号左边的<code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。<br>如果需要我们手动给 mySum 添加类型，则应该是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mySum:(x:number,y:number) =&gt;number = function(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不要混淆 TypScript 中<code>=&gt;</code>和 ES6 中的<code>=&gt;</code><br>在 TypeScript 的类型定义中，<code>=&gt;</code>用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<h2 id="用接口定义函数的类型"><a href="#用接口定义函数的类型" class="headerlink" title="用接口定义函数的类型"></a>用接口定义函数的类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface SearchFun &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line">let mySearch: SearchFun;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  return source.search(subString) !== 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p><code>?</code>定义可选参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">  if (lastName) &#123;</span><br><span class="line">    return firstName + &quot;&quot; + lastName;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);</span><br><span class="line">let tom1 = buildName(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>注意，可选参数必须在必需产生后面，可选参数后面不能出现必需参数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildName(lastName?: string, firstName: string) &#123;</span><br><span class="line">  if (lastName) &#123;</span><br><span class="line">    return firstName + &quot;&quot; + lastName;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);</span><br><span class="line">let tom1 = buildName(undefined, &quot;Tom&quot;);</span><br><span class="line">// error TS1016: A required parameter cannot follow an optional parameter.</span><br></pre></td></tr></table></figure>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>TypeScript 会将添加了默认值的参数识别为可选参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = &quot;Cat&quot;) &#123;</span><br><span class="line">  if (lastName) &#123;</span><br><span class="line">    return firstName + &quot;&quot; + lastName;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);</span><br><span class="line">let tom1 = buildName(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>此时不受可选参数必须在参数后面的限制了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildName(lastName: string = &quot;Cat&quot;, firstName: string) &#123;</span><br><span class="line">  if (lastName) &#123;</span><br><span class="line">    return firstName + &quot;&quot; + lastName;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);</span><br><span class="line">let tom1 = buildName(undefined, &quot;Tom&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p><code>...rest</code>获取剩余参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">  items.forEach(item =&gt; &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">let c = [];</span><br><span class="line">push(c, 1, 2, 3);</span><br></pre></td></tr></table></figure>
<p><strong>注意，rest 参数只能是最后一个参数</strong></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>允许一个函数接受不同数量或类型的参数时，作出不同的处理。<br>实现一个函数<code>reverse</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">  if (typeof x === &quot;number&quot;) &#123;</span><br><span class="line">    return Number(</span><br><span class="line">      x</span><br><span class="line">        .toString()</span><br><span class="line">        .split(&quot;&quot;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&quot;&quot;)</span><br><span class="line">    );</span><br><span class="line">  &#125; else if (typeof x === &quot;string&quot;) &#123;</span><br><span class="line">    return x</span><br><span class="line">      .split(&quot;&quot;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用重载定义多个 reverse 的函数类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">  if (typeof x === &quot;number&quot;) &#123;</span><br><span class="line">    return Number(</span><br><span class="line">      x</span><br><span class="line">        .toString()</span><br><span class="line">        .split(&quot;&quot;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&quot;&quot;)</span><br><span class="line">    );</span><br><span class="line">  &#125; else if (typeof x === &quot;string&quot;) &#123;</span><br><span class="line">    return x</span><br><span class="line">      .split(&quot;&quot;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</strong></p>
<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><p>使用第三方库的时候，需要引用其声明文件，才能获得对应的代码补全、接口提示等功能。</p>
<h2 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h2><ul>
<li><code>declare var</code> 声明全局变量</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code> 声明全局枚举类型</li>
<li><code>declare namespace</code> 声明（含子属性的）全局对象</li>
<li><code>interface 和 type</code> 声明全局类型</li>
<li><code>export</code> 导出变量</li>
<li><code>export namespace</code> 导出（含有子属性的）对象</li>
<li><code>export default</code> ES6 默认导出</li>
<li><code>export =</code> commonjs 导出模块</li>
<li><code>export as namespace</code> UMD 库声明全局变量</li>
<li><code>declare global</code>扩展全局变量</li>
<li><code>declare module</code>扩展模块</li>
<li><code>///&lt;reference/&gt;</code>三斜线指令</li>
</ul>
<p>例如，ts 无法识别用 script 标签引入的 Jquery，需要声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare var jQuery:(selector:string) =&gt; any</span><br><span class="line">jQuery(&apos;#foo&apos;)</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&apos;#foo&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="将声明语句放到一个单独文件（jQuery-d-ts）中"><a href="#将声明语句放到一个单独文件（jQuery-d-ts）中" class="headerlink" title="将声明语句放到一个单独文件（jQuery.d.ts）中"></a>将声明语句放到一个单独文件（jQuery.d.ts）中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//src/jQuery.d.ts</span><br><span class="line">declare var jQuery:(selector:string) =&gt; any</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/index.ts</span><br><span class="line">jQuery(&apos;#foo&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>注意，声明文件必须以<code>.d.ts</code> 结尾</strong><br>一般 ts 会解析项目中所有的<code>*.ts</code>文件，当然包括<code>.d.ts</code>结尾的文件，所以将<code>jQuery.d.ts</code>放到项目中，其他所有<code>*.ts</code>文件都可以获得<code>jQuery</code>的类型定义<br>项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>假如仍然无法解析，可以检查一下<code>tsconfig.json</code>中的<code>files</code>,<code>include</code>和<code>exclude</code>配置，确保其包含了<code>jQuery.d.ts</code>文件。</p>
<h2 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h2><p>jQuery 声明文件可以直接下载,<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts" target="_blank" rel="noopener">jQuery in DefinitelyTyped</a>)使用。<br>更推荐使用<code>@types</code>统一管理第三方库的声明文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure>
<p>可以使用<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeSearch</a>搜索你要安装的库</p>
<h2 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h2><p>第三方库没有提供声明文件时，需要自己书写声明文件。<br>不同的场景下，声明文件的内容和使用方式不同</p>
<ul>
<li><strong>全局变量</strong>：通过<code>&lt;script&gt;</code>标签引入第三方库。注入全局变量；</li>
<li><strong>npm 包</strong>：通过<code>import foo from &#39;foo</code>导入，符合 ES6 规范；</li>
<li><strong>UDM 库</strong>：既可以通过<code>&lt;script&gt;</code>标签引入，又可以通过<code>import</code>引入；</li>
<li><strong>直接扩展全局变量</strong>：通过<code>&lt;script&gt;</code>标签引入后，改变一个全局变量结构；</li>
<li><strong>在 npm 包或 UMD 库中扩展全局变量</strong>：引用<code>npm包</code>或<code>UMD库</code>后，改变一个全局变量结构；</li>
<li><strong>模块插件</strong>：通过<code>&lt;script&gt;</code>引入后，改变另一个模块的结构。</li>
</ul>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>之前举的例子就是通过<code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 \$ 和 jQuery。<br>如果是以<code>npm install @types/xxx --save-dev</code>安装的第三方库，就不需要配置。如果是将声明文件直接存放在当前项目中，则建议和其他源码一起放在<code>src</code>目录下（或对应源码目录下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>全局变量的声明文件语法：</p>
<ul>
<li><code>declare var</code> 声明全局变量</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code> 声明全局枚举类型</li>
<li><code>declare namespace</code> 声明（含子属性的）全局对象</li>
<li><code>interface 和 type</code> 声明全局类型</li>
</ul>
<h4 id="declare-var"><a href="#declare-var" class="headerlink" title="declare var"></a>declare var</h4><p>还有<code>declare let</code>和<code>declare const</code>，与直接使用<code>let</code>,<code>const</code>没区别：<br>// src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare let jQuery: (selector: string) =&gt; any;</span><br></pre></td></tr></table></figure>
<p>// src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&apos;#foo&apos;);</span><br><span class="line">// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span><br><span class="line">jQuery = function(selector) &#123;</span><br><span class="line">    return document.querySelector(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>let 声明的变量可以更改，const 更改的不能修改<br>// src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const jQuery: (selector: string) =&gt; any;</span><br></pre></td></tr></table></figure>
<p>// src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery = function(selector) &#123;</span><br><span class="line">    return document.querySelector(selector);</span><br><span class="line">&#125;;</span><br><span class="line">//error TS2588: Cannot assign to &apos;jQuery&apos; because it is a constant.</span><br></pre></td></tr></table></figure>
<p><strong>注意：声明语句中只能定义类型，切勿在声明语句中定义具体的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const jQuery = function(selector) &#123;</span><br><span class="line">  return document.querySelector(selector);</span><br><span class="line">&#125;;</span><br><span class="line">//error TS1183: An implementation cannot be declared in ambient contexts.</span><br></pre></td></tr></table></figure>
<h4 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a>declare function</h4><p>用来定义全局函数的类型，jQuery 其实就是一个函数，也可以使用<code>function</code>来定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function jQuery(selector:string):any</span><br></pre></td></tr></table></figure>
<p>在函数类型的声明语句中，函数重载也支持：<br>//src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function jQuery(selector:string):any</span><br><span class="line">declare function jQuery(domReadyCallback:()=&gt;any):any</span><br></pre></td></tr></table></figure>
<p>//src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&apos;#foo&apos;);</span><br><span class="line">jQuery(function()&#123;</span><br><span class="line">    alert(&apos;Dom Ready!&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a>declare class</h4><p>当全局变量是一个类时，使用<code>declare class</code>定义它的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//src/Animal.d.ts</span><br><span class="line">declare class Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string);</span><br><span class="line">    sayHi():string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，declare class 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 sayHi 方法的具体实现则会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/Animal.d.ts</span><br><span class="line"></span><br><span class="line">declare class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string);</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;;</span><br><span class="line">    // ERROR: An implementation cannot be declared in ambient contexts.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a>declare enum</h4><p>使用<code>declare enum</code>定义的枚举类型也称作外部枚举 （Ambient Enums)</p>
<p>仅用于定义类型，而不是具体的值。</p>
<h4 id="declare-namespace"><a href="#declare-namespace" class="headerlink" title="declare namespace"></a>declare namespace</h4><p>命名空间<br>早前 ts 提供了一种模块化方案，使用<code>module</code>关键字表示内部模块，后来为了兼容 ES6 就把<code>module</code>替换为<code>namespcae</code>,现在已经不建议使用 ts 的<code>namespace</code>。<br>declare namespace 还是常用的，用来表示全局变量是一个对象，包含很多子属性。<br>例如 jQuery 对象中的 ajax 方法<br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  function ajax(url: string, settings?: any): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.ajax(&apos;/api/get&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>注意，在<code>declare namespace</code> 内部，直接使用 <code>function ajax</code> 声明函数，而不是使用 <code>declare function ajax</code>。类似里面还可以使用 <code>const</code>,<code>class</code>,<code>enum</code></strong><br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  function ajax(url: string, settings?: any): void;</span><br><span class="line">  const version: number;</span><br><span class="line">  class Event &#123;</span><br><span class="line">    blur(eventType: EventType): void;</span><br><span class="line">  &#125;</span><br><span class="line">  enum EventType &#123;</span><br><span class="line">    CustomClick</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/hello.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const e = new jQuery.Event();</span><br><span class="line">e.blur(jQuery.EventType.CustomClick);</span><br></pre></td></tr></table></figure>
<h5 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h5><p>如果对象拥有深层的层级，则需要用嵌套的<code>namespace</code>来声深层属性的类型<br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  function ajax(url: string, settings?: any): void;</span><br><span class="line">  namespace fn &#123;</span><br><span class="line">    function extend(object: any): void;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">  check: function() &#123;</span><br><span class="line">    return this.each(() =&gt; &#123;</span><br><span class="line">      this.checked = true;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>假如<code>jQuery</code>下面仅有<code>fn</code>这一属性（没有<code>ajax</code>等其他属性或方法），则可以不需要嵌套<code>namespace</code>;<br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery.fn &#123;</span><br><span class="line">    function extend(object:any):void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">   check: function() &#123;</span><br><span class="line">    return this.each(() =&gt; &#123;</span><br><span class="line">      this.checked = true;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="interface-和-type"><a href="#interface-和-type" class="headerlink" title="interface 和 type"></a>interface 和 type</h4><p>直接使用<code>interface</code>或<code>type</code>来声明一个全局的接口或类型。<br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface AjaxSettings &#123;</span><br><span class="line">  method?: &quot;GET&quot; | &quot;POST&quot;;</span><br><span class="line">  data?: any;</span><br><span class="line">&#125;</span><br><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  function ajax(url: string, settings?: AjaxSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他文件也可以使用这个接口或类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let settings: AjaxSettings = &#123;</span><br><span class="line">  method: &quot;POST&quot;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(&quot;/api/get&quot;, settings);</span><br></pre></td></tr></table></figure>
<h5 id="防止命名冲突"><a href="#防止命名冲突" class="headerlink" title="防止命名冲突"></a>防止命名冲突</h5><p>暴露在最外层的<code>interface</code>或<code>type</code>会作为全局类型作用于整个项目，应该尽量减少全局变量或全局类型的数量，故最好将他们放到<code>namespace</code>下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  interface AjaxSettings &#123;</span><br><span class="line">    method?: &quot;GET&quot; | &quot;POST&quot;;</span><br><span class="line">    data?: any;</span><br><span class="line">  &#125;</span><br><span class="line">  function ajax(url: string, settings?: AjaxSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，使用<code>interface</code>的时候，也应该加上<code>jQuery</code>前缀</strong><br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  interface AjaxSettings &#123;</span><br><span class="line">    method?: &quot;GET&quot; | &quot;POST&quot;;</span><br><span class="line">    data?: any;</span><br><span class="line">  &#125;</span><br><span class="line">  function ajax(url: string, settings?: AjaxSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let settings: jQuery.AjaxSettings = &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &apos;foo&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(&apos;/api/post_something&apos;, settings);</span><br></pre></td></tr></table></figure>
<h5 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h5><p>假如 jQuery 既是一个函数，可以直接被调用<code>jQuery(&quot;#foo&quot;)</code>，又是一个对象拥有子属性<code>jQuery.ajax()</code>，那么我们可以组合多个声明语句，他们不冲突的合并起来。<br>src/jQuery.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function jQuery(selector: string): any;</span><br><span class="line">declare namespace jQuery &#123;</span><br><span class="line">  interface AjaxSettings &#123;</span><br><span class="line">    method?: &quot;GET&quot; | &quot;POST&quot;;</span><br><span class="line">    data?: any;</span><br><span class="line">  &#125;</span><br><span class="line">  function ajax(url: string, settings?: AjaxSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/hello.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&quot;#foo&quot;);</span><br><span class="line">let settings: jQuery.AjaxSettings = &#123;</span><br><span class="line">  method: &quot;POST&quot;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.ajax(&quot;/api/get&quot;, settings);</span><br></pre></td></tr></table></figure>
<h3 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a>npm 包</h3><p>ES6:<code>import foo from &#39;foo&#39;</code><br>为 npm 包创建声明文件之前，需要先看它的声明文件是否存在，一般来说，npm 包的声明文件可以存在于两个地方：</p>
<ol>
<li>与该 npm 包绑定在一起。判断依据<code>package.json</code>中有<code>types</code>字段，或者有一个<code>index.d.ts</code>声明文件。这种模式不需要额外安装其他包，最为推荐，所以以后我们自己创建 npm 包的时候，最好将声明文件与 npm 包绑定在一起。</li>
<li>发布到<code>@types</code>里。我们只需要尝试安装一下对应的<code>@types</code>包就知道是否存在该声明文件，安装命令是<code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到<code>@types</code>里</li>
</ol>
<p>假如以上两种方式都没有找到对应的声明文件，那么就需要自己写声明文件，由于是通过<code>import</code>语句导入模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>
<ol>
<li>创建一个<code>node_module/@types/foo/index.d.ts</code>文件，存放<code>foo</code>模块的声明文件。这种方式不需要额外配置，但是<code>node_modules</code>目录不稳定，代码也没有被保存到仓库，无法回溯版本，有被删除的风险，故不太建议用这种方案，一般只做临时测试。</li>
<li>创建一个<code>types</code>目录，专门用来管理自己写的声明文件，将<code>foo</code>的声明文件放到<code>types/foo/index.d.ts</code>中，这种方式需要配置下<code>tsconfig.json</code>中的<code>paths</code>和<code>baseUrl</code>字段<br>目录结构：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<p>tsconfig.json 内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;baseUrl&quot;: &quot;./&quot;,</span><br><span class="line">        &quot;paths&quot;: &#123;</span><br><span class="line">            &quot;*&quot;: [&quot;types/*&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此配置之后，通过 import 导入 foo 的时候，也会去 types 目录下寻找对应的模块的声明文件了。<br><strong>注意，<code>module</code>配置可以有多种选项，不同的选项影响模块的导入导出模式，<code>commonjs</code>是最常用的选项</strong><br>npm 包的声明文件主要有以下几种语法：</p>
<ul>
<li><code>export</code> 导出变量</li>
<li><code>export namespace</code> 导出（含子属性的）对象</li>
<li><code>export default</code> ES6 默认导出</li>
<li><code>export=</code> commonjs 导出模块</li>
</ul>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>npm 包的声明文件与全局变量的声明文件有很大的区别，使用<code>declare</code>不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用<code>export</code>导出，然后在使用<code>import</code>导入，才会应用到这些类型声明。<br><code>export</code>的语法与普通 ts 语法类似，区别在于声明文件中禁止定义具体的实现：<br>src/foo/index.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const name: string;</span><br><span class="line">export function getName(): string;</span><br><span class="line">export class Animal &#123;</span><br><span class="line">  constructor(name: string);</span><br><span class="line">  sayHi(): string;</span><br><span class="line">&#125;</span><br><span class="line">export enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">export interface Options &#123;</span><br><span class="line">  data: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的导入和使用模块应该这样使用<br>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; name, getName, Animal, Directions, Options &#125; from &quot;foo&quot;;</span><br><span class="line">console.log(name);</span><br><span class="line">let myName = getName();</span><br><span class="line">let cat = new Animal(&quot;Tom&quot;);</span><br><span class="line">let directions = [</span><br><span class="line">  Directions.Up,</span><br><span class="line">  Directions.Down,</span><br><span class="line">  Directions.Left,</span><br><span class="line">  Directions.Right</span><br><span class="line">];</span><br><span class="line">let options: Options = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &quot;foo&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="混用-declare-和-export"><a href="#混用-declare-和-export" class="headerlink" title="混用 declare 和 export"></a>混用 declare 和 export</h4><p>先使用<code>declare</code>声明多个变量，然后再使用<code>export</code>一次性导出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare const name: string;</span><br><span class="line">declare function getName(): string;</span><br><span class="line">declare class Animal &#123;</span><br><span class="line">  constructor(name: string);</span><br><span class="line">  sayHi(): string;</span><br><span class="line">&#125;</span><br><span class="line">declare enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">interface Options &#123;</span><br><span class="line">  data: any;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意，与全局变量声明文件类似，<code>interface</code>前不需要<code>declare</code></strong></p>
<h4 id="export-namespace"><a href="#export-namespace" class="headerlink" title="export namespace"></a>export namespace</h4><p>导出一个拥有子属性的对象<br>types/foo/index.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export namespace foo &#123;</span><br><span class="line">  const name: string;</span><br><span class="line">  namespace bar &#123;</span><br><span class="line">    function baz(): string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;foo&#125; from &apos;foo&apos;;</span><br><span class="line">console.log(foo.name)</span><br><span class="line">foo.bar.baz()</span><br></pre></td></tr></table></figure>
<h4 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h4><p>导出默认值<br>types/foo/index.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function foo():string</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import foo from &apos;foo&apos;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p><strong>注意，只有<code>function</code>,<code>class</code>,<code>interface</code>可以直接默认导出，其他变量需要先定义再默认导出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default Directions;</span><br><span class="line">declare enum Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认导出一般放在声明文件的最前面</strong></p>
<h4 id="export-1"><a href="#export-1" class="headerlink" title="export ="></a>export =</h4><p>在<code>commonjs</code>规范中，导出模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//整体导出</span><br><span class="line">module.exports = foo</span><br><span class="line">//单个导出</span><br><span class="line">exports.bar=bar</span><br></pre></td></tr></table></figure>
<p>导入方式</p>
<ol>
<li><code>const ... = require</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//整体导入</span><br><span class="line">const foo = require(&apos;foo&apos;)</span><br><span class="line">//单个导入</span><br><span class="line">const bar = require(&apos;foo&apos;).bar</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>‘import … from ‘<br>整体导入 <code>import * as ... from</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//整体导入</span><br><span class="line">import * as foo from &apos;foo&apos;;</span><br><span class="line">//单个导入</span><br><span class="line">import &#123;bar&#125; from &apos;foo&apos;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>import ... require</code>,<strong>ts 官方推荐</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//整体导入</span><br><span class="line">import foo = require(&apos;foo&apos;) ;</span><br><span class="line">//单个导入</span><br><span class="line">import bar = foo.bar;</span><br></pre></td></tr></table></figure>
<p>对于这种使用 commonjs 规范的库，假如为它写类型声明文件的话，就需要使用<code>export =</code>这种语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export = foo;</span><br><span class="line">declare function foo():string;</span><br><span class="line">declare namespace foo&#123;</span><br><span class="line">    const bar:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例使用<code>export =</code>之后，就不能使用单个导出<code>export {bar}</code>。通过声明合并，使用<code>declare namespace foo</code>来将<code>bar</code>合并到<code>foo</code><br><code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require 和</code> <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用。<br>不推荐使用<code>export =</code>，除非第三方使用 commonjs 规范。推荐使用 ES6 标准的<code>export default</code>和<code>export</code>。</p>
<h3 id="UMD-库"><a href="#UMD-库" class="headerlink" title="UMD 库"></a>UMD 库</h3><p>既可以通过<code>&lt;script&gt;</code>标签引入，又可以通过<code>import</code>导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供一个新语法<code>export as namespace</code>。</p>
<h4 id="export-as-namespace"><a href="#export-as-namespace" class="headerlink" title="export as namespace"></a>export as namespace</h4><p>一般使用<code>export as namespace</code>时,都先有了 npm 包的声明文件，再基于它添加一条<code>export as namespace</code>语句，即可将声明好的一个变量声明为全局变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export as namespace foo;</span><br><span class="line">export = foo;</span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare namespace foo &#123;</span><br><span class="line">  const bar: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以与<code>export default</code>一起使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export as namespace foo;</span><br><span class="line">export default foo;</span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare namespace foo &#123;</span><br><span class="line">  const bar: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接扩展全局变量"><a href="#直接扩展全局变量" class="headerlink" title="直接扩展全局变量"></a>直接扩展全局变量</h3><p>有的第三方库扩展了一个全局变量，可是全局变量的类型却没有相应的更新过来。就会导致 ts 编译出错<br>扩展<code>String</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface String&#123;</span><br><span class="line">    prependHello().string;</span><br><span class="line">&#125;</span><br><span class="line">&apos;foo&apos;.prependHello()</span><br></pre></td></tr></table></figure>
<p>通过声明合并，使用<code>interface String</code>即可给<code>String</code>添加属性或方法<br>也可以使用<code>declare namespace</code>给已有的命名空间添加类型声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// types/jquery-plugin/index.d.ts</span><br><span class="line">​</span><br><span class="line">declare namespace JQuery &#123;</span><br><span class="line">    interface CustomOptions &#123;</span><br><span class="line">        bar: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">interface JQueryStatic &#123;</span><br><span class="line">    foo(options: JQuery.CustomOptions): string;</span><br><span class="line">&#125;</span><br><span class="line">// src/index.ts</span><br><span class="line">​</span><br><span class="line">jQuery.foo(&#123;</span><br><span class="line">    bar: &apos;&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="在-npm-包或-UMD-库中扩展全局变量"><a href="#在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="在 npm 包或 UMD 库中扩展全局变量"></a>在 npm 包或 UMD 库中扩展全局变量</h4><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有<code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>
<h5 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a>declare global</h5><p>可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型。<br>types/foo/index.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface String &#123;</span><br><span class="line">    prependHello(): string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;bar&apos;.prependHello();</span><br></pre></td></tr></table></figure>
<p><strong>注意，此声明文件不需要导出任何东西，但是仍需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件</strong></p>
<h3 id="模块插件"><a href="#模块插件" class="headerlink" title="模块插件"></a>模块插件</h3><p>通过<code>import</code>导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，导致类型不完整。</p>
<h4 id="declare-module"><a href="#declare-module" class="headerlink" title="declare module"></a>declare module</h4><p>如果需要扩展原有模块的话，需要在类型声明文件中引用原有模块，再使用<code>declare module</code>扩展原有模块。<br>types/moment-plugin/index.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line">import * as moment from &apos;moment&apos;;</span><br><span class="line">​</span><br><span class="line">declare module &apos;moment&apos; &#123;</span><br><span class="line">    export function foo(): moment.CalendarKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as moment from &apos;moment&apos;;</span><br><span class="line">import &apos;moment-plugin&apos;;</span><br><span class="line">​</span><br><span class="line">moment.foo();</span><br></pre></td></tr></table></figure>
<p>一次性声明多个模块类型<br>types/foo-bar.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &quot;foo&quot; &#123;</span><br><span class="line">  export interface Foo &#123;</span><br><span class="line">    foo: string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">declare module &quot;bar&quot; &#123;</span><br><span class="line">  export function bar(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Foo &#125; from &apos;foo&apos;;</span><br><span class="line">import * as bar from &apos;bar&apos;;</span><br><span class="line">let f:Foo;</span><br><span class="line">bar.bar()</span><br></pre></td></tr></table></figure>
<h3 id="声明文件中的依赖"><a href="#声明文件中的依赖" class="headerlink" title="声明文件中的依赖"></a>声明文件中的依赖</h3><p>一个声明文件依赖另一个声明文件中的类型，<code>declare module</code>例子中，导入<code>moment</code>，并使用了<code>moment.CalendarKey</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// types/moment-plugin/index.d.ts</span><br><span class="line">​</span><br><span class="line">import * as moment from &apos;moment&apos;;</span><br><span class="line">​</span><br><span class="line">declare module &apos;moment&apos; &#123;</span><br><span class="line">    export function foo(): moment.CalendarKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以在声明文件中通过<code>import</code>导入另一个声明文件，还可以使用三斜线指令导入</p>
<h4 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h4><p>现在推荐使用 ES6 来实现模块之间的依赖，不过声明模块之间的依赖关系还需要使用三斜线指令</p>
<ul>
<li><p>当我们在书写一个全局变量的声明文件时<br>在全局变量的声明文件中，不允许出现<code>import</code>，<code>export</code>关键字，一旦出现，文件就会被视为一个 npm 包或 UMD 库，如果全局变量声明文件需要引用另一个库，就必须使用三斜线指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;reference types=&quot;jquery&quot; /&gt;</span><br><span class="line">declare function foo(options: JQuery.AjaxSettings): string;</span><br></pre></td></tr></table></figure>
<p>语法 <code>///</code>后面使用 xml 格式添加对<code>jquery</code>类型的依赖，这样就可以在声明文件中使用<code>JQuery.AjaxSettings</code>类型<br><strong>注意，三斜线指令必须放在文件的最顶端，三斜线指令的最前面值允许出现单行或多行注释</strong></p>
</li>
<li><p>当我们需要依赖一个全局变量的声明文件时<br>types/node-plugin/index.d.ts</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///&lt;reference types=&apos;node&apos;/&gt;</span><br><span class="line">export function foo(p: NodeJS.Process): string;</span><br></pre></td></tr></table></figure>
<p>src/index.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;foo &#125; from &apos;node-plugin&apos;;</span><br><span class="line">foo(global.process)</span><br></pre></td></tr></table></figure>
<p>由于引入的 node 中的类型都是全局变量的类型，它们是没有办法通过 import 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>
<h4 id="拆分声明文件"><a href="#拆分声明文件" class="headerlink" title="拆分声明文件"></a>拆分声明文件</h4><p>当全局声明文件太大时，可以拆分为多个文件，然后在一个入口文件中将他们一一引入，提高代码的可维护性。<br><code>jquery</code>的声明文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line">​</span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure>
<p>其中用到了<code>types</code>和<code>path</code>两种不同参数。</p>
<ul>
<li>types:用于声明对另一个库的依赖，</li>
<li>path:用于声明对另一个文件的依赖</li>
</ul>
<h3 id="自动生成声明文件"><a href="#自动生成声明文件" class="headerlink" title="自动生成声明文件"></a>自动生成声明文件</h3><p>如果库的源码本身就由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加<code>declaration</code>选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;outDir&quot;: &quot;lib&quot;,</span><br><span class="line">        &quot;declaration&quot;: true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>outDir</code>，将 ts 文件编译后的结果输出的到 lib 目录下</li>
<li><code>declaration</code>，执行编译的时候，ts 文件不仅生成<code>.js</code>文件同时自动生成<code>.d.ts</code>声明文件，也会输出到<code>lib</code>目录下<br>其他配置</li>
<li><code>declarationDir</code>,设置生成<code>.d.ts</code>文件的目录</li>
<li><code>declarationMap</code>,对每个<code>.d.ts</code>文件，生成对应的<code>.d.ts.map</code>文件</li>
<li><code>emitDeclarationOnly</code>,仅生成’.d.ts’文件，不生成<code>.js</code>文件</li>
</ul>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><h2 id="ECMAScript-的内置对象"><a href="#ECMAScript-的内置对象" class="headerlink" title="ECMAScript 的内置对象"></a>ECMAScript 的内置对象</h2><p>根据 js 的内置对象定义 ts 变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let aa: Boolean = new Boolean(1);</span><br><span class="line">let bb: Error = new Error(&quot;Error occurred&quot;);</span><br><span class="line">let cc: Date = new Date();</span><br><span class="line">let dd: RegExp = /[a-z]/;</span><br></pre></td></tr></table></figure>
<h2 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let body: HTMLElement = document.body;</span><br><span class="line">let allDiv: NodeList = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">document.addEventListener(&quot;click&quot;, function(e: MouseEvent) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-核心库的定义文件"><a href="#TypeScript-核心库的定义文件" class="headerlink" title="TypeScript 核心库的定义文件"></a>TypeScript 核心库的定义文件</h2><p>定义了所有了浏览器环境需要用到的类型，并且预置在 TypeScript 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.pow(10, &quot;2&quot;);</span><br><span class="line">//error TS2345: Argument of type &apos;&quot;2&quot;&apos; is not assignable to parameter of type &apos;number&apos;.</span><br></pre></td></tr></table></figure>
<p>Math.pow 必须接受两个 number 类型的参数。Math.pow 的类型定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Math &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the value of a base expression taken to a specified power.</span><br><span class="line">     * @param x The base value of the expression.</span><br><span class="line">     * @param y The exponent value of the expression.</span><br><span class="line">     */</span><br><span class="line">    pow(x: number, y: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOM 的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e) &#123;</span><br><span class="line">    console.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,17): error TS2339: Property &apos;targetCurrent&apos; does not exist on type &apos;MouseEvent&apos;.</span><br></pre></td></tr></table></figure>
<p>addEventListener 方法是在 TypeScript 核心库中定义的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：TypeScript 核心库的定义不包含 Node.js 部分</strong></p>
<h2 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h2><p>node.js 不是内置对象的一部分，如果要用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript入门</title>
    <url>/2019/11/09/TypeScript%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>TypeScript 入门<br>参考：<a href="https://ts.xcatliu.com/introduction/what-is-typescript" target="_blank" rel="noopener">https://ts.xcatliu.com/introduction/what-is-typescript</a><br>参考：<a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">https://ts.xcatliu.com/</a></p>
<a id="more"></a>
<h1 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h1><p>TypeScript 是 JavaScript 的类型超集，主要提供了类型系统和对 ES6 的支持，它可以编译成纯 JS,编译出来的 JS 代码可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。 ###优点</p>
<ul>
<li>增强代码的的可读性和可维护性<ul>
<li>类型系统是最好的文档，大部分函数通过查看参数类型的定义就知道如何使用</li>
<li>可以在编译阶段发现错误</li>
<li>增强了编译器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>
</ul>
</li>
<li>非常包容<ul>
<li>TypeScript 是 JavaScript 的超集，将.js 文件直接重命名为.ts 即可</li>
<li>即使不显示的定义类型，也能够自动做出类型推论（没有明确定义类型时，TS 会根据值推测出一个类型）</li>
<li>可以定义从简答到复杂的几乎一切类型</li>
<li>即使 TS 编译报错也能生成 JS 文件</li>
<li>兼容第三方库，即使第三方库不是 TS 写的，也可以编写单独的类型文件功 TS 读取</li>
</ul>
</li>
<li>拥有活跃的社区<ul>
<li>大部分第三方库都提供给 TS 的类型定义文件</li>
<li>Google 开发的 Angular2 就是 TS 编写的</li>
<li>TS 支持 ES6 规范，也支持部分 ESNext 草案的规范</li>
</ul>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等</li>
<li>短期内增加开发成本，需要多些一下类型的定义，不过对于需要长期维护的项目，TS 能够减少其维护成本</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>编译 TS 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p><strong>约定使用 TypeScript 编写的文件以.ts 为后缀，用 TypeScript 编写的 React 时，以.tsx 为后缀。</strong></p>
<h1 id="Hello-TypeScript"><a href="#Hello-TypeScript" class="headerlink" title="Hello TypeScript"></a>Hello TypeScript</h1><p>hello.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function sayHello(person: string)&#123;</span><br><span class="line">    return &apos;Hello,&apos; + person</span><br><span class="line">&#125;</span><br><span class="line">let user = &apos;Tom&apos;;</span><br><span class="line">console.log(sayHello(user))</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>会生成 hello.js 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &apos;Hello,&apos; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user = &apos;Tom&apos;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>TypeScript 中，使用 <code>:</code>指定变量的类型，<code>:</code>前后有没有空格都可以。</p>
<p><strong>TypeScript 只会进行静态检查，如果发现错误编译的时候就会报错。</strong></p>
<p>上面的例子中做如下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(person: string)&#123;</span><br><span class="line">    return &apos;Hello,&apos; + person</span><br><span class="line">&#125;</span><br><span class="line">let user = [1,2,3];</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>编译的时候会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello.ts:6:22 - error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>
<p>但是还是会生成 js 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &quot;Hello, &quot; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user = [0, 1, 2];</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p><strong>如果想要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。tsconfig.json 参考<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">官方手册</a></strong></p>
<p>编译项目使用 tsconfig.json 的两种方式：</p>
<ul>
<li>不显示指定<code>tsconfig.json</code>，此时，编译器会从当前路径开始寻找<code>tsconfig.json</code>文件，如果没有找到，则继续往上级路径逐步寻找，直到找到为止；</li>
<li><p>通过–project(-p)指定一个包含 tsconfig.json 的路径，或者包含配置信息的<code>.json</code>文件路径。<br><strong>注意，<code>tsc</code>的命令行选项具有优先级，会覆盖<code>tsconfig.json</code>中的同名选项</strong><br>compilerOptions 编译选项配置<br>指定带编译的文件</p>
</li>
<li><p>files</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123; //配置编译选项</span><br><span class="line">        &quot;noEmitOnError&quot;: true ,//编译出错时不生成js文件</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files&quot;: [ //指定带编译的文件，特指入口文件，不需要入口文件的依赖文件</span><br><span class="line">        &quot;hello.ts&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>files 属性是一个数组，数组元素可以是相对文件路径和绝对文件路径</p>
<ul>
<li>include 和 exclude</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123; //配置编译选项</span><br><span class="line">        &quot;noEmitOnError&quot;: true ,//编译出错时不生成js文件</span><br><span class="line">    &#125;,</span><br><span class="line">     &quot;include&quot;:[</span><br><span class="line">         &quot;src/**/*&quot;</span><br><span class="line">     ],</span><br><span class="line">     &quot;exclude&quot;:[</span><br><span class="line">         &quot;node_modules&quot;,</span><br><span class="line">         &quot;**/*.spec.ts&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>include 和 exclude 属性也是一个数组，但数组是类似<code>glob</code>的文件模式，支持的通配符<code>glob</code>:</p>
<ul>
<li><code>*</code>:匹配 0 或多个字符（注意：不包含路径分隔符）</li>
<li><code>?</code>:匹配任意单个字符（注意：不包含路径分隔符）</li>
<li><code>**/</code>:递归匹配任何子路径</li>
</ul>
<p>TS 文件指拓展名为<code>.ts</code>,<code>.tsx</code>,<code>.d.ts</code>的文件。<br>如果开启了<code>allowJs</code>选项，那么<code>.js</code>和<code>.jsx</code>文件也属于 ts 文件。<br>如果同时设置了 files 和 include 编译器会把两者包含的文件都引入。<br>如果同时没有设置 files 和 include，会排除 exclude 包含的文件，其他文件都编译。<br>任何被 files 或 include 引入的文件依赖会被自动引入。</p>
<h2 id="编译选项（compilerOptions）"><a href="#编译选项（compilerOptions）" class="headerlink" title="编译选项（compilerOptions）"></a>编译选项（compilerOptions）</h2><table>
<thead>
<tr>
<th>选项字段</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allowJs</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>是否运行编译 <code>JS</code> 文件</td>
</tr>
<tr>
<td>`checkJs</td>
<td>boolean`</td>
<td><code>false</code></td>
<td>报告 JS 文件中存在的类型错误，需要配合<code>allowJs</code>使用</td>
</tr>
<tr>
<td>`declaration</td>
<td>boolean`</td>
<td><code>false</code></td>
<td>生成对应的<code>.d.ts</code>文件</td>
</tr>
<tr>
<td><code>declarationDir</code></td>
<td><code>stringv</code></td>
<td>-</td>
<td>生成的<code>.d.ts</code>文件存放路径，默认与<code>.ts</code>文件相同</td>
</tr>
<tr>
<td><code>experimentalDecorators</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>启用实验功能-ES 装饰器</td>
</tr>
<tr>
<td><code>jsx</code></td>
<td><code>string</code></td>
<td><code>Preserve</code></td>
<td>在<code>.tsx</code>中支持 <code>JSX:React</code>、<code>Preserve</code>、<code>React-native</code></td>
</tr>
<tr>
<td><code>jsxFactory</code></td>
<td><code>string</code></td>
<td><code>React.createElement</code></td>
<td><code>jsx</code> 设置 <code>React</code> 时使用的创建函数</td>
</tr>
<tr>
<td><code>lib</code></td>
<td><code>string[]</code></td>
<td>-</td>
<td>编译时引入 ES 功能库，包含<code>es5</code>、<code>es6</code>、<code>es7</code>、<code>dom</code>等。如未设置，则默认为：<code>target</code> 为<code>es5</code>时：<code>[&quot;dom&quot;,&quot;es5&quot;,&quot;scripthost&quot;]</code>，<code>target</code>为<code>es6</code>时：<code>[&quot;dom&quot;,&quot;es6&quot;,&quot;dom.iterable&quot;,&quot;scripthost&quot;]</code></td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td>target === “es3” or “es5”?”commonjs”:”es6”</td>
<td>生成的模块形式：<code>none</code>、<code>commonjs</code>、<code>amd</code>、 <code>system</code>、 <code>umd</code>、<code>es6</code>、<code>es2015</code>或<code>esnext</code>，只有<code>amd</code>和<code>system</code>能和<code>outFile</code>一起使用<code>target</code>为<code>es5</code>或更低时可用<code>es6</code>和<code>es2015</code></td>
</tr>
<tr>
<td><code>moduleResolution</code></td>
<td><code>string</code></td>
<td><code>module === &quot;amd&quot; or &quot;system&quot; or &quot;es6&quot; ? &quot;classic&quot;:&quot;node&quot;</code></td>
<td>模块解析方式</td>
</tr>
<tr>
<td><code>noImplicitAny</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>存在隐士<code>any</code>是抛错</td>
</tr>
<tr>
<td><code>noImplicitReturns</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>不存在<code>return</code>时抛错</td>
</tr>
<tr>
<td><code>noImplicitThis</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td><code>this</code>可能为<code>any</code>时抛错</td>
</tr>
<tr>
<td><code>outDir</code></td>
<td><code>string</code></td>
<td>-</td>
<td>编译生成的文件存放路径默认与<code>.ts</code>文件相同</td>
</tr>
<tr>
<td><code>sourceMap</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>生成<code>.map</code>文件</td>
</tr>
<tr>
<td><code>target</code></td>
<td><code>string</code></td>
<td><code>es3</code></td>
<td>生成<code>.js</code>文件版本</td>
</tr>
<tr>
<td><code>strictNullChecks</code></td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>是否禁止 null 和 undefined 赋值给除他们自身和 void 以外类型的变量</td>
</tr>
</tbody>
</table>
<p>附件：<a href="http://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">官方完整的编译选项列表</a></p>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
  </entry>
  <entry>
    <title>前端必备nginx知识</title>
    <url>/2019/11/06/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87nginx%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>前端开发者必备的 nginx 知识</p>
<a id="more"></a>
<h1 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>为客户端服务，客户端可以通过正向代理访问它本身无法访问的服务器资源。<br>对客户端是透明的，对服务器端是非透明的，即服务器端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 ##反向代理<br>指代理服务器接收 Internet 上的连接请求，然后将连接请求转发到内部网络上的服务器，并将从服务器上得到的结果返回到 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务端。<br>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<h1 id="基本配置-配置结构"><a href="#基本配置-配置结构" class="headerlink" title="基本配置 ##配置结构"></a>基本配置 ##配置结构</h1><ul>
<li><p>nginx.conf</p>
<ul>
<li>events</li>
<li>http<ul>
<li>upstream</li>
<li>server<ul>
<li>location</li>
<li>location</li>
<li>…</li>
</ul>
</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p>main：全局配置对全局生效</p>
</li>
<li>events：配置影响 nginx 服务器或用户额网络连接</li>
<li>http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</li>
<li>server：配置虚拟机相关参数，一个 http 中可以有多个 server</li>
<li>location：配置请求的路由，以及各种页面的处理情况</li>
<li>upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><table>
<thead>
<tr>
<th>变量名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>\$host</td>
<td>请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名</td>
</tr>
<tr>
<td>\$request_method</td>
<td>客户端请求类型，如 GET、POST</td>
</tr>
<tr>
<td>\$remote_addr</td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td>\$args</td>
<td>请求中的参数</td>
</tr>
<tr>
<td>\$content_length</td>
<td>请求头中的 Content-length 字段</td>
</tr>
<tr>
<td>\$http_user_agent</td>
<td>客户端 agent 信息</td>
</tr>
<tr>
<td>\$http_cookie</td>
<td>客户端 cookie 信息</td>
</tr>
<tr>
<td>\$remote_addr</td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td>\$remote_port</td>
<td>客户端的端口</td>
</tr>
<tr>
<td>\$server_protocol</td>
<td>请求使用的协议，如 HTTP/1.0、HTTP/1.1</td>
</tr>
<tr>
<td>\$server_addr</td>
<td>服务器地址</td>
</tr>
<tr>
<td>\$server_name</td>
<td>服务器名称</td>
</tr>
<tr>
<td>\$server_port</td>
<td>服务器的端口号</td>
</tr>
</tbody>
</table>
<h2 id="解决跨域-原理"><a href="#解决跨域-原理" class="headerlink" title="解决跨域 ###原理"></a>解决跨域 ###原理</h2><p>例如：</p>
<ul>
<li>前端 server 的域名为：fe.server.com</li>
<li>后端服务器的域名为：dev.server.com</li>
</ul>
<p>用 fe.server.com 访问后端服务器，会出现跨域。<br>启动一个 nginx 服务器，将 server_name 设为 fe.server.com，然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com<br>电脑 ngix 安装目录下的 nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以完美绕过浏览器的同源策略：fe.server.com 访问 nginx 的 fe.server.com 属于同源访问，而 nginx 对服务端转发的请求不会触发浏览器的同源策略。</p>
<h3 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h3><p>根据状态码过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br><span class="line">     location = /50x.html &#123;</span><br><span class="line">         root   /root/static/html;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>根据 URL 名称过滤，精准匹配 URL，不匹配的 URL 全部重定向到主页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^.*$ / index.html redirect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据请求类型过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if($request_method !~ ^(GET|POST|HEAD)$)&#123;</span><br><span class="line">    return 403</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行"></a>nginx 命令行</h1><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>关闭 nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br><span class="line">kill -QUIT 57192</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/06/前端必备nginx知识/img1.png" alt="常用命令"><br>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>前端的网络请求方式</title>
    <url>/2019/10/30/%E5%89%8D%E7%AB%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>网络请求 跨域处理方式<br><a href="https://mp.weixin.qq.com/s/zSB7X2ka6GtxtupUtal7ig" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zSB7X2ka6GtxtupUtal7ig</a></p>
<a id="more"></a>
<h2 id="AJAX-请求"><a href="#AJAX-请求" class="headerlink" title="AJAX 请求"></a>AJAX 请求</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    //请求参数</span><br><span class="line">    postData = &#123;</span><br><span class="line">        &apos;name1&apos;: &apos;value1&apos;,</span><br><span class="line">        &apos;name2&apos;: &apos;value2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(&apos;POST&apos;, &apos;http://localhost:8000/login&apos;, true);</span><br><span class="line"></span><br><span class="line">    //get</span><br><span class="line">    postData = (function (value) &#123;</span><br><span class="line">        let oStr = &apos;&apos;;</span><br><span class="line">        for (var key in value) &#123;</span><br><span class="line">            oStr += key + &apos;=&apos; + value[key] + &apos;&amp;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return oStr</span><br><span class="line">    &#125;)(postData)</span><br><span class="line">    url=url+&apos;?&apos;+posData;</span><br><span class="line">    xhr.open(&apos;GET&apos;, url.replace(/\?$/g,&apos;), true);</span><br><span class="line">    //  接收返回值</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.readyState === 4 ) &#123;</span><br><span class="line">            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123;</span><br><span class="line">                console.log(xhr.responseText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(postData)</span><br><span class="line">    //设置请求头</span><br><span class="line">    xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">    //异常处理</span><br><span class="line">    xhr.onerror = function () &#123;</span><br><span class="line">        console.log(&apos;Network request failed!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    //跨域携带cookie</span><br><span class="line">    xhr.withCredentials = true;</span><br><span class="line">    //发出请求</span><br><span class="line">    xhr.send(postData)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>open</strong></p>
<p>用于初始化一个请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.open(method, url, async)</span><br></pre></td></tr></table></figure>
<ul>
<li>method:请求方法，get/post</li>
<li>url:请求的 url</li>
<li>async:是否为异步请求。true/false</li>
</ul>
<p><strong>send</strong></p>
<p>用于发送 HTTP 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.send(param)</span><br></pre></td></tr></table></figure>
<ul>
<li>param:请求参数可以是<code>string</code>、<code>Blob</code> 等类型</li>
</ul>
<p><strong>abort</strong><br>如果该请求已被发出，<code>abort()</code> 方法将终止该请求。当一个请求被终止，它的 <code>readyState</code> 属性将被置为 <code>0（ UNSENT )</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.abort()</span><br></pre></td></tr></table></figure>
<p><strong>setRequestHeader</strong><br>用于设置 HTTP 请求头，此方法必须在 <code>open()</code>方法和 <code>send()</code>之间调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(header, value)</span><br></pre></td></tr></table></figure>
<p><strong>getResponseHeader</strong><br>用于获取 HTTP 返回头，如果在返回头中有多个一样的名称，那么 返回值就会用逗号和空格将 值分隔的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var header = xhr.getResponseHeader(name)</span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>readyState</strong><br>用来标识当前 XMLHttpRequest 对象所处的状态，XMLHttpRequest 对象总是位于下列状态中的一个：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>UNSENT</td>
<td>代理被创建，但尚未调用 open()方法</td>
</tr>
<tr>
<td>1</td>
<td>OPENED</td>
<td>open 方法已经被调用</td>
</tr>
<tr>
<td>2</td>
<td>HEADERS_RECEIVED</td>
<td>send()方法已经被调用，并且头部和状态已经可获得</td>
</tr>
<tr>
<td>3</td>
<td>LOADING</td>
<td>下载中，responseText 属性已经包含部分数</td>
</tr>
<tr>
<td>4</td>
<td>DONE</td>
<td>下载操作已完成</td>
</tr>
</tbody>
</table>
<p><strong>status</strong><br>表示 http 请求的状态，初始值为 0。如果服务器没有现实指定状态码，那么 status 将被设置为默认值，即 200。</p>
<p><strong>responseType</strong><br>表示响应的数据类型，并允许我们手动设置，如果结果为空，默认为 text 类型<br>|值|描述|<br>|-|-|<br>|””|将 responseType 设置空字符串与设置为 text 相同，是默认类型|<br>|”arraybuffer”|response 是一个包含二进制数据的 JavaScriptArrayBuffer|<br>|”blob”|response 是一个包含二进制数据的 Blob 对象|<br>|”document”|responses 是一个 HTML Document 或者 XML XMLDocument，取决于接收到数据的 MIME 类型|<br>|”json”|response 是一个 JavaScript 对象，这个对象时通过将接收到的数据类型为 JSON 解析|<br>|”text”|response 是包含在 DOMString 对象中的文本|</p>
<p><strong>response</strong><br>返回响应的正文，返回的类型由上面的 responseType 决定</p>
<p><strong>withCredentials</strong><br>ajax 请求默认会携带同源请求的 cookie，而跨域请求则不会携带 cookie，设置 xhr 的 withCredentials 的属性为 true 将允许携带跨域 cookie</p>
<h3 id="事件回调"><a href="#事件回调" class="headerlink" title="事件回调"></a>事件回调</h3><p><strong>onreadystatechange</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = callback</span><br></pre></td></tr></table></figure>
<p>当 readyState 属性发生变化时，callback 会被触发<br><strong>onloadstart</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">xhr.onloadstart = callback</span><br></pre></td></tr></table></figure>
<p>在 ajax 请求发送之前（readyState==1 后，readyState==2 前），callback 会被触发<br><strong>onprogress</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onprogress = function(event)&#123;</span><br><span class="line">    console.log(event.loaded/event.total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调函数可以获取资源总大小 total，已经加装的资源大小 loaded，用着两个值可以计算加载进度。<br><strong>onload</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onload = callback</span><br></pre></td></tr></table></figure>
<p>当一个资源及其依赖已完成加载时，将触发 callback，通常我们会在 onload 事件中处理返回值。 ##异常处理</p>
<p><strong>onerror</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onerror = callback</span><br></pre></td></tr></table></figure>
<p>ajax 资源加载失败触发 callback</p>
<p><strong>ontimeout</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.ontimeout = callback</span><br></pre></td></tr></table></figure>
<p>当进度由于预定时间到期而终止时，会触发 callback，超时时间可使用 timeout 属性进行设置。</p>
<h3 id="JQuery-对-Ajax-的封装"><a href="#JQuery-对-Ajax-的封装" class="headerlink" title="JQuery 对 Ajax 的封装"></a>JQuery 对 Ajax 的封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;http://localhost:8000/login&apos;,//请求接口</span><br><span class="line">    type: &apos;POST&apos;,//请求类型</span><br><span class="line">    dataType: &apos;json&apos;, //设置返回值类型</span><br><span class="line">    contentType: &apos;application/json&apos;, //设置请求参数类型</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;, //设置请求头</span><br><span class="line">    xhrFields: &#123;</span><br><span class="line">        widthCredentials: true</span><br><span class="line">    &#125;, //跨域携带cookie</span><br><span class="line">    data: JSON.stringify(&#123;</span><br><span class="line">        a: [&#123;</span><br><span class="line">            b: 1,</span><br><span class="line">            a: 1</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;),</span><br><span class="line">    error: function (xhr, status) &#123; //错误处理</span><br><span class="line">        console.log(xhr, status);</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (data, status) &#123; //获取结果</span><br><span class="line">        console.log(data, status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>url：请地址和接口</li>
<li>type：请求类型。String。”POST”/“GET”，默认为”GET”</li>
<li>timeout：Number 设置请求超时时间（毫秒），此设置将覆盖全局设置。</li>
<li>success：Function，请求成功的回调函数</li>
<li>error：Function，请求失败的回调函数</li>
<li>jsonp：String，jsonp:’callback’</li>
<li>jsonpCallback: String，函数名”onJsonPLoad”,</li>
<li><p>dataType：</p>
<ul>
<li>‘xml’：返回 XML 文档，可用 JQuery 处理</li>
<li>‘html’：返回纯文本 HTML 信息，包含的 script 标签会在插入 dom 时执行</li>
<li>‘script’：返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了’cache’参数。注意：在远程请求时（不同域下），所有 POST 请求都将转为 GET 请求，（因为将使用 DOM 的 script 标签来加载）</li>
<li>‘json’：返回 JSON 数据</li>
<li>‘jsonp’：JSONP 格式，使用 JSONP 形式调用函数时如”myurl?callback=?”，jQuery 将自动替换?为正确的函数名，以执行回调函数。</li>
<li>‘text’：返回纯文字字符串</li>
</ul>
</li>
<li><p>data：类型 String 使用 JSON.stringify()转码</p>
</li>
<li>complete：Function，请求完成以后回调函数，请求成功或失败之后均会调用</li>
<li>async：Boolean，默认为 true，异步请求，如需发送同步请求，设为 false</li>
<li>contentType：String，默认’application/x-www-form-urlencoded’。发送信息至服务器时内容编码的类型。<br>一般键值对的形式，默认的编码方法可以处理，如 data:{a:1, b:2, c:3}<br>但是 json 对象存在对象嵌套数组，数组包含对象，上面的编码方式就无法处理，需要将参数利用 JSON.stringify()处理，data:JSON.stringify({a:1, [{b:2, c:3}]})</li>
</ul>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  const options = &#123;</span><br><span class="line">    method: &apos;POST&apos;, //请求方法</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    &#125;, //设置请求头</span><br><span class="line">    body: JSON.stringify(&#123;</span><br><span class="line">        name: &apos;123&apos;</span><br><span class="line">    &#125;),//请求参数</span><br><span class="line"></span><br><span class="line">    credentials: &apos;include&apos;, //cookie设置</span><br><span class="line">    mode: &apos;cors&apos;, //跨域</span><br><span class="line">&#125;</span><br><span class="line">fetch(&apos;http://localhost:8000/login1&apos;, options)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        return res.json()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(myJson =&gt; &#123;</span><br><span class="line">        console.log(myJson)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mode:是否跨域</p>
<ul>
<li>cors：允许发送跨域请求，服务器需要设置 cors 响应头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8888&quot;);</span><br><span class="line">//或</span><br><span class="line">res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>no-cors：常用于在跨域不带 CORS 场景下， 此时请求发出并且会有响应，但是此时 type 为“opaque”， status 为 0 ，js 获取不到返回数据。</li>
<li>same-origin：在同域下请求</li>
<li>cors-with-forced-preflight：在请求前进行 preflight 检查</li>
</ul>
</li>
<li><p>credentials：请求是否需要携带 cookie</p>
<ul>
<li>omit:不携带认证凭证 Cookie</li>
<li>same-origin:在同源站点下包含凭证</li>
<li>include:对所有网址包含认证凭证</li>
</ul>
</li>
</ul>
<ol>
<li>跨域请求，不携带 cookie</li>
</ol>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const options = &#123;</span><br><span class="line">    method: &apos;POST&apos;, //请求参数</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;content-Type&apos;: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">    &#125;, //设置请求头</span><br><span class="line">    body: JSON.stringify(&#123;</span><br><span class="line">        name: &apos;123&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    credentials: &apos;omit&apos;, //或same-origin</span><br><span class="line">    mode: &apos;cors&apos;, //跨域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(&apos;http://localhost:8000/login1&apos;, options)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        return res.json()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(myJson =&gt; &#123;</span><br><span class="line">        console.log(myJson)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>node 服务器端配置<br>响应头设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//处理请求跨域</span><br><span class="line">server.all(&quot;*&quot;, function(req, res, next) &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8888&quot;);//可以是*，表示通配符匹配全部地址，或者是,连接的多个地址</span><br><span class="line">  res.setHeader(</span><br><span class="line">    &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    &quot;Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;</span><br><span class="line">  );//响应头</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>客户端请求允许携带 cookie</li>
</ol>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> const options = &#123;</span><br><span class="line">    method: &apos;POST&apos;, //请求参数</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;content-Type&apos;: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">    &#125;, //设置请求头</span><br><span class="line">    body: JSON.stringify(&#123;</span><br><span class="line">        name: &apos;123&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    credentials: &apos;include&apos;, //允许跨域cookie</span><br><span class="line">    mode: &apos;cors&apos;, //跨域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(&apos;http://localhost:8000/login1&apos;, options)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        return res.json()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(myJson =&gt; &#123;</span><br><span class="line">        console.log(myJson)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//处理请求跨域</span><br><span class="line">server.all(&quot;*&quot;, function(req, res, next) &#123;</span><br><span class="line">res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8888&quot;);//必须是地址，不能写通配符</span><br><span class="line">res.setHeader(</span><br><span class="line">  &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">  &quot;Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;</span><br><span class="line">);</span><br><span class="line">res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">res.setHeader(&quot;Access-Control-Allow-Credentials&quot;, true);//表示是否允许发送Cookie</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>获取请求的 cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req.headers.cookie</span><br></pre></td></tr></table></figure>
<p><code>Fetch</code> 执行完毕后，不能直接在 <code>response</code> 中获取到返回值必须调用 <code>text()、json()、blob()、formData()</code>函数才能获取返回值。每次调用<code>text()、json()</code>等函数后会将 bodyUsed 变量变为 true，用来标识返回值已经读取过了，下一次再读取直接抛出 TypeError(‘Already read’)。<br>fetch 是一个非常底层的 API，它的问题：</p>
<ul>
<li>不能直接传递 JavaScript 对象作为参数</li>
<li>需要自己判断返回值类型，并执行响应获取返回值的方法</li>
<li>获取返回值方法只能调用一次，不能调用多次</li>
<li>无法正常捕获异常</li>
<li>老版浏览器默认不会携带 cookie</li>
<li>不支持 jsonp</li>
</ul>
<h3 id="对-fetch-的封装"><a href="#对-fetch-的封装" class="headerlink" title="对 fetch 的封装"></a>对 fetch 的封装</h3><h3 id="请求参数的处理"><a href="#请求参数的处理" class="headerlink" title="请求参数的处理"></a>请求参数的处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function stringify(url, data) &#123;</span><br><span class="line">    var dataString = url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;;</span><br><span class="line">    for (var key in data) &#123;</span><br><span class="line">        dataString += key + &apos;=&apos; + data[key] + &apos;&amp;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return dataString;</span><br><span class="line">&#125;</span><br><span class="line">if (request.formData) &#123;</span><br><span class="line">    request.body = request.data;</span><br><span class="line">&#125; else if (/^get$/i.test(request.method)) &#123;</span><br><span class="line">    request.url = `$&#123;request.url&#125;$&#123;stringify(request.url, request.data)&#125;`;</span><br><span class="line">&#125; else if (request.form) &#123; //表单提交</span><br><span class="line">    request.headers = &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-urlencoded;charset=UTF-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    request.body = stringify(request.data)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    request.headers = &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    request.body = JSON.stringify(request.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.then(response =&gt; &#123;</span><br><span class="line">console.log(response)</span><br><span class="line">if (response.ok) &#123;</span><br><span class="line">    return Promise.resolve(response);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    const error = new Error(`请求失败！状态码：$&#123;response.status&#125;,失败信息：$&#123;response</span><br><span class="line">.statusText&#125;`)</span><br><span class="line">    error.response = response;</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .then(response =&gt; &#123;</span><br><span class="line">    let contentType = response.headers.get(&apos;content-type&apos;);</span><br><span class="line">    if (contentType.includes(&apos;application/json&apos;)) &#123;</span><br><span class="line">        return response.json()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return response.text()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
  </entry>
  <entry>
    <title>Node 加密解密</title>
    <url>/2019/10/29/Node%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>使用 Node 自带的 crypto 模块进行加密和解密</p>
<a id="more"></a>
<ol>
<li><p>加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>@description:加密</li>
<li>@param algorithm 加密算法</li>
<li>@param key 秘钥</li>
<li>@param iv 偏移量</li>
<li>@return:字符串<br>*/<br>function genSign(algorithm, key, iv) {<br>let sign = “”;<br>const cipher = crypto.createCipheriv(“aes-128-cbc”, key, iv);<br>sign += cipher.update(algorithm, “utf8”, “hex”);<br>sign += cipher.final(“hex”);<br>return sign;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 解密</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>@description:</li>
<li>@param sign:加密后的字符串，buffer.toString()</li>
<li>@param key 秘钥</li>
<li>@param iv 偏移量</li>
<li>@return:<br>*/<br>function deSign(sign, key, iv) {<br>let src = “”;<br>const cipher = crypto.createDecipheriv(“aes-128-cbc”, key, iv);<br>src += cipher.update(sign, “hex”, “utf8”);<br>src += cipher.final(“utf8”);<br>return src;<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node</category>
      </categories>
  </entry>
  <entry>
    <title>对像-操作方法</title>
    <url>/2019/10/11/%E5%AF%B9%E8%B1%A1-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对像-操作方法</p>
<a id="more"></a>
<h2 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h2><ul>
<li><h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3></li>
</ul>
<p>冻结对象，使其不能修改、删除、新增属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const o1=&#123;x:10,y:10&#125;</span><br><span class="line">o1.x=11</span><br><span class="line">//o1</span><br><span class="line">//&#123;x: 11, y: 10&#125;</span><br><span class="line">Object.freeze(o1)</span><br><span class="line">const o2=o1;</span><br><span class="line">o2.x=22</span><br><span class="line">//o1</span><br><span class="line">//&#123;x: 11, y: 10&#125;</span><br><span class="line">//o2</span><br><span class="line">//&#123;x: 11, y: 10&#125;</span><br></pre></td></tr></table></figure>
<p>冻结不是深度冻结，如果属性值还是对象的话，还是可以修修改的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const o3=&#123;x:&#123;y:1&#125;&#125;</span><br><span class="line">Object.freeze(o3)</span><br><span class="line">o3.x.y=2</span><br><span class="line">//o3</span><br><span class="line">//&#123;x:&#123;y:2&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ul>
<li><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3></li>
</ul>
<p>将对象变成数组，对象属性变成子数组<br>返回一个给定对象自身可枚举属性的键值对数组，数组每个元素是一个包含键和值的数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;x:1,y:2&#125;</span><br><span class="line">let arr = Object.entries(obj)</span><br><span class="line">//arr</span><br><span class="line">//[[&apos;x&apos;,1],[&apos;y&apos;,2]]</span><br><span class="line">for(let [x, y] of arr)&#123;</span><br><span class="line">    console.log(x,y)</span><br><span class="line">&#125;</span><br><span class="line">//x 1</span><br><span class="line">//y 2</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>返回对象自身可枚举属性属性名组成的数组，不包含 Symbol 类型的属性</p>
</li>
<li><h3 id="for…-in"><a href="#for…-in" class="headerlink" title="for… in"></a>for… in</h3><p>遍历返回对象的自身和原型链上的可枚举属性（不包含 Symbol 属性）</p>
</li>
<li><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>返回对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值属性）组成的数组</p>
</li>
<li><h3 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h3><p>返回对象的所有 Symbol 类型属性的 key 组成数组</p>
</li>
<li><h3 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h3><p>返回对象自身的所有属性,不管属性名是 Symbol 或字符串,也不管是否可枚举.</p>
</li>
</ul>
<h2 id="判断对象是否含有某属性"><a href="#判断对象是否含有某属性" class="headerlink" title="判断对象是否含有某属性"></a>判断对象是否含有某属性</h2><ul>
<li><code>key in obj</code>:检测指定对象(obj)原型链上是否有对应的属性值。</li>
<li><code>obj.hasOwnProperty(key)</code>判断 key 是不是 obj 的私有属性。<br><em>在 ES5 里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 TypeError。在 ES2015 中，非对象的参数将被强制转换为一个对象。</em></li>
</ul>
<h2 id="对象浅拷贝"><a href="#对象浅拷贝" class="headerlink" title="对象浅拷贝"></a>对象浅拷贝</h2><ul>
<li><h3 id="Object-assign-obj"><a href="#Object-assign-obj" class="headerlink" title="Object.assign({}, obj)"></a>Object.assign({}, obj)</h3><p>将 obj 拷贝到空对象，返回目标对象<br><code>Object.assign(target, ...source)</code><br>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。会修改原对象。</p>
</li>
<li><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let newObj=&#123;...obj&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3></li>
<li><h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><p><strong>注意：</strong>Array 的 slice 和 concat 方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p>
</li>
<li><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shadowClone(obj) &#123;</span><br><span class="line">    //保证新对象与原对象是相同的构造函数的实例</span><br><span class="line">    let newObj = new obj.constructor;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123; //只拷贝私有属性，不拷贝原型链上的属性</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h2><ul>
<li><h2 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h2></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>时间对象拷贝后不是时间对象而是字符串<br><img src="/2019/10/11/对象-操作方法/img1.png" alt="date"></li>
<li>正则表达式、Error 对象拷贝后变成空对象<br><img src="/2019/10/11/对象-操作方法/img2.png" alt="date"></li>
<li>函数、<code>undefined</code> 拷贝后会丢失<br><img src="/2019/10/11/对象-操作方法/img3.png" alt="date"></li>
<li><code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code>，拷贝后会变成 null<br><img src="/2019/10/11/对象-操作方法/img4.png" alt="date"></li>
<li>只能序列化对象的可枚举的自有属性，如果 obj 中的对象是由构造函数生成的，则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor。</li>
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝。</li>
</ul>
<p><strong>总结</strong><br>JSON.parse(JSON.stringify(X))，其中 X 只能是 Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构</p>
<p><strong>JSON.stringify()的其他用法</strong></p>
<ul>
<li><p>判断数组是否包含某对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data = [</span><br><span class="line">&#123;name:&apos;John&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Mary&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Lucky&apos;&#125;,</span><br><span class="line">],</span><br><span class="line">val = &#123;name:&apos;Mary&apos;&#125;;</span><br><span class="line">console.log(JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1);//true</span><br><span class="line">console.log(data.indexOf(val) !== -1)//false</span><br><span class="line">//因为两个对象是引用值不同，所以需要序列化一下转成字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断对象/数组是否相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a=[1,2,3],b=[1,2,3];</span><br><span class="line">JSON.Stringify(a)===JSON.stringify(b);//true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与 toString()的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">console.log(JSON.stringify(arr));//&apos;[1,2,3]&apos;</span><br><span class="line">console.log(arr.toString());//&apos;1,2,3&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">      //递归终止条件</span><br><span class="line">      if (obj === null) return null;</span><br><span class="line">      if (!isObject(obj)) return obj;</span><br><span class="line">      if (obj instanceof RegExp) return new RegExp(obj);</span><br><span class="line">      if (obj instanceof Date) &#123;</span><br><span class="line">          return new Date(obj)</span><br><span class="line">      &#125;</span><br><span class="line">      //测试了一下，貌似还是拷贝了引用地址，未找到替换方法</span><br><span class="line">      if (typeof obj === &apos;function&apos;) &#123;</span><br><span class="line">          return new Function(&quot;return &quot; + JSON.stringify(obj))();</span><br><span class="line">      &#125;</span><br><span class="line">      if (obj instanceof TypeError) &#123;</span><br><span class="line">          return new TypeError(obj)</span><br><span class="line">      &#125;</span><br><span class="line">      //保证新对象与原对象是相同的构造函数的实例，比如原对象是[]</span><br><span class="line">      let newObj = new obj.constructor;</span><br><span class="line">      for (let key in obj) &#123;</span><br><span class="line">          if (obj.hasOwnProperty(key)) &#123; //只拷贝私有属性，不拷贝原型链上的属性</span><br><span class="line">              newObj[key] = deepClone(obj[key])</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return newObj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>问题</strong><br>如果存在循环引用递归终止条件就无法执行，陷入死循环。</p>
<ul>
<li><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const deepClone = (value, hash = new WeakMap) =&gt; &#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        //排除null 和 undefine的情况,直接返回</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof value !== &quot;object&quot;) &#123;</span><br><span class="line">        //基本数据类型和函数的情况直接返回即可</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value instanceof RegExp) &#123;</span><br><span class="line">        //正则的情况,返回新的正则即可</span><br><span class="line">        return new RegExp(value);</span><br><span class="line">    &#125;</span><br><span class="line">    if (value instanceof Date) &#123;</span><br><span class="line">        return new Date(value);</span><br><span class="line">    &#125;</span><br><span class="line">    //处理对象或者数组的情况,new 创建新的空对象或数组</span><br><span class="line">    let instance = new value.constructor();</span><br><span class="line">    if (hash.has(value)) &#123;</span><br><span class="line">        //在hash 中查询一下是否存在过，如果存在就把以前拷贝的返回</span><br><span class="line">        return hash.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">    hash.set(value, instance); //没有存过就放进去</span><br><span class="line">    for (let key in value) &#123;</span><br><span class="line">        if (value.hasOwnProperty(key)) &#123;</span><br><span class="line">            //排除原型链上的属性或方法</span><br><span class="line">            instance[key] = deepClone(value[key], hash);</span><br><span class="line">            //将hash继续传递下去，保证每次能拿到以前拷贝的结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JS-浏览器缓存</title>
    <url>/2019/10/08/JS-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Cookie、Session 和 localStorage、以及 SessionStorage 之间的区别</p>
<a id="more"></a>
<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>性能优化中最简单高效的方式，可以显著减少网络传输所带来的损耗。</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><ol>
<li><p>Service Worker<br>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存、如何读取缓存，并且缓存是持续性的。<br>如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>
</li>
<li><p>Memory Cache<br>内存中的缓存。读取内存中的数据肯定比磁盘快，但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放。一旦关闭 Tab 页面，内存中的缓存也就被释放。<br>内存一定比硬盘容量小得多，所以操作系统需要精打细算内存的使用。</p>
</li>
<li><p>Disk Cache<br>硬盘中的缓存，读取速度慢，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>
</li>
<li><p>Push Cache<br>HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（session）中存在，一旦会话结束就被释放。<br>未来的趋势，现在资料很少，有时间看看</p>
<ul>
<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
</li>
<li>网络请求<br>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</li>
</ol>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p><a href="https://dorisfeng.github.io/2020/01/06/m-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/">强缓存和协商缓存</a></p>
<p>如果什么缓存策略都没设置，那么浏览器会怎么处理？<br>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li><strong>频繁变动的资源</strong></li>
</ul>
<ol>
<li>使用<code>Cache-Control: no-cache</code>使浏览器每次都请求服务器，</li>
<li>配合<code>ETag</code>或者<code>Last-Modified</code>来验证资源是否有效，这种方法不能节省请求数量，但是能显著减少响应数据大小。</li>
</ol>
<ul>
<li><strong>代码文件</strong><br>这里特指 HTML 之外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。<br>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。</li>
</ul>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>Cookie，localStorage，SessionStorage</p>
<ul>
<li>共同点：都是保存在浏览器端，且遵循同源策略</li>
<li>不同点：生命周期与作用域不同</li>
</ul>
<p>作用域：localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。<br>SessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p>
<p>1、Cookie<br>一般限制在 4kb 以下，Cookie 缓存浏览器和服务器间来回传递，所以一般只将用户登录状态或权限验证放在 Cookie 中，避免影响请求传输效率。在设置的过期时间之前一直有效。<br>2、localStorage<br>大小 5mb 以下，存储在浏览器缓存中直到代码删除或手动清除浏览器缓存。<br>方法：</p>
<ul>
<li>存储：<code>localStorage.setItem(key,value)</code>，存储或更新</li>
<li>获取：<code>localStorage.getItem(key)</code>,如果 key 不存在返回 null</li>
<li>删除：<code>localStorage.removeItem(key)</code>一旦删除，key 对应的数据将会全部删除</li>
<li>全部删除：<code>localStorage.clear()</code></li>
</ul>
<p>3、SessionStorage<br>5mb，生命周期维持到页面窗口关闭</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 使基于无状态的 HTTP 协议可以记录稳定的状态信息。<br>Cookie 存储在客户端：服务器发送到用户浏览器并保存在本地，下次向服务器发起请求被携带。通常用于告知服务端两个请求是否来自同一浏览器，如保存用户的登录状态。<br>Cookie 不可以跨域：每个 Cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的（靠的是 domain）</strong><br>Cookie 数据为键值对，键、值都必须是字符串类型。<br>如果值为 Unicode 字符，需要为字符编码。<br>如果值为二进制数据，则需要使用 BASE64 编码。<br>属性见《-HTTP 协议》</p>
<p><strong>问题：</strong></p>
<ul>
<li>存储在客户端，容易被客户端篡改。</li>
<li>使用 httpOnly 在一定程度上提高安全性。</li>
<li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
</ul>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>记录服务器和客户端会话状态的机制。<br>保存在服务器，有一个唯一标识。在服务端保存 Session 的方法很多，内存、数据库、文件都有。<br><img src="/2019/10/08/JS-浏览器缓存/img1.png" alt="session"><br>Session 认证流程：</p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li>当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session。</li>
<li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。</li>
<li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现。</li>
</ul>
<h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><ul>
<li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li>
<li><strong>存取值的类型不同：</strong> Cookie 只支持存字符串数据，其他类型都要转换为字符串，Session 可以存任意数据。</li>
<li><strong>有效期不同：</strong> Cookie 可设置为长时间保存，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可以存储数据远高于 Cookie，但是访问量过多，会占用过多的服务器资源。</li>
</ul>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><ul>
<li>访问资源接口（API）时所需的资源凭证。</li>
<li>简单 Token 的组成：uid（用户唯一的身份标识）、time（当前时间的时间戳，用于控制登录过期）、sign（签名、Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>服务端无状态、可扩展性好</li>
<li>支持移动端设备</li>
<li>安全</li>
<li>支持跨域程序调用</li>
</ul>
<p><strong>Token 的身份验证流程</strong><br><img src="/2019/10/08/JS-浏览器缓存/img2.png" alt="Token"></p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后，会把它存储起来，比如放在 Cookie 里或者 LocalStorage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token ，如果验证成功，就向客户端返回请求的数据</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>每一次请求都需要携带 Token，需要把 Token 放到 HTTP 的 Header 里</li>
<li>基于 Token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 Token 数据。用解析 Token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</li>
<li>Token 完全由应用管理，所以它可以避开同源策略</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Toke 目前最流行的跨域认证解决方案。一种认证授权机制。<br>JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。<br><strong>原理：</strong> 服务器认证后，生成一个 JSON 对象，发给用户，之后用户与服务器通信都要发回这个 JSON 对象。为了防止用户篡改数据，服务器在生成这个对象的时候会加上签名。<br><strong>组成部分：</strong> <code>Header</code>(头部),<code>Payload</code>(消息体),<code>Signature</code>(签名)<br><code>Header.Payload.Signature</code></p>
<ul>
<li><p><strong>Header</strong><br>JSON 对象，描述 JWT 的元数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;:&quot;HS256&quot;</span><br><span class="line">  &quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alg</code>：签名算法（algorithm），默认是 <code>HMAC SHA256(HS256)</code>;<br><code>typ</code>：表示这个令牌（token）的类型，JWT 统一写为<code>JWT</code></p>
</li>
<li><p><strong>Payload</strong><br>用来存放实际需要传递的数据，官方规定 7 个字段供选用</p>
<ul>
<li>iss（issuer）：签发人</li>
<li>exp（expiration time）：过期时间</li>
<li>sub（subject）：主题</li>
<li>aud（audience）：受众</li>
<li>nbf（Not Before）：生效时间</li>
<li>iat（Issued At）：签发时间,令牌生成的时间</li>
<li>jti（JWT ID）：编号<br>除了官方字段，你还可以在这个部分定义私有字段</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;:&quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<ul>
<li><p><strong>Signature</strong><br>对前两部分的签名，防止数据篡改。<br>指定一个密钥（<code>secret</code>），只能服务器知道。使用 Header 里面指定的签名算法（默认 <code>HMAC SHA256</code>）,按照下面的公式产生签名。<br>签名计算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const base64Header = encodeBase64(header)</span><br><span class="line">const base64Payload = encodeBase64(payload)</span><br><span class="line">const unsignedToken = `$&#123;base64Header&#125;.$&#123;base64Payload&#125;`</span><br><span class="line">const key = &apos;服务器私钥&apos;</span><br><span class="line"></span><br><span class="line">signature = HMAC(key, unsignedToken)</span><br></pre></td></tr></table></figure>
<p>最后，Token 计算如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const base64Header = encodeBase64(header)</span><br><span class="line">const base64Payload = encodeBase64(payload)</span><br><span class="line">const base64Signature = encodeBase64(signature)</span><br><span class="line"></span><br><span class="line">token = `$&#123;base64Header&#125;.$&#123;base64Payload&#125;.$&#123;base64Signature&#125;`</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用方式</strong><br>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面。<br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。<br>服务器在判断 Token 时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [base64Header, base64Payload, base64Signature] = token.split(&apos;.&apos;)</span><br><span class="line"></span><br><span class="line">const signature1 = decodeBase64(base64Signature)</span><br><span class="line">const unsignedToken = `$&#123;base64Header&#125;.$&#123;base64Payload&#125;`</span><br><span class="line">const signature2 = HMAC(&apos;服务器私钥&apos;, unsignedToken)</span><br><span class="line"></span><br><span class="line">if(signature1 === signature2) &#123;</span><br><span class="line">  return &apos;签名验证成功，token 没有被篡改&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const payload =  decodeBase64(base64Payload)</span><br><span class="line">if(new Date() - payload.iat &lt; &apos;token 有效期&apos;)&#123;</span><br><span class="line">  return &apos;token 有效&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong></p>
<ul>
<li>默认不加密，但是也可以加密，生成原始 Token 以后，可以用密钥加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h2 id="Service-Worker-整理的有点乱，没看懂"><a href="#Service-Worker-整理的有点乱，没看懂" class="headerlink" title="Service Worker(整理的有点乱，没看懂)"></a>Service Worker(整理的有点乱，没看懂)</h2><p>运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用<code>Service Worker</code>的话，传输协议必须为<code>HTTPS</code>。因为<code>Service Worker</code>中涉及到请求拦截，所以必须<code>HTTPS</code>协议来保障安全。<br>Service Worker 的初衷是极致优化用户体验，是用来锦上添花的，技术只是技术，但实际应用前，应考虑成本和收益。</p>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p><code>Progressive Web Apps</code>，渐进式网络应用程序，是一种普通网页或网站架构起来的的网络应用程序。<br><code>Progressive 渐进式</code>：由于浏览器对于 Web 标准的跟进会有不同程度的滞后（更有甚者不但不跟进还要乱搞），很多优秀的新特性老旧浏览器并不支持，所以开发者有时会采取渐进式的策略，充分利用新特性，为支持新特性的浏览器提供更完善的功能和更好的体验（ 让一部分人先富起来？）。PWA 之 P，大约就是这个意思。</p>
<h3 id="Service-Worker-的生命周期"><a href="#Service-Worker-的生命周期" class="headerlink" title="Service Worker 的生命周期"></a>Service Worker 的生命周期</h3><ul>
<li>注册<br>如果要使用<code>Service Worker</code>，就要在指定页面的 JS 页面注册，注册后，浏览器会自动安装<code>Service Worker</code>;</li>
<li><p>安装<br>缓存一些静态资源，如果缓存成功，则<code>Service Worker</code>安装成功，相反，缓存失败，安装就会失败，此时<code>Service Worker</code>不会被激活，但是稍后它还是会继续安装的。</p>
</li>
<li><p>激活<br>激活成功后，<code>service worker</code> 会控制其范围内的所有页面。第一次注册 <code>service worker</code> 的页面，会等到页面加载成功后，才会接受控制。一旦<code>service worker</code>在控制页面，它只会有两种状态：要么停止运行，要么处理页面中的<code>fetch</code> 和<code>message</code>事件(当页面中有网络请求或消息时)。</p>
</li>
</ul>
<h3 id="Service-Worker-的主要事件"><a href="#Service-Worker-的主要事件" class="headerlink" title="Service Worker 的主要事件"></a>Service Worker 的主要事件</h3><ul>
<li><code>install</code>，安装时触发，通常在此时缓存文件</li>
<li><code>active</code>，激活时触发，通常做一些重置的操作，例如处理旧版本 Service Worker 的缓存</li>
<li><code>fetch</code>，浏览器发起<code>HTTP</code>请求时触发，通常在这个事件的回调函数中匹配缓存，是最常用的事件。</li>
<li><code>push</code>，和推送通知功能相关</li>
<li><code>sync</code>，和后台同步功能相关</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>缓存静态资源</li>
<li><p>离线体验<br><strong>步骤</strong></p>
</li>
<li><p>注册<code>Service Worker</code>；</p>
</li>
<li>监听到<code>install</code>事件以后就可以缓存需要的文件；</li>
<li>下次用户访问的时候，就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//防止报错，符合渐进式的要求</span><br><span class="line">//如果浏览器不支持Service Worker，就不执行</span><br><span class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">    window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">        //所以Service Worker只是一个挂在navigator对象上的HTML5 API而已</span><br><span class="line">        navigator.serviceWorker.register(&apos;/sw.js&apos;).then(function (registration) &#123;</span><br><span class="line">            // 注册成功</span><br><span class="line">            console.log(&apos;注册成功: &apos;, registration.scope);</span><br><span class="line">        &#125;, function (err) &#123;</span><br><span class="line">            // 注册失败</span><br><span class="line">            console.log(&apos;注册失败: &apos;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查<code>Service Worker</code>服务是否可用，页面加载完成后，注册<code>/sw.js</code>.<br>可以在页面加载后直接调用<code>register()</code>，浏览器会自动处理 service worker 是不是已经注册过并且根据情况处理。<br><code>register()</code> 的一个需要注意的点是 <code>service worker</code>的文件位置。这个例子中，文件位置在域名的根位置底下。这说明 <code>service worker</code>的作用域是整个源。换句话说，<code>service worker</code> 会接受到这个域名下到所有 <code>fetch</code> 事件。如果我们注册到是<code>/example/sw.js</code> 这个位置，那 <code>service worker</code> 就只会接收到 URL 以<code>/example/</code> 开头(比如 <code>/example/page1/</code>, <code>/example/page2/</code>)的 <code>fetch</code> 事件</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// sw.js</span><br><span class="line">self.addEventListener(&quot;install&quot;, (e) =&gt; &#123;</span><br><span class="line">  e.waitUntill(</span><br><span class="line">    catches.open(&quot;my-cache&quot;).then((cache) =&gt; &#123;</span><br><span class="line">      return cache.addAll([ &quot;./a.js&quot;]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&quot;fetch&quot;, function (event) &#123;</span><br><span class="line">  if (/\.png$/.test(event.request.url)) &#123;</span><br><span class="line">    event.respondWith(fetch(&quot;/bird.jpg&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 callback 函数内部，我们需要注意：</p>
<ul>
<li>开启缓存</li>
<li>缓存一些文件</li>
<li>检查文件是否缓存成功</li>
</ul>
<p><code>self</code>，类似于 <code>window</code> 或 <code>global</code>，代表该 <code>Service Worker</code> 自身。</p>
<p>调用<code>caches.open()</code>开启缓存，调用<code>cache.addAll()</code>，传入需要缓存的文件数组。<br>如果所有这些文件都被成功缓存，那<code>service worker</code> 就被成功安装上了。但是，只要有一个文件下载失败，整个安装步骤就失败了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>数组-操作方法</title>
    <url>/2019/10/08/%E6%95%B0%E7%BB%84-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>js 数组操作方法总结</p>
<a id="more"></a>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p><strong>方法一</strong><br>相当于双层 for 循环，时间复杂度 O(n²)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq()&#123;</span><br><span class="line">    return arr.reduce((result, item) =&gt; &#123;</span><br><span class="line">        console.log(&apos;111&apos;, result)</span><br><span class="line">        if (result.indexOf(item) === -1) &#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!result.includes(arr[i])) &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong><br>ES6 的 Set 结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function uniq(arr) &#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    arr.forEach(item =&gt; obj[item] = item)</span><br><span class="line">    return Object.values(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三</strong><br>对象 key 的唯一，时间复杂度 O(n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function uniq(arr) &#123;</span><br><span class="line">    let resultObj = &#123;&#125;;</span><br><span class="line">    arr.forEach((item, index)=&gt;&#123;</span><br><span class="line">        resultObj[item] = item;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Object.values(resultObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拉平嵌套数组"><a href="#拉平嵌套数组" class="headerlink" title="拉平嵌套数组"></a>拉平嵌套数组</h2><ol>
<li>es6 中数组的操作方法<code>flat</code>可以返回扁平化的数组，不修改原数组，默认参数是<code>1</code>，只拉平一层嵌套的数组，如果是多层的需要传入层数，最大是<code>Math.pow(2,53)-1</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function flattenDeep(arr, deepLength) &#123;</span><br><span class="line">    return arr.flat(deepLength)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.利用 concat 和 reduce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function flattenDeep(arr, deepLength) &#123;</span><br><span class="line">    return arr.reduce((pre, val, index) =&gt; Array.isArray(val) ? pre.concat(flattenDeep(val)) : pre.concat(val), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.stack 无限反嵌套数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function flattenDeep(inputArr) &#123;</span><br><span class="line">    const stack = [...inputArr];</span><br><span class="line">    const res = [];</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        let next = stack.pop();</span><br><span class="line">        console.log(next)</span><br><span class="line">        if (Array.isArray(next)) &#123;</span><br><span class="line">            stack.push(...next)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.push(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res.reverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>var peoples=[‘Tom’,’Jerry’,’Jack’,’Mary’]</p>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>ES5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i =0; i&lt;peoples.length; i++)&#123;</span><br><span class="line">    let people=peoples[i];</span><br><span class="line">    console.log(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i in peoples)&#123;</span><br><span class="line">    let people=peoples[i];</span><br><span class="line">    console.log(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let people of peoples)&#123;</span><br><span class="line">    console.log(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>ES6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peoples.forEach(people=&gt;&#123;</span><br><span class="line">    console.log(people)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>将数组映射成另一个数组，返回新数组。<br>如果没有<code>return</code>，默认返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let new_peoples=peoples.map(people=&gt;(&#123;name:people,age:10&#125;))</span><br><span class="line">//[&#123;name:&apos;Tom&apos;,age:10&#125;,&#123;name:&apos;Jerry&apos;,age:10&#125;,&#123;name:&apos;Jack&apos;,age:10&#125;,&#123;name:&apos;Mary&apos;,age:10&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>返回数组中符合条件的元素组成新数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let peoples=[&#123;name:&apos;Tom&apos;,age:10&#125;,&#123;name:&apos;Jerry&apos;,age:11&#125;,&#123;name:&apos;Jack&apos;,age:11&#125;,&#123;name:&apos;Mary&apos;,age:10&#125;]</span><br><span class="line">let new_peoples=peoples.filter(people=&gt;people.age===10);</span><br><span class="line">//[&#123;name:&apos;Tom&apos;,age:10&#125;,&#123;name:&apos;Mary&apos;,age:10&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let peoples=[&#123;name:&apos;Tom&apos;,age:10&#125;,&#123;name:&apos;Jerry&apos;,age:11&#125;,&#123;name:&apos;Jack&apos;,age:11&#125;,&#123;name:&apos;Mary&apos;,age:10&#125;]</span><br><span class="line">peoples.find(people=&gt;people.age===10);//[&#123;name:&apos;Tom&apos;,age:10&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>数组中是否每个元素都满足指定的条件<br>返回<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peoples.every(people=&gt;people.age&gt;10)//false</span><br><span class="line">peoples.every(people=&gt;people.age&gt;9)//true</span><br></pre></td></tr></table></figure>
<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>数组中是否有元素满足指定的条件<br>返回<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peoples.some(people=&gt;people.age&gt;10)//true</span><br><span class="line">peoples.some(people=&gt;people.age&lt;10)//false</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=[1,2,3,4];</span><br><span class="line">let sum =arr.reduce((prev,cur,index,arr)=&gt;&#123;</span><br><span class="line"> return prev+cur</span><br><span class="line">&#125;,0)</span><br><span class="line">sum //10</span><br></pre></td></tr></table></figure>
<ul>
<li>prev：第一项的值或上一次叠加的结果值</li>
<li>cur：当前会遍历的值</li>
<li>index：当前值的索引</li>
<li>arr：数组本身</li>
<li>传入参数 0，叠加的初始值<br>如果不传入参数，第一个 prev 就是第一项的值，cur 是第二项的值，如果传参，第一个 prev 就是传入参数，cur 就是数组第一项的值。<br>传入参数的类型决定 reduce 最终结果</li>
</ul>
<h4 id="计算字符串中字母出现的次数"><a href="#计算字符串中字母出现的次数" class="headerlink" title="计算字符串中字母出现的次数"></a>计算字符串中字母出现的次数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&apos;asdaaddad&apos;;</span><br><span class="line">str.split(&apos;&apos;).reduce((res,cur)=&gt;&#123;</span><br><span class="line">    res[cur]?res[cur]++:res[cur]=1;</span><br><span class="line">    return res</span><br><span class="line">&#125;,&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>将类数组转化为数组。<br>类数组：一个对象的所有键名都是正整数或零，并且具有<code>length</code>属性，例如 arguments,DOM 元素集，字符串。<br>参数：</p>
<ul>
<li><code>obj</code>：要转换的对象</li>
<li><code>map</code>：类似数组的 map 方法，用来对每个对象进行处理，处理后返回一个数组</li>
<li><code>context</code>：绑定 map 中用到的<code>this</code><br><strong>只要是部署了 iterator 接口的数据结构，Array.from 都能将其转为数组:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr=Array.from(&apos;Hello&apos;);//[&apos;H&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];</span><br><span class="line">Array.from(&apos;123&apos;,(x)=&gt;x*x);//[1,4,9]</span><br><span class="line">//等同于</span><br><span class="line">[1,2,3].map(x=&gt;x*x);//[1,4,9]</span><br></pre></td></tr></table></figure>
<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from(&#123; length: 2 &#125;, () =&gt; &apos;jack&apos;)// [&apos;jack&apos;, &apos;jack&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="Array-of-v1-v2-v3"><a href="#Array-of-v1-v2-v3" class="headerlink" title="Array.of(v1,v2,v3)"></a>Array.of(v1,v2,v3)</h2><p>将传入的所有参数转换为一个数组，而不管参数的数量与类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.of(1,&apos;1&apos;,&apos;a&apos;,true,&#123;a:1&#125;)</span><br><span class="line">//[1, &quot;1&quot;, &quot;a&quot;, true, &#123;a:1&#125;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>经典布局</title>
    <url>/2019/09/18/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>记录几种布局</p>
<a id="more"></a>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p><strong>html</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&apos;container&apos;&gt;</span><br><span class="line">    &lt;div class=&apos;middle&apos;&gt;middle&lt;/div&gt;</span><br><span class="line">    &lt;div class=&apos;left&apos;&gt;left&lt;/div&gt;</span><br><span class="line">    &lt;div class=&apos;right&apos;&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">        padding: 0 200px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .middle &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background: red;</span><br><span class="line">        min-height: 200px;</span><br><span class="line">        float: left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        min-height: 200px;</span><br><span class="line">        float: left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">        background: green;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        position: relative;</span><br><span class="line">        left: -200px;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">        background: yellow;</span><br><span class="line">        margin-left: -200px;</span><br><span class="line">        position: relative;</span><br><span class="line">        right: -200px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong><br><img src="/2019/09/18/经典布局/img1.png" alt="圣杯布局"></p>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p><strong>html</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&apos;container2&apos;&gt;</span><br><span class="line">    &lt;div class=&apos;middle2&apos;&gt;</span><br><span class="line">        &lt;div class=&apos;inner&apos;&gt;middle&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&apos;left2&apos;&gt;left&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div class=&apos;right2&apos;&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><strong>css</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.middle2 &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      background: red;</span><br><span class="line">      min-height: 200px;</span><br><span class="line">      float: left;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .middle2 .inner &#123;</span><br><span class="line">      height: 200px;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">      margin-top: 10px;</span><br><span class="line"></span><br><span class="line">      /* 以下是设置的 margin */</span><br><span class="line">      margin-left: 200px;</span><br><span class="line">      margin-right: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .left2,</span><br><span class="line">  .right2 &#123;</span><br><span class="line">      width: 200px;</span><br><span class="line">      min-height: 200px;</span><br><span class="line">      float: left;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .left2 &#123;</span><br><span class="line">      background: green;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .right2 &#123;</span><br><span class="line">      background: yellow;</span><br><span class="line">      margin-left: -200px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Calc"><a href="#Calc" class="headerlink" title="Calc"></a>Calc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.center&#123;</span><br><span class="line">  width:calc(100% - 400px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content:space-between;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    flex:0 0 200px;</span><br><span class="line">    height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    flex:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">   position:relative;</span><br><span class="line">   height:200px</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    left:0</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    right：0</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    position:absolute；</span><br><span class="line">    left:200px;</span><br><span class="line">    right:200px;</span><br><span class="line">    height:100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>布局</category>
      </categories>
  </entry>
  <entry>
    <title>snippets</title>
    <url>/2019/09/16/snippets/</url>
    <content><![CDATA[<p>记录在公众号，或者开发过程中遇到的一些有意思的代码片段</p>
<a id="more"></a>
<h5 id="1、创建一个函数来判断给定的表达式中的大括号是否闭合，返回-True-False，对于空字串，返回-True"><a href="#1、创建一个函数来判断给定的表达式中的大括号是否闭合，返回-True-False，对于空字串，返回-True" class="headerlink" title="1、创建一个函数来判断给定的表达式中的大括号是否闭合，返回 True/False，对于空字串，返回 True"></a>1、创建一个函数来判断给定的表达式中的大括号是否闭合，返回 True/False，对于空字串，返回 True</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isBalanced(exp)&#123;</span><br><span class="line">    let info = exp.split(&apos;&apos;);</span><br><span class="line">    let stack = [];</span><br><span class="line">    for(let i = 0; i &lt; info.length; ++i)&#123;</span><br><span class="line">        let el = info[i];</span><br><span class="line">        if(el === &apos;&#123;&apos;)&#123;</span><br><span class="line">            stack.push(&apos;&#123;&apos;);</span><br><span class="line">        &#125;else if(el === &apos;&#125;&apos;)&#123;</span><br><span class="line">            if(stack.length === 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length === 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、实现函数-isBalanced，用-true-或-false-表示给定的字符串的括号是否平衡（一一对应）。注意了是要支持三种类型的括号-，-，和-。带有交错括号的字符串应该返回-false"><a href="#2、实现函数-isBalanced，用-true-或-false-表示给定的字符串的括号是否平衡（一一对应）。注意了是要支持三种类型的括号-，-，和-。带有交错括号的字符串应该返回-false" class="headerlink" title="2、实现函数 isBalanced，用 true 或 false 表示给定的字符串的括号是否平衡（一一对应）。注意了是要支持三种类型的括号{}，[]，和()。带有交错括号的字符串应该返回 false"></a>2、实现函数 isBalanced，用 true 或 false 表示给定的字符串的括号是否平衡（一一对应）。注意了是要支持三种类型的括号{}，[]，和()。带有交错括号的字符串应该返回 false</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isBalanced = str =&gt; &#123;</span><br><span class="line">    const map = new Map([</span><br><span class="line">        [&apos;&#123;&apos;, &apos;&#125;&apos;],</span><br><span class="line">        [&apos;[&apos;, &apos;]&apos;],</span><br><span class="line">        [&apos;(&apos;, &apos;)&apos;]</span><br><span class="line">    ]);</span><br><span class="line">    let stack = [];</span><br><span class="line">    for(let i = 0; i &lt; str.length; ++i)&#123;</span><br><span class="line">        let node = str[i];</span><br><span class="line">        if(map.has(node))&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125;else if([...map.values()].includes(node))&#123;</span><br><span class="line">            if(stack[stack.length-1] !== [...map.entries()].filter(el =&gt; el[1] === node).pop().shift())&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、再次扩充一下这道题目。要求严格限制括号的顺序，即中括号外围只能是大括号，内部只能是小括号。也即：括号只能以大括号、中括号、小括号的顺序只能前面的包含后面的，不能后面的包含前面的"><a href="#3、再次扩充一下这道题目。要求严格限制括号的顺序，即中括号外围只能是大括号，内部只能是小括号。也即：括号只能以大括号、中括号、小括号的顺序只能前面的包含后面的，不能后面的包含前面的" class="headerlink" title="3、再次扩充一下这道题目。要求严格限制括号的顺序，即中括号外围只能是大括号，内部只能是小括号。也即：括号只能以大括号、中括号、小括号的顺序只能前面的包含后面的，不能后面的包含前面的"></a>3、再次扩充一下这道题目。要求严格限制括号的顺序，即中括号外围只能是大括号，内部只能是小括号。也即：括号只能以大括号、中括号、小括号的顺序只能前面的包含后面的，不能后面的包含前面的</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isStrictBalanced= str =&gt; &#123;</span><br><span class="line">    const map = new Map([</span><br><span class="line">        [&apos;&#123;&apos;, &apos;&#125;&apos;],</span><br><span class="line">        [&apos;[&apos;, &apos;]&apos;],</span><br><span class="line">        [&apos;(&apos;, &apos;)&apos;]</span><br><span class="line">    ]);</span><br><span class="line">    let stack = [];</span><br><span class="line">    let keys = [...map.keys()], values = [...map.values()];</span><br><span class="line">    for(let i = 0; i &lt; str.length; ++i)&#123;</span><br><span class="line">        let node = str[i];</span><br><span class="line">        if(map.has(node))&#123;</span><br><span class="line">            if(stack.length)&#123;</span><br><span class="line">                let arr = [node, [...stack].pop()].map(el =&gt; keys.indexOf(el))</span><br><span class="line">                if(arr[0] &lt; arr[1])&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125;else if(values.includes(node))&#123;</span><br><span class="line">            let needKey = [...map.entries()].filter(el =&gt; el[1] === node).pop().shift();</span><br><span class="line">            if(needKey !== [...stack].pop())&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.length === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-快速过滤掉数据的假值"><a href="#4-快速过滤掉数据的假值" class="headerlink" title="4.快速过滤掉数据的假值"></a>4.快速过滤掉数据的假值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compact = arr =&gt; arr/filter(Boolean)</span><br></pre></td></tr></table></figure>
<h5 id="5-双位运算符"><a href="#5-双位运算符" class="headerlink" title="5.双位运算符~~"></a>5.双位运算符<code>~~</code></h5><p>对正数来说替代<code>Math.floor()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~4.9 === 4 //true</span><br></pre></td></tr></table></figure>
<p>对负数来说替代<code>Math.ceil()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~-4.9 === -4 //true</span><br></pre></td></tr></table></figure>
<h5 id="6-取整-0-效果跟-一样"><a href="#6-取整-0-效果跟-一样" class="headerlink" title="6.取整|0,效果跟~~一样"></a>6.取整<code>|0</code>,效果跟<code>~~</code>一样</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.3|0 //1</span><br><span class="line">-1.9|0 //0</span><br></pre></td></tr></table></figure>
<h5 id="7-判断奇偶-amp-1"><a href="#7-判断奇偶-amp-1" class="headerlink" title="7.判断奇偶&amp;1"></a>7.判断奇偶<code>&amp;1</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!(3&amp;1)//true</span><br><span class="line">!!(2&amp;1)//false</span><br></pre></td></tr></table></figure>
<h5 id="遍历到为-true"><a href="#遍历到为-true" class="headerlink" title="遍历到为 true"></a>遍历到为 true</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj=&#123;&apos;key1&apos;:&apos;v1&apos;,&apos;key2&apos;:&apos;v2&apos;,&apos;key3&apos;:&apos;v3&apos;,&apos;key0&apos;:&apos;v0&apos;&#125;;</span><br><span class="line">Reflect.ownKeys(obj).reduce(</span><br><span class="line">    (prev, name) =&gt; &#123;</span><br><span class="line">        console.log(name);</span><br><span class="line">        return prev || obj[name] ===&apos;v2&apos;;</span><br><span class="line">        &#125;,</span><br><span class="line">    false</span><br><span class="line">  );</span><br><span class="line">  let state=false</span><br><span class="line">  for(key in obj)&#123;</span><br><span class="line">       console.log(key);</span><br><span class="line">       if(obj[name] ===&apos;v2&apos;)&#123;</span><br><span class="line">           state= true;</span><br><span class="line">           break</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Reflect.ownKeys(obj).map(name=&gt; obj[name] ===&apos;v2&apos;&amp;&amp; true)</span><br><span class="line">  for(let i=0;i&lt;Reflect.ownKeys(obj).length;i++)&#123;</span><br><span class="line">       console.log(key);</span><br><span class="line">       if(obj[name] ===&apos;v2&apos;)&#123;</span><br><span class="line">           break</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Python+Spark2.0+Hadoop</title>
    <url>/2019/09/04/Python-Spark2-0-Hadoop/</url>
    <content><![CDATA[<p>Python+Spark2.0+Hadoop 机器学习与大数据实战<br>遇到的问题记录</p>
<a id="more"></a>
<p><strong>1、启动 HDFS 报 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable，</strong></p>
<ul>
<li>开启 debug</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">che</span><br></pre></td></tr></table></figure>
<p>Failed to load native-hadoopwith error: java.lang.UnsatisfiedLinkError: no hadoop in java.library.path</p>
<ul>
<li>官方文档需要的文件名 libhadoop.so，但是 usr/local/hadoop/lib/native 文件中只有 libhadoop.so.1.0.0，官方编译软件确实有个 libhadoop.so 文件，但是是个 link</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s libhadoop.so.1.0.0 libhadoop.so</span><br></pre></td></tr></table></figure>
<p><strong>2、每次使用 start-all.sh 启动 HDFS 和 YARN 的时候无法启动 NameNode，每次都需要使用 hadoop namenode -format 格式化 HDFS 所有数据，才能启动</strong></p>
<p><strong>解决办法：</strong></p>
<ul>
<li><p>配置 tmp 文件目录</p>
<p>默认在根目录/tmp 文件中，如果 tmp 文件中无重要文件可以清空文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /tmp/*</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 hadoop_tmp 目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir /home/hduser/hadoop_tmp  /*hduser是用户名*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 core-site.xml 文件，新增如下节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /usr/local/hadoop/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/home/hduser/hadoop_tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化 namenode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3、hadoop 集群 master 主机启动 namenode,但其 slaves 未启动 datanode</strong></p>
<ul>
<li>原因 hadoop namenode -format 执行，导致 master 中/usr/local/hadoop/hadoop_data/hdfs/namenode/current 里面的 version 和 salve 中/usr/local/hadoop/hadoop_data/hdfs/datanode/current/version 内容不一致，导致的。</li>
<li>我将 master 里面的 version 复制到 salves 里面问题没有解决</li>
<li>将所有 current 删除后重新启动，解决了</li>
<li>不要执行 hadoop namenode -format</li>
</ul>
<p><strong>4、运行 scala 报错，Exception in thread “main” java.lang.UnsupportedClassVersionError: scala/tools/nsc/MainGenericRunner : Unsupported major.minor version 52.0</strong></p>
<p>安装的 scala 版本较高，降级安装 scala.2.11.6<br>或者升级 jdk1.7=&gt;jdk1.8</p>
<p><strong>将目录所有者更改为 hduser</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R hduser:hduser /usr/local/hadoop</span><br></pre></td></tr></table></figure>
<p><strong>启动共享文件夹</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mount -t vboxsf Hadoop共享 /mnt/share/</span><br></pre></td></tr></table></figure>
<p><strong>8.7 在 Hadoop YARN 运行 pyspark</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HADOOP_CONF_DIR=/usr/hadoop/etc/hadoop pyspark  --master yarn --deploy-mode client</span><br></pre></td></tr></table></figure>
<p><strong>8.8 在 Spark Standalone 运行 pyspark</strong></p>
<ul>
<li>1、启动 Spark Standalone Cluster</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/spark/sbin/start-all.sh</span><br></pre></td></tr></table></figure>
<p>分别启动 master 与 slaves</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/spark/sbin/start-master.sh</span><br><span class="line">/usr/local/spark/sbin/start-salves.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在 Spark Standalone 运行 pyspark</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyspark --master spark://master:7077 --num-executors 1 --total-executor-cores 3 --executor-memory 512m</span><br></pre></td></tr></table></figure>
<ul>
<li>3、读取本地文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">textFile=sc.textFile(&quot;file:/usr/local/spark/README.md&quot;)</span><br><span class="line">textFile.count()</span><br></pre></td></tr></table></figure>
<p><strong>错误</strong><br>WARN TaskSchedulerImpl: Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient resources</p>
]]></content>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2019/07/24/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>错误</p>
<a id="more"></a>
<h1 id="1、使用-urllib-模块的-request-urlopen-报错"><a href="#1、使用-urllib-模块的-request-urlopen-报错" class="headerlink" title="1、使用 urllib 模块的 request.urlopen 报错"></a>1、使用 urllib 模块的 request.urlopen 报错</h1><p>简单的爬虫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#usr/bin/python</span><br><span class="line">#-*-coding:UTF-8-*-</span><br><span class="line">from urllib import request</span><br><span class="line">response = request.urlopen(&apos;https://movie.douban.com/&apos;)</span><br><span class="line">content = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>
<p>报错<br><img src="/2019/07/24/python爬虫/img1.png"><br>mac python 3.7</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>Mac 二进制版本忽略了对 SSL 证书的验证<br>手动 ssl 证书验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from urllib import request</span><br><span class="line">import ssl</span><br><span class="line">context = ssl._create_unverified_context()</span><br><span class="line">response = request.urlopen(&apos;https://movie.douban.com/&apos;,context=context)</span><br><span class="line">content = response.read().decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"># from mysqlclient import *</span><br><span class="line">import re</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">context = ssl._create_unverified_context()</span><br><span class="line"></span><br><span class="line">class MovieTop(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.start = 0</span><br><span class="line">        self.param = &apos;&amp;filter=&apos;</span><br><span class="line">        self.headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; WOW64)&apos;&#125;</span><br><span class="line">        self.movie_list = []</span><br><span class="line">        self.file_path = &apos;./test.txt&apos;</span><br><span class="line"></span><br><span class="line">    def get_page(self):</span><br><span class="line">        try:</span><br><span class="line">            url=&apos;https://movie.douban.com/top250?start=&apos;+str(self.start)+str(self.param)</span><br><span class="line">            req = request.Request(url, headers = self.headers)</span><br><span class="line">            response = request.urlopen(req, context=context)</span><br><span class="line">            page = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line">            page_num = self.start/25 + 1</span><br><span class="line">            print(&apos;正在抓取第&apos;+str(page_num)+&apos;页数据。。。&apos;)</span><br><span class="line">            self.start += 25</span><br><span class="line">            return page</span><br><span class="line">        except request.URLError as e:</span><br><span class="line">            if hasattr(e, &apos;reason&apos;):</span><br><span class="line">                 print(&apos;抓取失败，失败原因：&apos;+e.reason)</span><br><span class="line"></span><br><span class="line">    def get_movie_info(self):</span><br><span class="line">        pattern = re.compile( u&apos;&lt;em.*?class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span.*?class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span.*?class=&quot;title&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span.*?class=&quot;other&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;p.*?class=&quot;&quot;&gt;.*?导演:(.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;主演:(.*?)...&lt;br&gt;&apos;</span><br><span class="line">            + u&apos;(.*?)&amp;nbsp;/&amp;nbsp;(.*?)&amp;nbsp;/&amp;nbsp;(.*?)&lt;/p&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span.*?class=&quot;rating_num&quot;.*?property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span&gt;(.*?)人评价&lt;/span&gt;.*?&apos;</span><br><span class="line">            + u&apos;&lt;span.*?class=&quot;inq&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;/p&gt;.*?&apos;,re.S)</span><br><span class="line"></span><br><span class="line">        while self.start &lt;= 225:</span><br><span class="line">            page = self.get_page()</span><br><span class="line">            movies  = re.findall(pattern, page)</span><br><span class="line">            for movie in movies:</span><br><span class="line">                self.movie_list.append([</span><br><span class="line">                    movie[0],</span><br><span class="line">                    movie[1],</span><br><span class="line">                    movie[2],</span><br><span class="line">                    movie[3],</span><br><span class="line">                    movie[4].strip(),</span><br><span class="line">                    movie[5].strip().rstrip(&apos;/&apos;),</span><br><span class="line">                    movie[6].lstrip(),</span><br><span class="line">                    movie[7].lstrip(),</span><br><span class="line">                    movie[8].strip(),</span><br><span class="line">                    movie[9],</span><br><span class="line">                    movie[10],</span><br><span class="line">                    movie[11]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def write_text(self):</span><br><span class="line">        print(&apos;开始向文件写入数据。。。&apos;)</span><br><span class="line">        file_top = open(self.file_path, &apos;w&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">        try:</span><br><span class="line">            for movie in self.movie_list:</span><br><span class="line">                file_top.write(&apos;电影排名：&apos;+movie[0]+&apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;电影名称：&apos; + movie[1] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;外文名称：&apos; + movie[2] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;电影别名：&apos; + movie[3] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;导演姓名：&apos; + movie[4] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;主演名称：&apos; + movie[5] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;上映年份：&apos; + movie[6] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;制作国家/地区：&apos; + movie[7] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;电影类别：&apos; + movie[8] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;电影评分：&apos; + movie[9] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;参评人数：&apos; + movie[10] + &apos;\r\n&apos;)</span><br><span class="line">                file_top.write(&apos;简短影评：&apos; + movie[11] + &apos;\r\n\n&apos;)</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">        finally:</span><br><span class="line">            file_top.close()</span><br><span class="line"></span><br><span class="line">    def main(self):</span><br><span class="line">        print(&quot;开始抓取数据&quot;)</span><br><span class="line">        self.get_movie_info()</span><br><span class="line">        self.write_text()</span><br><span class="line">        print(&apos;数据抓取完毕&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    m = MovieTop()</span><br><span class="line">    m.main()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2019/07/24/MySQL/</url>
    <content><![CDATA[<p>MySQL + Mac</p>
<a id="more"></a>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载稳定版本的 MySQL：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>按照安装指导下一步就可以了，记住最后安装完成生成的用户密码<br><img src="/2019/07/24/MySQL/img1.png" title="安装完成"></p>
<h1 id="开启-MySQL-服务"><a href="#开启-MySQL-服务" class="headerlink" title="开启 MySQL 服务"></a>开启 MySQL 服务</h1><p>系统偏好设置/MySQL<br><img src="/2019/07/24/MySQL/img2.jpg" title="开启服务"><br>打钩开机自动运行 MySQL</p>
<p>使用 open /usr/local 打开文件夹将 Mysql 安装包改变文件名 mysql</p>
<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<p>使环境变量生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<h1 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a>登录 MySQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>密码就是安装完成后出现的截图里 2j.pX8&amp;yEhnk</p>
<p>修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;fdd930102&apos;);</span><br></pre></td></tr></table></figure>
<p>退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql &gt; \q;</span><br></pre></td></tr></table></figure>
<h1 id="python-连接到-mysql-遇到的问题"><a href="#python-连接到-mysql-遇到的问题" class="headerlink" title="python 连接到 mysql,遇到的问题"></a>python 连接到 mysql,遇到的问题</h1><p>python 的 datetime 存入 mysql 需要转换一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date_time_format = &apos;%y-%m-%d %H:%M:%S&apos;</span><br><span class="line">def date_time_str(date_time):</span><br><span class="line">    return datetime.strftime(date_time, date_time_format)</span><br><span class="line"> sql = &quot;&quot;&quot; INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME, CERATE_TIME) VALUES(&apos;%s&apos;, &apos;%s&apos;, &apos;%d&apos;, &apos;%c&apos;, &apos;%d&apos;, &apos;%s&apos;)&quot;&quot;&quot;%(&apos;xiao&apos;,&apos;zhi&apos;,22,&apos;M&apos;,3000, date_time_str(datetime.now()))</span><br></pre></td></tr></table></figure>
<h1 id="mysql-语法"><a href="#mysql-语法" class="headerlink" title="mysql 语法"></a>mysql 语法</h1><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line">CREATE DATABASE &lt;name&gt;;</span><br><span class="line">//删除数据库</span><br><span class="line">DROP DATABASE  &lt;name&gt;;</span><br><span class="line">//显示数据库列表</span><br><span class="line">SHOW DATABASES;</span><br><span class="line">//选择数据库</span><br><span class="line">USE &lt;name&gt;;</span><br><span class="line">// 查看test中所有的表</span><br><span class="line">SHOW TABLES;</span><br><span class="line">//展示表结构</span><br><span class="line">DESC &lt;table-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建表</span><br><span class="line">CREATE TABLE &lt;table-name&gt; (column_name columns_type, column_name columns_type ... );</span><br><span class="line">//创建表之前先检查是否存在</span><br><span class="line">DROP TABLE IF EXISTS douban_commont;</span><br><span class="line">//删除表</span><br><span class="line">DROP TABLE &lt;table-name1&gt; &lt;table-name2&gt;...;</span><br></pre></td></tr></table></figure>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//插入数据</span><br><span class="line">INSERT INTO &lt;table-name&gt; (field1, ... ) VALUES(value1, ...) ;</span><br><span class="line">//查询数据</span><br><span class="line">SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N] [OFFSET M];</span><br><span class="line">//更新数据</span><br><span class="line">UPDATE &lt;table-name&gt; set column_name = value where column_name=value</span><br><span class="line">//删除数据</span><br><span class="line">DELETE FROM &lt;table-name&gt; [WHERE]</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2019/07/24/MongoDB/</url>
    <content><![CDATA[<p>Mac 环境下配置 MongoDB</p>
<a id="more"></a>
<h1 id="直接使用-brew-安装"><a href="#直接使用-brew-安装" class="headerlink" title="直接使用 brew 安装"></a>直接使用 brew 安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install mongodb</span><br></pre></td></tr></table></figure>
<h1 id="或下载"><a href="#或下载" class="headerlink" title="或下载"></a>或下载</h1><p>官网：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a><br>下载到本地，解压，放到/usr/local 文件中（可以直接使用 open /usr/local 打开文件夹）<br>修改文件名为 mongodb</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在当前用户文件夹中打开.bash_profile,（快捷键 option+enter+&gt;.显示隐藏文件）<br>加入下列配置并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export PATH=$&#123;PATH&#125;:/usr/local/mongodb/bin</span><br></pre></td></tr></table></figure>
<p>使环境变量生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line">source</span><br></pre></td></tr></table></figure>
<h1 id="新建-data-db-文件"><a href="#新建-data-db-文件" class="headerlink" title="新建 data/db 文件"></a>新建 data/db 文件</h1><p>然后在根目录下新建文件夹 data/db，mongodb 默认运行在 data/db<br>(新的 mac 系统新建不了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br></pre></td></tr></table></figure>
<p>给 data/d 目录设置权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown ‘username’ /data/db</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/24/MongoDB/img1.jpg" alt="new"><br>在/usr/local/mongodb 新建 data 文件夹，执行是配置</p>
<h1 id="运行-Mongodb"><a href="#运行-Mongodb" class="headerlink" title="运行 Mongodb"></a>运行 Mongodb</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mongod</span><br><span class="line">或mongod --dbpath /usr/local/mongodb/data //定义默认存储目录</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/24/MongoDB/img2.jpg" alt="mongod"><br>mongodb 运行在 localhost:27017</p>
<p>浏览器打开 localhost:27017</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure>
<h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><p>命令行打输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>
<p>退出 MongoDB 数据库（一定要正常退出，不然下次使用会报错）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">use admin;</span><br><span class="line"></span><br><span class="line">db.shutdownServer();</span><br></pre></td></tr></table></figure>
<h1 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h1><p>Robo 3T：<a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a><br>下载安装</p>
<p>create 创建连接</p>
]]></content>
  </entry>
  <entry>
    <title>小程序notbook</title>
    <url>/2019/06/01/%E5%B0%8F%E7%A8%8B%E5%BA%8Fnotbook/</url>
    <content><![CDATA[<p>小程序学习遇到的问题记录</p>
<a id="more"></a>
<h1 id="问题：无法直接在双括号中直接调用-js-内置函数"><a href="#问题：无法直接在双括号中直接调用-js-内置函数" class="headerlink" title="问题：无法直接在双括号中直接调用 js 内置函数 "></a><font color="#FF0000">问题：无法直接在双括号中直接调用 js 内置函数 </font></h1><p>1、在 wxml 文件中调用函数</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;text&gt;&#123;&#123;util.getFirst(item.name)&#125;&#125;&lt;/text&gt;</span><br><span class="line"> &lt;wxs module=&quot;util&quot;&gt;hexo</span><br><span class="line">    var getFirst = function(name) &#123;</span><br><span class="line">        return name.slice(0,1)</span><br><span class="line">    &#125;</span><br><span class="line">    module.exports.getFirst = getFirst;</span><br><span class="line">&lt;/wxs&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法二<br>1、新建 util.wxs 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getFirst = function(name) &#123;</span><br><span class="line">     return name.slice(0,1)</span><br><span class="line"> &#125;</span><br><span class="line"> module.exports.getFirst = getFirst;</span><br></pre></td></tr></table></figure>
<p>2、wxml 中引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;wxs src=&apos;../../utils/util.wxs&apos; module=&apos;util&apos;&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;util.getFirst(item.name)&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="问题：路由跳转"><a href="#问题：路由跳转" class="headerlink" title="问题：路由跳转 "></a><font color="#FF0000">问题：路由跳转 </font></h1><ol>
<li>跳转到当前私有页面<ul>
<li>路由配置 app.json</li>
</ul>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;:[</span><br><span class="line">  &quot;pages/departmentList/index&quot;,</span><br><span class="line">  &quot;pages/departmentList/detail&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

- index.js
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDetail:function(e)&#123;</span><br><span class="line">    let id=e.currentTarget.dataset[&apos;id&apos;];</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">        url: &apos;detail?id=&apos; + id,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>跳转到公共页面</li>
</ol>
<ul>
<li>路由配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;:[</span><br><span class="line">    &quot;pages/departmentList/index&quot;,</span><br><span class="line">    &quot;pages/detail/index&quot;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>
<ul>
<li>跳转</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDetail:function(e)&#123;</span><br><span class="line">     let id=e.currentTarget.dataset[&apos;id&apos;];</span><br><span class="line">     wx.navigateTo(&#123;</span><br><span class="line">         url: &apos;/pages/detail/index?id=&apos; + id,</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>wchat</tag>
      </tags>
  </entry>
  <entry>
    <title>base64文件处理</title>
    <url>/2019/05/30/base64%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>base64 转换</p>
<a id="more"></a>
<ul>
<li><p>base64 转图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`data:$&#123;type&#125;;base64,`+code</span><br></pre></td></tr></table></figure>
<p>type 是文件类型，比如图片 image/png,image/jpeg,pdf:application/pdf</p>
</li>
<li><p>base64 转为 Blob 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dataURLtoBlob(dataurl) &#123;</span><br><span class="line">    var arr = dataurl.split(&apos;,&apos;), mime = arr[0].match(/:(.*?);/)[1],</span><br><span class="line">        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Blob([u8arr], &#123; type: mime &#125;);</span><br><span class="line">&#125;</span><br><span class="line">let blob = dataURLtoBlob(`data:$&#123;mimetype&#125;;base64,`+image)`)</span><br></pre></td></tr></table></figure>
</li>
<li><p>blob 转为 File</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function blobToFile(theBlob, fileName)&#123;</span><br><span class="line">   theBlob.lastModifiedDate = new Date();</span><br><span class="line">   theBlob.name = fileName;</span><br><span class="line">   return theBlob;</span><br><span class="line">&#125;</span><br><span class="line">var file = blobToFile(blob, imgName);</span><br></pre></td></tr></table></figure>
</li>
<li><p>base64 转为 File 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function dataURLtoFile(dataurl, filename) &#123;//将base64转换为文件</span><br><span class="line">     var arr = dataurl.split(&apos;,&apos;), mime = arr[0].match(/:(.*?);/)[1],</span><br><span class="line">     bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);</span><br><span class="line">     while(n--)&#123;</span><br><span class="line">         u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">     &#125;</span><br><span class="line">     return new File([u8arr], filename, &#123;type:mime&#125;);</span><br><span class="line"> &#125;</span><br><span class="line">let file = dataURLtoFile(`data:$&#123;mimetype&#125;;base64,`+image)`,&apos;PDF.pdf&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>转为 url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.URL.createObjectURL(blob|file)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a=document.getElementById(&apos;download&apos;);</span><br><span class="line"> let blob=dataURLtoBlob(`data:$&#123;image[0].mimetype&#125;;base64,`+image[0].image);</span><br><span class="line"> a.download = image[0].name+&apos;.pdf&apos;;</span><br><span class="line"> a.href = window.URL.createObjectURL(blob)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号</title>
    <url>/2019/05/29/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
    <content><![CDATA[<p>微信公众号开发记录</p>
<a id="more"></a>
<h1 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a>微信公众号开发</h1><ul>
<li><p>微信登录</p>
<ul>
<li><p>用户同意，获取 code<br>链接：<code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</code></p>
<ul>
<li>appid 基本配置中的 AppID</li>
<li><p>redirect_uri 请求 code 之后重定向的域名，也是在基本配置中设置的，如果需要跳转到下级路由需要配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&apos;/&apos; exact render=&#123;()=&gt;(&lt;Redirect from=&apos;/&apos; to=&apos;/loading&apos;/&gt;)&#125;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>state 参数，可以是要绑定的 uid</p>
</li>
<li>scope<ul>
<li>snsapi_base:不弹出授权页面，直接跳转，只能获取用户 openid</li>
<li>snsapi_userinfo:弹出授权页面，可通过 openid 拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息<br><strong>code 说明 ： code 作为换取 access_token 的票据，每次用户授权带上的 code 将不一样，code 只能使用一次，5 分钟未被使用自动过期。</strong><br>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。</li>
</ul>
</li>
</ul>
</li>
<li><p>根据 code 获取用户的 openid</p>
<ul>
<li><p>请求</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.get(&#123;</span><br><span class="line">    url: `https://api.weixin.qq.com/sns/oauth2/access_token?appid=$&#123;wxConfig.appID&#125;&amp;secret=$&#123;wxConfig.appSecret&#125;&amp;code=$&#123;code&#125;&amp;grant_type=authorization_code`</span><br><span class="line">&#125;, function (error, response, body) &#123;</span><br><span class="line">    console.log(&apos;openid&apos;, body)</span><br><span class="line">    let &#123;  openid &#125; = JSON.parse(body)</span><br><span class="line">    let body1=&#123;</span><br><span class="line">        params: &#123;openid:openid&#125;,</span><br><span class="line">        model,</span><br><span class="line">        method</span><br><span class="line">    &#125;</span><br><span class="line">    request_primary_server(&apos;/login&apos;,&#123;body:body1&#125;,res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>appid:公众号唯一标识</li>
<li>secret：公众号的 appsecret</li>
<li>grant_type:authorization_code</li>
<li>code</li>
</ul>
</li>
<li><p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,//网页授权接口凭证</span><br><span class="line">    &quot;expires_in&quot;:7200,  //凭证超期时间 s</span><br><span class="line">    &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">    &quot;openid&quot;:&quot;OPENID&quot;, //公众号和用户唯一的</span><br><span class="line">    &quot;scope&quot;:&quot;SCOPE&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果 scope 为 snsapi_userinfo 可以通过 access_token 和 openid 拉取用户信息</p>
<ul>
<li><p>GET 方法请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;openid&quot;:&quot; OPENID&quot;,//用户唯一的标识</span><br><span class="line">    &quot; nickname&quot;: NICKNAME,//昵称</span><br><span class="line">    &quot;sex&quot;:&quot;1&quot;,//性别1是男，2为女，0是未知</span><br><span class="line">    &quot;province&quot;:&quot;PROVINCE&quot;, //省份</span><br><span class="line">    &quot;city&quot;:&quot;CITY&quot;, //城市</span><br><span class="line">    &quot;country&quot;:&quot;COUNTRY&quot;, //国家</span><br><span class="line">    &quot;headimgurl&quot;:       &quot;http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;,//头像</span><br><span class="line">    &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot;     ],//用户特权信息</span><br><span class="line">    &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; //只有公众号绑定到微信开发平台账号后，才会出现该字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>微信公众平台 JS-SDK<br>面向网页开发者提供基于微信内的网页开发工具包</p>
<ul>
<li>绑定域名<br>微信公众平台，微信公众号设置，填写 JS 接口安全域名</li>
<li><p>引入 JS 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&apos;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&apos;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前台配置 window.wx.config</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">    timestamp: , // 必填，生成签名的时间戳  new Date().getTime()</span><br><span class="line">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串 &apos;fdd&apos;</span><br><span class="line">    signature: &apos;&apos;,// 必填，签名</span><br><span class="line">    jsApiList: [] // 必填，需要使用的JS接口列表 地理位置 [&apos;getLocation&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>signature</p>
<ul>
<li><p>获取 access_token 存入全局</p>
<ul>
<li><p>GET 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">request.get(&#123;//获取access_token</span><br><span class="line">   url: `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$&#123;wxConfig.appID&#125;&amp;secret=$&#123;wxConfig.appSecret&#125;`,</span><br><span class="line">   &#125;,(error, response, body) =&gt; &#123;</span><br><span class="line">       if (!error &amp;&amp; response.statusCode === 200) &#123;</span><br><span class="line">           let &#123;  access_token &#125; = JSON.parse(body);</span><br><span class="line">           global.access_token = access_token;</span><br><span class="line">           let expires_out = timestamp + 7200 * 1000;</span><br><span class="line">           global.expires_out=expires_out;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取 ticket,生成 js-sdk 权限签名</p>
<ul>
<li><p>GET 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.get(&#123;</span><br><span class="line">    url:`https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=$&#123;access_token&#125;&amp;type=jsapi`</span><br><span class="line">&#125;,(error, response, body) =&gt; &#123;</span><br><span class="line">    if (!error &amp;&amp; response.statusCode === 200) &#123;</span><br><span class="line">        console.log(&apos;body&apos;,body)</span><br><span class="line">        let &#123;  ticket &#125; = JSON.parse(body);</span><br><span class="line">        let result=&#123;</span><br><span class="line">            signature: getSignature(timestamp, nonceStr, URL, ticket),</span><br><span class="line">        &#125;</span><br><span class="line">        res.json(&#123;&apos;result&apos;:result&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>签名算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var crypto = require(&apos;crypto&apos;)</span><br><span class="line">function sha1(str) &#123;</span><br><span class="line">    let shasum = crypto.createHash(&quot;sha1&quot;)</span><br><span class="line">    shasum.update(str)</span><br><span class="line">    str = shasum.digest(&quot;hex&quot;)</span><br><span class="line">     return str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSignature(timestamp,nonceStr,URL,ticket)&#123;</span><br><span class="line">    var string = `jsapi_ticket=$&#123;ticket&#125;&amp;noncestr=$&#123;nonceStr&#125;&amp;timestamp=$&#123;timestamp&#125;&amp;url=$&#123;URL&#125;`</span><br><span class="line">    return sha1(string)</span><br><span class="line">&#125;</span><br><span class="line">module.exports =  getSignature;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端 通过 ready 接口处理成功验证,error 接口处理失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    window.wx.ready(()=&gt;&#123;</span><br><span class="line">        //示例获取地理位置</span><br><span class="line">    window.wx.getLocation(&#123;</span><br><span class="line">        type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos;</span><br><span class="line">        success: (res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    window.wx.error(function(res)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>wchat</tag>
      </tags>
  </entry>
  <entry>
    <title>手写webpack</title>
    <url>/2019/04/07/%E6%89%8B%E5%86%99webpack/</url>
    <content><![CDATA[<p>手写 webpack</p>
<a id="more"></a>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &quot;./bin/pack.js&quot;,</span><br></pre></td></tr></table></figure>
<h2 id="新建文件夹-bin，新建文件-pack-js"><a href="#新建文件夹-bin，新建文件-pack-js" class="headerlink" title="新建文件夹 bin，新建文件 pack.js"></a>新建文件夹 bin，新建文件 pack.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">//表示使用node执行该js</span><br><span class="line"></span><br><span class="line">//1）找到当前执行命令的路径，拿到webpack.config.js</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const config =  require(path.resolve(&apos;webpack.config.js&apos;));//获取到配置文件</span><br><span class="line">let Compiler = require(&apos;../lib/Compiler.js&apos;); //编译类</span><br><span class="line"></span><br><span class="line">let compiler = new Compiler(config);</span><br><span class="line">compiler.hooks.entryOption.call()</span><br><span class="line">//标识运行编译</span><br><span class="line">compiler.run()</span><br></pre></td></tr></table></figure>
<h2 id="新建文件夹-lib-文件-Compiler-js-，编写编译文件"><a href="#新建文件夹-lib-文件-Compiler-js-，编写编译文件" class="headerlink" title="新建文件夹 lib,文件 Compiler.js ，编写编译文件"></a>新建文件夹 lib,文件 Compiler.js ，编写编译文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">//把源码转换成ast</span><br><span class="line">const babylon = require(&apos;babylon&apos;);</span><br><span class="line">const traverse = require(&apos;@babel/traverse&apos;).default;//遍历</span><br><span class="line">const t = require(&apos;@babel/types&apos;);</span><br><span class="line">const generator = require(&apos;@babel/generator&apos;).default;</span><br><span class="line">const ejs = require(&apos;ejs&apos;);</span><br><span class="line">const &#123; SyncHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line"></span><br><span class="line">class Compiler&#123;</span><br><span class="line">    constructor(config)&#123;</span><br><span class="line">        //配置文件</span><br><span class="line">        this.config = config;</span><br><span class="line">        //入口文件的路径</span><br><span class="line">        this.entryId;</span><br><span class="line">        //所有模块依赖</span><br><span class="line">        this.modules = &#123;&#125;,</span><br><span class="line">        this.entry = config.entry;//入口文件路径</span><br><span class="line">        this.root = process.cwd();//运行当前脚本的路径npx pack</span><br><span class="line">        this.hooks = &#123;</span><br><span class="line">            entryOption: new SyncHook(),</span><br><span class="line">            compiler: new SyncHook(),</span><br><span class="line">            afterCompiler: new SyncHook(),</span><br><span class="line">            afterPlugins: new SyncHook(),</span><br><span class="line">            run: new SyncHook(),</span><br><span class="line">            emit:new SyncHook(),</span><br><span class="line">            done:new SyncHook(),</span><br><span class="line">        &#125;</span><br><span class="line">        let plugins = this.config.plugins;</span><br><span class="line">        if(Array.isArray(plugins))&#123;</span><br><span class="line">            plugins.forEach(plugin =&gt; &#123;</span><br><span class="line">                plugin.apply(this)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.hooks.afterPlugins.call()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取文件内容</span><br><span class="line">    getSource(modulePath)&#123;</span><br><span class="line">        let rules = this.config.module.rules;</span><br><span class="line">        let content = fs.readFileSync(modulePath,&apos;utf8&apos;);//文件内容</span><br><span class="line">        //每一个规则</span><br><span class="line">        for( let i=0; i&lt;rules.length; i++)&#123;</span><br><span class="line">            let rule = rules[i];</span><br><span class="line">            let &#123;test, use&#125; = rule;</span><br><span class="line">            let len=use.length-1;</span><br><span class="line">            if(test.test(modulePath))&#123;//后缀匹配到路径匹配</span><br><span class="line">              function normalLoader()&#123;</span><br><span class="line">                  let loader = require(use[len--])</span><br><span class="line">                  content = loader(content);</span><br><span class="line">                  if(len&gt;=0)&#123;</span><br><span class="line">                    normalLoader()</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              normalLoader()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return content</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析源码</span><br><span class="line">    parse(source, parentPath)&#123;//AST解析语法树</span><br><span class="line">       let ast = babylon.parse(source);</span><br><span class="line">       let dependencies = [];</span><br><span class="line">       traverse(ast, &#123;</span><br><span class="line">            CallExpression(p)&#123;</span><br><span class="line">               let node = p.node; //对应节点</span><br><span class="line">               if(node.callee.name === &apos;require&apos;)&#123;</span><br><span class="line">                  node.callee.name = &apos;__webpack_require__&apos;;</span><br><span class="line">                  let moduleName = node.arguments[0].value;</span><br><span class="line">                  moduleName += path.extname(moduleName)?&apos;&apos;:&apos;.js&apos;;</span><br><span class="line">                  moduleName = &apos;./&apos; + path.join(parentPath,moduleName);</span><br><span class="line">                  dependencies.push(moduleName);</span><br><span class="line">                  node.arguments = [t.stringLiteral(moduleName)]//修改源码中的路径</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       let sourceCode= generator(ast).code;//生成新的源码</span><br><span class="line">       return &#123;sourceCode, dependencies&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildModule(modulePath, isEntry)&#123;</span><br><span class="line"></span><br><span class="line">        let source = this.getSource(modulePath);</span><br><span class="line">        let moduleName = &apos;./&apos;+ path.relative(this.root,modulePath);</span><br><span class="line">        if(isEntry)&#123;</span><br><span class="line">            this.entryId = moduleName;//入口文件名字</span><br><span class="line">        &#125;</span><br><span class="line">        //解析源码 改造source源码，返回依赖列表</span><br><span class="line">        let &#123; sourceCode, dependencies &#125; = this.parse(source, path.dirname(moduleName))//父路径</span><br><span class="line">        //保存解析好的模块</span><br><span class="line">        this.modules[moduleName] = sourceCode;</span><br><span class="line"></span><br><span class="line">        //递归解析依赖</span><br><span class="line">        dependencies.forEach(dep =&gt;&#123;</span><br><span class="line">           this.buildModule(path.resolve(this.root,dep),false)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emitFile()&#123;</span><br><span class="line">        //输出文件路径</span><br><span class="line">        let outputPath = path.join(this.config.output.path,this.config.output.filename);</span><br><span class="line">        let template = this.getSource(path.join(__dirname,&apos;main.ejs&apos;));</span><br><span class="line">        let bundleCode = ejs.render(template,&#123;entryId:this.entryId,modules:this.modules&#125;)</span><br><span class="line">        this.assets=&#123;&#125;;</span><br><span class="line">        //多个资源存储</span><br><span class="line">        this.assets[outputPath]=bundleCode;</span><br><span class="line">        Object.keys(this.assets).forEach( key=&gt;&#123;</span><br><span class="line">            fs.writeFileSync(key,this.assets[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;//执行编译</span><br><span class="line">        this.hooks.run.call()</span><br><span class="line">        this.hooks.compiler.call()</span><br><span class="line">        //创建模块的依赖关系</span><br><span class="line">        this.buildModule(path.resolve(this.root,this.entry),true)</span><br><span class="line">        this.hooks.afterCompiler.call();</span><br><span class="line">        //生成打包后的文件</span><br><span class="line">        this.emitFile();</span><br><span class="line">        this.hooks.emit.call();</span><br><span class="line">        this.hooks.done.call()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports= Compiler</span><br></pre></td></tr></table></figure>
<h1 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h1><ul>
<li><p>在本地编写的 npm 模块中执行 npm link，将模块链接到全局<br>mac 中使用 sudo npm link</p>
</li>
<li><p>在需要项目中使用的执行 npm link，将模块连接到项目中</p>
</li>
<li>想去掉 link ：npm unlink my-utils</li>
</ul>
<h1 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let path = require(&apos;path&apos;);</span><br><span class="line">class P&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        compiler.hooks.emit.tap(&apos;emit&apos;,() =&gt; &#123;</span><br><span class="line">            console.log(&apos;emit&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class P1&#123;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        compiler.hooks.afterPlugins.tap(&apos;afterPlugins&apos;,() =&gt; &#123;</span><br><span class="line">            console.log(&apos;afterPlugins&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">          &#123;</span><br><span class="line">              test:/\.less$/,</span><br><span class="line">              use:[</span><br><span class="line">                  path.resolve(__dirname, &apos;loader&apos;, &apos;style-loader&apos;),</span><br><span class="line">                  path.resolve(__dirname, &apos;loader&apos;, &apos;less-loader&apos;)</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new P(),</span><br><span class="line">        new P1()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="手写-less-loader"><a href="#手写-less-loader" class="headerlink" title="手写 less-loader"></a>手写 less-loader</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let less =require(&apos;less&apos;);</span><br><span class="line">function loader(source)&#123;</span><br><span class="line">    let css =&apos;&apos;;</span><br><span class="line">    less.render(source, (err,c) =&gt; &#123;</span><br><span class="line">        css=c.css</span><br><span class="line">    &#125;)</span><br><span class="line">    css=css.replace(/\n/g,&apos;\\n&apos;)</span><br><span class="line">    return css</span><br><span class="line">&#125;</span><br><span class="line">module.exports =loader</span><br></pre></td></tr></table></figure>
<h1 id="手写-style-loader"><a href="#手写-style-loader" class="headerlink" title="手写 style-loader"></a>手写 style-loader</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loader(source)&#123;</span><br><span class="line">    let style=`</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `</span><br><span class="line">    return style;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure>
<h1 id="loader-加载顺序"><a href="#loader-加载顺序" class="headerlink" title="loader 加载顺序"></a>loader 加载顺序</h1><ul>
<li>从左到右加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    test:/\.js$/,</span><br><span class="line">    use:[&apos;loader1&apos;,&apos;loader2&apos;,&apos;loader3&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>从下到上加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader1&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader2&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader3&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>enfore 设置执行顺序，pre-前置 post-后置 normal-正常<br>loader1 loader2 loader3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader1&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        enforce: &apos;pre&apos;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader2&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader:&apos;loader3&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        enforce: &apos;post&apos;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>inline 内置 loader<br>加载顺序 pre-normal-inline-post<br>新建 a.js，在 index.js 中添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str =require(&apos;inline-loader!./a.js&apos;)</span><br></pre></td></tr></table></figure>
<p>执行顺序<br><img src="/2019/04/07/手写webpack/img1.jpg" alt="inline-loader"></p>
<p>! 没有 normal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str =require(&apos;!inline-loader!./a.js&apos;)</span><br></pre></td></tr></table></figure>
<p>执行顺序<br><img src="/2019/04/07/手写webpack/img2.png" alt="inline-loader1"></p>
<p>-! 不执行 inline-loader 前面的 loader pre-normal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str =require(&apos;-!inline-loader!./a.js&apos;)</span><br></pre></td></tr></table></figure>
<p>执行顺序<br><img src="/2019/04/07/手写webpack/img3.png" alt="inline-loader2"></p>
<p>!!其他 loader 都不执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str =require(&apos;!!inline-loader!./a.js&apos;)</span><br></pre></td></tr></table></figure>
<p>执行顺序<br><img src="/2019/04/07/手写webpack/img4.png" alt="inline-loader2"></p>
<h1 id="手写-babel-loader"><a href="#手写-babel-loader" class="headerlink" title="手写 babel-loader"></a>手写 babel-loader</h1><ul>
<li>安装模块@babel/core loader-utils</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const babel = require(&apos;@babel/core&apos;);//核心模块</span><br><span class="line">const loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line">function loader(source)&#123;</span><br><span class="line">    let options = loaderUtils.getOptions(this);//获取loader的options</span><br><span class="line">    let cb = this.async();//执行完的回调</span><br><span class="line">    babel.transform(source, &#123;</span><br><span class="line">        ...options,</span><br><span class="line">        sourceMap: true,</span><br><span class="line">        filename: this.resourcePath.split(&apos;/&apos;).pop()  //source-map文件名</span><br><span class="line">    &#125;, (err, result) =&gt; &#123;</span><br><span class="line">        cb(null, result.code, result.map )/异步</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader</span><br></pre></td></tr></table></figure>
<h1 id="手写-banner-loader-在打包的-js-前面加上相同前缀"><a href="#手写-banner-loader-在打包的-js-前面加上相同前缀" class="headerlink" title="手写 banner-loader 在打包的 js 前面加上相同前缀"></a>手写 banner-loader 在打包的 js 前面加上相同前缀</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line">const validateOptions = require(&apos;schema-utils&apos;);//验证参数的类型是否正确</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">function loader(source)&#123;</span><br><span class="line">    let options = loaderUtils.getOptions(this);</span><br><span class="line">    let cb = this.async();</span><br><span class="line">    let schema =&#123;</span><br><span class="line">        type: &quot;object&quot;,</span><br><span class="line">        properties:&#123;</span><br><span class="line">            text:&#123;</span><br><span class="line">                type: &quot;string&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            filename:&#123;</span><br><span class="line">                type: &quot;string&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validateOptions(schema, options, &apos;banner-loader&apos;);</span><br><span class="line">    if(options.filename)&#123;</span><br><span class="line">        fs.readFile(options.filename, (err, data) =&gt; &#123;</span><br><span class="line">            this.addDependency(options.filename);//将文件加入webpack依赖文件中，修改后webpack自动打包</span><br><span class="line">            cb(null, `/**$&#123;data&#125;**/$&#123;source&#125;`)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cb(null, `/**$&#123;options.text&#125;**/$&#123;source&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader</span><br></pre></td></tr></table></figure>
<h1 id="手写-file-loader"><a href="#手写-file-loader" class="headerlink" title="手写 file-loader"></a>手写 file-loader</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line"></span><br><span class="line">function loader(source)&#123;</span><br><span class="line">    //根据传入的文件的二进制，然后转换成MD5文件，文件名是hash+后缀，返回文件名</span><br><span class="line">    let filename=loaderUtils.interpolateName(this,&apos;[hash].[ext]&apos;,&#123;content: source&#125;);</span><br><span class="line">    this.emitFile(filename, source); //发射文件放到dist里面</span><br><span class="line">    return `module.exports= &quot;$&#123;filename&#125;&quot;`//返回MD5文件路径</span><br><span class="line">&#125;</span><br><span class="line">loader.raw = true //二进制</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure>
<h1 id="手写-url-loader"><a href="#手写-url-loader" class="headerlink" title="手写 url-loader"></a>手写 url-loader</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line">const fileLoader= require(&apos;./file-loader&apos;);</span><br><span class="line">let mime =require(&apos;mime&apos;);</span><br><span class="line"></span><br><span class="line">function loader(source)&#123;</span><br><span class="line">    let &#123;limit &#125; = loaderUtils.getOptions(this);</span><br><span class="line">    if(limit&amp;&amp;source.length&gt;limit)&#123;</span><br><span class="line">        return fileLoader.call(this, source)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //返回base64格式 mime获取文件类型</span><br><span class="line">        return `module.exports = &quot;data:$&#123;mime.getType(this.resourcePath)&#125;;base64,$&#123;source.toString(&apos;base64&apos;)&#125;&quot;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">loader.raw = true</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure>
<h1 id="css-loader-解析-background-url-‘-img-jpg’-将路径变成-require-‘-img-jpg’"><a href="#css-loader-解析-background-url-‘-img-jpg’-将路径变成-require-‘-img-jpg’" class="headerlink" title="css-loader 解析 background: url(‘./img.jpg’)将路径变成 require(‘./img.jpg’)"></a>css-loader 解析 background: url(‘./img.jpg’)将路径变成 require(‘./img.jpg’)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loader(source)&#123;</span><br><span class="line">    let reg = /url\((.+?)\)/g;</span><br><span class="line">    let pos = 0;</span><br><span class="line">    let current;</span><br><span class="line">    let arr = [&apos;let list = []&apos;];//将css各部分拼接</span><br><span class="line">    while(current = reg.exec(source))&#123;</span><br><span class="line">        let [matchUrl, g] = current;//匹配到的整体内容和括号里面的内容</span><br><span class="line">        let last = reg.lastIndex-matchUrl.length;</span><br><span class="line">        arr.push(`list.push($&#123;JSON.stringify(source.slice(pos,last))&#125;)`);</span><br><span class="line">        pos =reg.lastIndex;</span><br><span class="line">        //把g替换成require的写法，=》url(require(&apos;xxx))</span><br><span class="line">        arr.push(`list.push(&apos;url(&apos;+require($&#123;g&#125;)+&apos;)&apos;)`);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(`list.push($&#123;JSON.stringify(source.slice(pos))&#125;)`)</span><br><span class="line">    arr.push(`module.exports= list.join(&apos;&apos;)`);</span><br><span class="line">    return arr.join(&apos;\r\n&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader</span><br></pre></td></tr></table></figure>
<h1 id="loader-pitch"><a href="#loader-pitch" class="headerlink" title="loader.pitch"></a>loader.pitch</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在style-loader上 写了pitch</span><br><span class="line">// style-loader     less-loader!css-loader!./index.less</span><br><span class="line">loader.pitch = function (remainingRequest) &#123; // 剩余的请求</span><br><span class="line">  // 让style-loader 去处理less-loader!css-loader/./index.less</span><br><span class="line">  // require路径 返回的就是css-loader处理好的结果 require(&apos;!!css-loader!less-loader!index.less&apos;)</span><br><span class="line">  let str = `</span><br><span class="line">    let style = document.createElement(&apos;style&apos;);</span><br><span class="line">    style.innerHTML = require($&#123;loaderUtils.stringifyRequest(this, &apos;!!&apos; + remainingRequest)&#125;);</span><br><span class="line">    document.head.appendChild(style);</span><br><span class="line">  `</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="手写文件列表-FileListPlugin"><a href="#手写文件列表-FileListPlugin" class="headerlink" title="手写文件列表 FileListPlugin"></a>手写文件列表 FileListPlugin</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FileListPlugin&#123;</span><br><span class="line">    constructor(&#123;filename&#125;)&#123;</span><br><span class="line">        this.filename=filename</span><br><span class="line">    &#125;</span><br><span class="line">    apply(complier)&#123;//编译后的文件</span><br><span class="line">        complier.hooks.emit.tap(&apos;FileListPlugin&apos;, (compilation) =&gt; &#123;</span><br><span class="line">            let &#123; assets &#125; = compilation;//编译后的静态资源</span><br><span class="line">            let content =&apos;## 文件名    文件大小\r\n&apos;</span><br><span class="line">            Object.entries(assets).forEach(([filename, statObj]) =&gt; &#123;</span><br><span class="line">                content += `- $&#123;filename&#125;    $&#123;statObj.size()&#125;\r\n`</span><br><span class="line">            &#125;)</span><br><span class="line">            //将生成的列表文件加入打包的资源中,根据该文件生成打包后的dist</span><br><span class="line">            assets[this.filename]=&#123;</span><br><span class="line">                source()&#123;</span><br><span class="line">                    return content</span><br><span class="line">                &#125;,</span><br><span class="line">                size()&#123;</span><br><span class="line">                    return content.length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = FileListPlugin</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new FileListPlugin(&#123;</span><br><span class="line">    filename:&apos;list.md&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="将-css-和-js-内联到-html-中"><a href="#将-css-和-js-内联到-html-中" class="headerlink" title="将 css 和 js 内联到 html 中"></a>将 css 和 js 内联到 html 中</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//把外联标签变成内联</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">class InlineSourcePlugin&#123;</span><br><span class="line">    constructor(&#123;match&#125;) &#123;</span><br><span class="line">        this.reg=match;</span><br><span class="line">    &#125;</span><br><span class="line">    processTag(tag, compilation)&#123;</span><br><span class="line">        let newTag,url;</span><br><span class="line">        if(tag.tagName === &apos;link&apos; &amp;&amp; this.reg.test(tag.attributes.href))&#123;</span><br><span class="line"></span><br><span class="line">            newTag = &#123;</span><br><span class="line">                tagName: &apos;style&apos;</span><br><span class="line">            &#125;;</span><br><span class="line">            url = tag.attributes.href;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tag.tagName === &apos;script&apos; &amp;&amp; this.reg.test(tag.attributes.src))&#123;</span><br><span class="line">            newTag = &#123;</span><br><span class="line">                tagName: &apos;script&apos;</span><br><span class="line">            &#125;;</span><br><span class="line">            url = tag.attributes.src;</span><br><span class="line">        &#125;</span><br><span class="line">        if(url)&#123;</span><br><span class="line">            newTag.innerHTML = compilation.assets[url].source();</span><br><span class="line">            delete compilation.assets[url];</span><br><span class="line">            return newTag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return tag</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    processTags(data, compilation)&#123;</span><br><span class="line">        let headTags = [];</span><br><span class="line">        let bodyTags = [];</span><br><span class="line">        data.headTags.forEach(headTag =&gt; &#123;</span><br><span class="line">            headTags.push(this.processTag( headTag, compilation))</span><br><span class="line">        &#125;)</span><br><span class="line">        data.bodyTags.forEach(bodyTag =&gt; &#123;</span><br><span class="line">            bodyTags.push(this.processTag( bodyTag, compilation))</span><br><span class="line">        &#125;)</span><br><span class="line">        return &#123; ...data, headTags, bodyTags&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">        compiler.hooks.compilation.tap(&apos;InlineSourcePlugin&apos;, (compilation) =&gt; &#123;</span><br><span class="line">            HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync(&apos;MyPlugin&apos;, (data, cb) =&gt; &#123;</span><br><span class="line">                data = this.processTags(data, compilation)</span><br><span class="line">                cb(null ,data)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = InlineSourcePlugin</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2019/04/05/ES6/</url>
    <content><![CDATA[<p>ES6 ES2015</p>
<a id="more"></a>
<h2 id="所有属性"><a href="#所有属性" class="headerlink" title="所有属性"></a>所有属性</h2><p>详情见 <a href="https://www.jianshu.com/writer#/notebooks/40257545/notes/31568992" target="_blank" rel="noopener">简书 ES6</a></p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li>let const</li>
<li>=&gt;箭头函数</li>
<li>Set,Map</li>
<li>…</li>
<li>解构赋值</li>
<li>for of 遍历数组、Set、Map 结构、类数组，字符串</li>
<li>es6 Module</li>
<li>扩展操作符</li>
<li>class,extends</li>
<li>Symbol</li>
<li><p>Proxy 代理，第一代理监听对象的操作<br>用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）<br><code>Reflect</code>是一个内置对象，提供拦截 JS 操作的方法。这些方法与<code>Proxy</code>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const observe = (data, callback) =&gt; &#123;</span><br><span class="line">    return new Proxy(data, &#123;</span><br><span class="line">        get(target, key) &#123;</span><br><span class="line">            return Reflect.get(target, key)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, key, value, proxy) &#123;</span><br><span class="line">            callback(key, value);</span><br><span class="line">            target[key] = value;</span><br><span class="line">            return Reflect.set(target, key, value, proxy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const FooBar = &#123;</span><br><span class="line">    open: false</span><br><span class="line">&#125;;</span><br><span class="line">const FooBarObserver = observe(FooBar, (property, value) =&gt; &#123;</span><br><span class="line">    property === &apos;open&apos; &amp;&amp; value ? console.log(&apos;FooBar is open!!!&apos;) : console.log(&apos;keep waiting&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(FooBarObserver.open) //false</span><br><span class="line">FooBarObserver.open = true; //FooBar is open!!!</span><br><span class="line">console.log(FooBarObserver.open) //true</span><br></pre></td></tr></table></figure>
<p>如果对象带有<code>configurable: false</code> 跟<code>writable: false</code>属性，则代理失效。</p>
</li>
<li><p>Promise 见<a href="https://dorisfeng.github.io/2020/06/22/JS-Promise/">JS-Promise</a></p>
</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>对象属性简写</li>
<li>迭代器、生成器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* makeRangeIterator(start = 0, end = Infinity, step = 1) &#123;</span><br><span class="line">    for (let i = start; i &lt; end; i += step) &#123;</span><br><span class="line">        yield i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = makeRangeIterator(1, 10, 2);</span><br><span class="line">console.log(a.next()); //&#123;value: 1, done: false&#125;</span><br><span class="line">console.log(a.next()); //&#123;value: 3, done: false&#125;</span><br><span class="line">console.log(a.next()); //&#123;value: 5, done: false&#125;</span><br><span class="line">console.log(a.next()); //&#123;value: 7, done: false&#125;</span><br><span class="line">console.log(a.next()); //&#123;value: 9, done: false&#125;</span><br><span class="line">console.log(a.next()); //&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Set/WeakSet</code><br><code>Set</code>对象允许存储任何类型的惟一值，无论是原始值还是对象引用。可以使用<code>Set</code>去重。<br><code>WeakSet</code>和<code>Set</code>的区别：</p>
<ul>
<li><code>WeakSet</code>对象只存放对象的引用，不存放值。</li>
<li><code>WeakSet</code>对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code>对象是无法被枚举的, 没有办法拿到它包含的所有元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ws = new WeakSet();</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let foo = &#123;&#125;;</span><br><span class="line">ws.add(window);</span><br><span class="line">ws.add(obj);</span><br><span class="line">console.log(ws.has(window)); //true 是否含有对象</span><br><span class="line">console.log(ws.has(foo)); //false</span><br><span class="line">ws.delete(window); //删除</span><br><span class="line">console.log(ws.has(window));</span><br><span class="line">ws.clear() // 清空整个 WeakSet 对象</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Map/WeakMap</code><br><code>Map</code>对象保存键值对。任何职（对象或原始值）都可以作为一个键或一个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, &apos;Not a number&apos;);</span><br><span class="line">console.log(myMap.get(NaN)); //&apos;not a number&apos;</span><br><span class="line">let otherNaN = Number(&apos;foo&apos;);</span><br><span class="line">console.log(myMap.get(otherNaN)) //&apos;not a number&apos;</span><br></pre></td></tr></table></figure>
<p><code>WeakMap</code>对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let wm1 = new WeakMap();</span><br><span class="line">let wm2 = new WeakMap();</span><br><span class="line">let o1 = &#123;&#125;,</span><br><span class="line">    o2 = function () &#123;&#125;,</span><br><span class="line">    o3 = window;</span><br><span class="line">wm1.set(o1, 37);</span><br><span class="line">wm1.set(o2, &apos;aaa&apos;);</span><br><span class="line">wm2.set(o1, o2); //value 可以是任意值，包括对象</span><br><span class="line">wm2.set(o3, undefined);</span><br><span class="line">console.log(wm1.get(o1));</span><br><span class="line">console.log(wm1.get(o2));</span><br><span class="line">console.log(wm2.get(o2));</span><br><span class="line">console.log(wm2.get(o3));</span><br><span class="line">console.log(wm1.has(o2)); // true</span><br><span class="line">console.log(wm2.has(o2)); // false</span><br><span class="line">wm1.delete(o1);</span><br><span class="line">console.log(wm1.get(o1)); //undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math</code>对象的扩展</p>
<ul>
<li><code>Number.EPSILON</code>：数值最小精度</li>
<li><code>Number.isFinite()</code> : 是否为有限数值</li>
<li><code>Number.isNaN()</code> : 是否为 NaN</li>
<li><code>Number.isInteger()</code> : 是否为整数</li>
<li><code>Number.isSafeInteger()</code> : 是否在数值安全范围内</li>
</ul>
</li>
<li><p><code>Array</code>对象的扩展</p>
<ul>
<li><code>Array.from()</code> 转换具有<code>Interator</code>接口的数据结构为真正的数组，返回新数组。</li>
<li><p><code>Array.of()</code> 将参数转换为数组，返回新数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.of(7)       // [7]</span><br><span class="line">Array.of(1, 2, 3) // [1, 2, 3]</span><br><span class="line">Array(7)          // [empty, empty, empty, empty, empty, empty]</span><br><span class="line">Array(1, 2, 3)    // [1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.copyWithin(target,start[,end])</code> 把指定位置的成员复制到其他位置，返回新数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;];</span><br><span class="line">console.log(array1.copyWithin(0, 3, 4));//[&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line">console.log(array1.copyWithin(1, 3));//[&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;f&quot;, &quot;g&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.find()</code>：返回第一个符合条件的成员</p>
</li>
<li><code>Array.prototype.findIndex()</code>：返回第一个符合条件的成员索引值</li>
<li><code>Array.prototype.fill(value, start,end)</code>：根据指定值填充整个数组，修改并返回原数组<ul>
<li>value，数组的填充值</li>
<li>start, 开始下标，默认 0</li>
<li>end，结束下标，默认数组长度，缺省或者结束下标大于数组长度-开始坐标时填充到数组最后一个元素</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;];</span><br><span class="line">array1.fill(0, 2, 4);</span><br><span class="line">console.log(array1); //[&quot;a&quot;, &quot;b&quot;, 0, 0, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line">array1.fill(5, 4);</span><br><span class="line">console.log(array1);//[&quot;a&quot;, &quot;b&quot;, 0, 0, 5, 5, 5]</span><br><span class="line">array1.fill(7, 4, 10);</span><br><span class="line">console.log(array1);// [&quot;a&quot;, &quot;b&quot;, 0, 0, 7, 7, 7]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h2 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. <code>let、const、var</code>的区别</h2><ul>
<li><code>var</code>声明的变量存着变量提升，<code>let</code>和<code>const</code>声明的变量存在暂时性死区不会提升。</li>
<li><code>var</code> 声明的变量只有全局作用域和函数作用域，没有块级作用域，但是<code>let</code>和<code>const</code>声明的变量存着块级作用域（一对<code>{}</code>之间）；</li>
<li>全局作用域下<code>let</code>和<code>const</code>什么的变量不会被挂载到 window 上，但是<code>var</code>声明的全局变量会挂载到 window 上</li>
<li><code>var</code>可以重复声明相同变量，<code>let</code>和<code>const</code>会报错</li>
<li><code>const</code>声明后必须赋值，否则报错。改变<code>const</code>变量也会报错</li>
</ul>
<h2 id="2-暂存性死区"><a href="#2-暂存性死区" class="headerlink" title="2. 暂存性死区"></a>2. 暂存性死区</h2><p>在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">   var foo = 33;</span><br><span class="line">   &#123;</span><br><span class="line">       let foo = (foo + 55); // ReferenceError</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<h2 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3. 模块化"></a>3. 模块化</h2><p>为什么要模块化？好处</p>
<ul>
<li>解决命名冲突</li>
<li>提供复用性</li>
<li>提供代码可维护性</li>
</ul>
<p><strong>立即执行函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(globalVariable)&#123;</span><br><span class="line">   globalVariable.test = function() &#123;&#125;</span><br><span class="line">   // ... 声明各种变量、函数都不会污染全局作用域</span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure>
<p><strong>AMD 和 CMD</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//AMD</span><br><span class="line">define([&apos;./a&apos;,&apos;./b&apos;],function(a,b)&#123;</span><br><span class="line">    //加载模块完毕可以使用</span><br><span class="line">    a.do();</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line">//CMD</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    //加载模块</span><br><span class="line">    var a=require(&apos;./a.js&apos;);</span><br><span class="line">    a.do()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>CommonJS</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//a.js</span><br><span class="line">let a=1;</span><br><span class="line">module.exports=&#123;a&#125;;</span><br><span class="line">//or</span><br><span class="line">exports.a=1;</span><br><span class="line">//b.js</span><br><span class="line">var module=require(&apos;./a.js&apos;);</span><br><span class="line">module.a;//1</span><br></pre></td></tr></table></figure>
<p>详见《JS-CommonJS》<br><strong>ES Module</strong><br>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：</p>
<ul>
<li><code>CommonJS</code>支持动态导入，就是<code>require(${path}/xx.js)</code>，<code>ES Module</code>不支持，但是已有提案。</li>
<li><code>CommonJS</code>是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不是很大。<code>ES Module</code>是异步导入，因为浏览器需要下载文件，如果也采用同步导入就会对渲染有很大影响。</li>
<li><code>CommomnJS</code>在导出时是值拷贝，导入之后就跟脚本的变化无关，如果需要更新就要清除缓存，重新导入。<code>ES Module</code>采用实时绑定的方式，导入导出的值指向同一内存地址，，所以导入值会跟随导出值变化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入模块 API</span><br><span class="line">import XXX from &apos;./a.js&apos;</span><br><span class="line">import &#123; XXX &#125; from &apos;./a.js&apos;</span><br><span class="line">// 导出模块 API</span><br><span class="line">export let a=1;</span><br><span class="line">export function a() &#123;&#125;</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line">let a=1;</span><br><span class="line">export &#123;a as arg1&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>重命名使用<code>as</code></li>
<li>import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面改写接口，报错。</li>
<li>import 命令具有提升效果，会提升到整个模块的头部，首先执行。</li>
<li>import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li>
</ol>
<h2 id="4-使用箭头函数应该注意什么"><a href="#4-使用箭头函数应该注意什么" class="headerlink" title="4.使用箭头函数应该注意什么"></a>4.使用箭头函数应该注意什么</h2><ul>
<li>箭头函数里面的<code>this</code>不在指向<code>window</code>，而是父级</li>
<li>不可以作为构造函数，不能使用<code>new</code>命令</li>
<li>不可以使用 <code>arguments</code> 对象，不存在，可以使用 <code>rest</code> 代替</li>
<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数</li>
</ul>
<h2 id="5-ES6-模板字符串有哪些新特性？并实现一个类模板字符串的功能"><a href="#5-ES6-模板字符串有哪些新特性？并实现一个类模板字符串的功能" class="headerlink" title="5.ES6 模板字符串有哪些新特性？并实现一个类模板字符串的功能"></a>5.ES6 模板字符串有哪些新特性？并实现一个类模板字符串的功能</h2><ul>
<li>基本的字符串格式化。</li>
<li>字符串拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name = &apos;web&apos;;</span><br><span class="line">let age = 10;</span><br><span class="line">let str = &apos;你好，$&#123;name&#125; 已经 $&#123;age&#125;岁了&apos;</span><br><span class="line">str = str.replace(/\$\&#123;([^&#125;]*)\&#125;/g,function()&#123;</span><br><span class="line">    return eval(arguments[1]);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str);//你好，web 已经 10岁了</span><br></pre></td></tr></table></figure>
<h2 id="6-Set-和-Map-的区别"><a href="#6-Set-和-Map-的区别" class="headerlink" title="6.Set 和 Map 的区别"></a>6.Set 和 Map 的区别</h2><ul>
<li>Set<ul>
<li>成员不能重复</li>
<li>键名和键值相同，类似数组</li>
<li>可以遍历</li>
<li>所有值按照设置顺序排列</li>
<li>无法通过迭代器直接改变值（因为键值就是键名）</li>
</ul>
</li>
<li>Map:<ul>
<li>本质上是健值对的集合，类似集合</li>
<li>键名不允许重复</li>
<li>可以遍历，可以跟各种数据格式转换</li>
<li>键是不能修改的，但是其键对应的值是可以修改的</li>
</ul>
</li>
</ul>
<h2 id="7-使用结构赋值，实现两个变量的值的交换"><a href="#7-使用结构赋值，实现两个变量的值的交换" class="headerlink" title="7.使用结构赋值，实现两个变量的值的交换"></a>7.使用结构赋值，实现两个变量的值的交换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a=1,b=2;</span><br><span class="line">[a,b]=[b,a]</span><br></pre></td></tr></table></figure>
<h2 id="8-设计一个对象，键名的类型至少包含一个-symbol-类型，并且实现遍历所有-key"><a href="#8-设计一个对象，键名的类型至少包含一个-symbol-类型，并且实现遍历所有-key" class="headerlink" title="8.设计一个对象，键名的类型至少包含一个 symbol 类型，并且实现遍历所有 key"></a>8.设计一个对象，键名的类型至少包含一个 symbol 类型，并且实现遍历所有 key</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line">    name:&apos;Lily&apos;,</span><br><span class="line">    [Symbol(&apos;Lily&apos;)]:&apos;student&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let keys = Reflect.ownKeys(obj);</span><br></pre></td></tr></table></figure>
<p><a href="https://dorisfeng.github.io/2019/10/11/%E5%AF%B9%E8%B1%A1-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/">对象遍历方法</a></p>
<h2 id="9-set"><a href="#9-set" class="headerlink" title="9.set"></a>9.set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s = newSet();</span><br><span class="line">s.add([1]);s.add([1]);</span><br><span class="line">console.log(s.size);//2</span><br></pre></td></tr></table></figure>
<p><strong>注意：数组（对象）是引用类型，所以两个是不相等的。另外在 Set 内部，两个 NaN 是相等</strong></p>
<h2 id="10-理解-async-await-以及对-Generator-的优势"><a href="#10-理解-async-await-以及对-Generator-的优势" class="headerlink" title="10.理解 async/await 以及对 Generator 的优势"></a>10.理解 async/await 以及对 Generator 的优势</h2><p>async 函数是 Generator 函数的语法糖。<br>当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。可以理解，await 后面的语句是放到 Promise.then()去执行的。<br>async 较 Generator 的优势：<br>（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样<br>（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　<br>（3）更广的适用性。yield 命令后面只能是 Thunk 函数或 Promise 对象，async 函数的 await 后面可以是 Promise 也可以是原始类型的值<br>（4）返回值是 Promise。async 函数返回的是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</p>
<h2 id="11-forEach、for-in、for-of-三者区别"><a href="#11-forEach、for-in、for-of-三者区别" class="headerlink" title="11. forEach、for in、for of 三者区别"></a>11. forEach、for in、for of 三者区别</h2><ul>
<li><code>forEach</code>更多的用来遍历数组</li>
<li><code>for key in</code> 一般常用来遍历对象或 json</li>
<li><code>for of</code>数组,可以通过 Object.keys()获取对象 key 遍历对象</li>
</ul>
<h2 id="12-Proxy-来实现一个数据响应式"><a href="#12-Proxy-来实现一个数据响应式" class="headerlink" title="12. Proxy 来实现一个数据响应式"></a>12. Proxy 来实现一个数据响应式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">    let handler = &#123;</span><br><span class="line">        get(target, property, receiver) &#123;</span><br><span class="line">            getLogger(target, property)</span><br><span class="line">            return Reflect.get(target, property, receiver)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, property, value, receiver) &#123;</span><br><span class="line">            setBind(value, property)</span><br><span class="line">            return Reflect.set(target, property, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">let p = onWatch(obj,</span><br><span class="line">    (v, property) =&gt; &#123;</span><br><span class="line">        console.log(`监听到属性&apos;$&#123;property&#125;&apos;改变为$&#123;v&#125;`)</span><br><span class="line">    &#125;,</span><br><span class="line">    (target, property) =&gt; &#123;</span><br><span class="line">        console.log(`获取属性&apos;$&#123;property&#125;&apos;的值为$&#123;target[property]&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">p.a; //获取属性&apos;a&apos;的值为1</span><br><span class="line">p.a = 2; //监听到属性&apos;a&apos;改变为2</span><br><span class="line">p.a //获取属性&apos;a&apos;的值为2</span><br></pre></td></tr></table></figure>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>利用 gulp 将 es6 转为 es5<br>目录结构<br><img src="/2019/04/05/ES6/目录结构.jpg" alt="目录结构"><br>全局模块安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install babel-cli -g</span><br></pre></td></tr></table></figure>
<p>package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;learn-es6&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;browser-sync&quot;: &quot;^2.26.3&quot;,</span><br><span class="line">    &quot;gulp&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;gulp-babel&quot;: &quot;^7.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>babel 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;es2015&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gulp 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var babel = require(&apos;gulp-babel&apos;);</span><br><span class="line">var browserSync = require(&apos;browser-sync&apos;).create();</span><br><span class="line">var reload = browserSync.reload;</span><br><span class="line">gulp.task(&apos;js&apos;,() =&gt; &#123;</span><br><span class="line">    return gulp.src(&apos;./src/index.js&apos;)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets:[&apos;es2015&apos;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;./dist/&apos;))</span><br><span class="line">        .pipe(reload(&#123;stream:true&#125;))</span><br><span class="line">&#125;)</span><br><span class="line">gulp.task(&apos;default&apos;,() =&gt; &#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server:&#123;</span><br><span class="line">            baseDir:&apos;./&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        port:&apos;8080&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.watch(&apos;./src/*.js&apos;,gulp.series([&apos;js&apos;]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
  </entry>
  <entry>
    <title>webpack之Tapable</title>
    <url>/2019/04/04/webpack%E4%B9%8BTapable/</url>
    <content><![CDATA[<p>webpack 里面使用的</p>
<a id="more"></a>
<h1 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h1><p>webpack 是一种事件流机制，将各个插件串联起来，wbpack 使用 Tapable 进行编译</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add apable</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同步钩子 SyncHook</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; SyncHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Lesson&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new SyncHook([&apos;name])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap()&#123;//注册监听函数</span><br><span class="line">        this.hooks.arch.tap(&apos;node&apos;,function()&#123;</span><br><span class="line">            console.log(&apos;node&apos;,name)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arc.tap(&apos;node&apos;,function()&#123;</span><br><span class="line">            console.log(&apos;node&apos;,name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.call(&apos;fdd&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let l =new Lesson()</span><br><span class="line">l.tap()  //注册钩子</span><br><span class="line">l.start()  //启动钩子</span><br></pre></td></tr></table></figure>
<ul>
<li>SyncHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SyncHook&#123;</span><br><span class="line">    constructor(args)&#123; // args =》[&apos;name&apos;]</span><br><span class="line">        this.tasks=[]</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.task.push(task)</span><br><span class="line">    &#125;,</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">        this.tasks.forEach(task=&gt; task(...args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new SyncHook([&apos;name&apos;])</span><br><span class="line">hook.tap(&apos;react&apos;,function(name)&#123;</span><br><span class="line">    console.log(&apos;react&apos;,name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;node&apos;,function(name)&#123;</span><br><span class="line">    console.log(&apos;node&apos;,name</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(&apos;fdd&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncBailHook 可熔断钩子 return 非 undefined 的值就停止向下执行</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; SyncBailHook &#125; = require(&apos;tapable&apos;）</span><br><span class="line">class Lesson&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks = &#123;</span><br><span class="line">            arch: new SyncBailHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap()&#123;  //注册监听函数</span><br><span class="line">        this.hooks.arch.tap(&apos;node&apos;,function(name)&#123;</span><br><span class="line">            console.log(&apos;node&apos;,name)</span><br><span class="line">            return &apos;停止学习&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tap(&apos;react&apos;,function(name)&#123;</span><br><span class="line">            console.log(&apos;react&apos;,name)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     start()&#123;</span><br><span class="line">        this.hooks.arch.call(&apos;fdd&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let l =new Lesson()</span><br><span class="line">l.tap()  //注册钩子</span><br><span class="line">l.start()  //启动钩子</span><br></pre></td></tr></table></figure>
<ul>
<li>SyncBailHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SyncBailHook&#123;</span><br><span class="line">    constructor(arg)&#123;</span><br><span class="line">        this.tasks=[]</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name,task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">        let ret; //当前task的返回值</span><br><span class="line">        let index=0;//当前要执行的第一个</span><br><span class="line">        do&#123;</span><br><span class="line">        ret = this.tasks[ index++ ](...args)</span><br><span class="line">        &#125;while(ret===undefined &amp;&amp; index&lt;this.tasks.length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new SyncBailHook([&apos;name&apos;])</span><br><span class="line">hook.tap(&apos;react&apos;,function(name)&#123;</span><br><span class="line">    console.log(&apos;react&apos;,name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;node&apos;,function(name)&#123;</span><br><span class="line">    console.log(&apos;node&apos;,name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(&apos;fdd&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncWaterfallHook 瀑布流钩子</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; SyncWaterfallHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Less&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new SyncWaterfallHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.hooks.arch.tap(&apos;node&apos;, function(name)&#123;</span><br><span class="line">            console.log(&apos;node&apos;, name);</span><br><span class="line">            return &apos;node学习&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tap(&apos;react&apos;,function(data)&#123;</span><br><span class="line">            console.log(&apos;react&apos;,data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.call(&apos;fdd&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    let l =new Lesson()</span><br><span class="line">    l.tap()  //注册钩子</span><br><span class="line">    l.start()  //启动钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SyncWaterfallHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class  SyncWaterfallHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">        this.tasks=[]...args</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">        let [ first, ...others] = this.tasks;</span><br><span class="line">        let ret = first(...args)</span><br><span class="line">        others.reduce((a, b) =&gt; b(a),ret) /将a的结果传递给b，初始值为第一个函数的执行结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new SyncWaterfallHook([&apos;name&apos;]);</span><br><span class="line">hook.tap(&apos;react&apos;, function(name)&#123;</span><br><span class="line">    console.log(&apos;react&apos;, name);</span><br><span class="line">    return &apos;reactOk&apos;</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;node&apos;, function(data)&#123;</span><br><span class="line">  console.log(&apos;node&apos;, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;webpack&apos;, function(data)&#123;</span><br><span class="line">  console.log(&apos;webpack&apos;, data)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(&apos;fdd&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SyncLoopHook 同步遇到某个不返回 undefinedj 的监听函数循环执行</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; SyncLoopHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">    class Less&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line">            this.index=0;</span><br><span class="line">            this.hooks=&#123;</span><br><span class="line">                arch: new SyncLoopHook([&apos;name&apos;])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tap(name, task)&#123;</span><br><span class="line">            this.hooks.arch.tap(&apos;node&apos;,(name) =&gt;&#123;</span><br><span class="line">                console.log(&apos;node&apos;, name);</span><br><span class="line">                return  index++===3?return undefined: &apos;node学习&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">            this.hooks.arch.tap(&apos;react&apos;,(data) =&gt;&#123;</span><br><span class="line">                console.log(&apos;react&apos;,data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        call()&#123;</span><br><span class="line">            this.hooks.arch.call(&apos;fdd&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        let l =new Lesson()</span><br><span class="line">        l.tap()  //注册钩子</span><br><span class="line">        l.start()  //启动钩子</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SyncLoopHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class  SyncLoopHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">        this.tasks=[]...args</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">       this.tasks.forEach(task =&gt; &#123;</span><br><span class="line">           let ret;</span><br><span class="line">           do&#123;</span><br><span class="line">            ret = task(...args)</span><br><span class="line">           &#125; while(ret!== undefined)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new SyncLoopHook([&apos;name&apos;]);</span><br><span class="line">let total=0</span><br><span class="line">hook.tap(&apos;react&apos;, function(name)&#123;</span><br><span class="line">    console.log(&apos;react&apos;, name);</span><br><span class="line">    return ++total===3?undefined:&apos;reactOk&apos;</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;node&apos;, function(name)&#123;</span><br><span class="line">  console.log(&apos;node&apos;, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tap(&apos;webpack&apos;, function(name)&#123;</span><br><span class="line">  console.log(&apos;webpack&apos;, name)</span><br><span class="line">&#125;)</span><br><span class="line">hook.call(&apos;fdd&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncParallelHook 异步并行<br>异步的钩子，并行执行，同发送多了请求，需要等待所有并发异步时间执行后再执行回调方法<br>注册方法 tap 和 tapAsync,tapPromise</p>
<ul>
<li><p>使用 异步注册 tapAsync</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Less&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new AsyncParallelHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.hooks.arch.tapAsync(&apos;node&apos;, (name, cb)=&gt;&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">               console.log(&apos;node&apos;, name);</span><br><span class="line">               cb()</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tapAsync(&apos;react&apos;,(name, cb)=&gt;&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">               console.log(&apos;react&apos;, name);</span><br><span class="line">               cb()</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.callAsync(&apos;fdd&apos;,function()&#123;</span><br><span class="line">            console.log(&apos;end&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    let l =new Lesson()</span><br><span class="line">    l.tap()  //注册钩子</span><br><span class="line">    l.start()  //启动钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AsyncParallelHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class  AsyncParallelHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">        this.tasks=[]...args</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">       let finalCallback=args.pop() //拿到最后的回调函数</span><br><span class="line">       let index = 0;</span><br><span class="line">      let next = () =&gt; &#123;</span><br><span class="line">           index++;</span><br><span class="line">           if(index===this.tasks.length)&#123;</span><br><span class="line">               finalCallback()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       this.tasks.forEach(task =&gt; &#123;</span><br><span class="line">           task(...args, done)</span><br><span class="line">       &#125; )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new AsyncParallelHook([&apos;name&apos;]);</span><br><span class="line">hook.tapAsync(&apos;react&apos;, (name,cb) =&gt;&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">       console.log(&apos;react&apos;, name);</span><br><span class="line">       cb()</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(&apos;node&apos;, (name,cb) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;node&apos;, name);</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(&apos;fdd&apos;,function()&#123;</span><br><span class="line">    console.log(&apos;end&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 promise 注册 tapPromise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Less&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new AsyncParallelHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.hooks.arch.tapPromise(&apos;node&apos;, (name)=&gt;&#123;</span><br><span class="line">            return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">                 console.log(&apos;node&apos;, name);</span><br><span class="line">                 resolve()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tapPromise(&apos;react&apos;,(name)=&gt;&#123;</span><br><span class="line">             return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">                 console.log(&apos;react&apos;, name);</span><br><span class="line">                 resolve()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.promise(&apos;fdd&apos;).then(function()&#123;</span><br><span class="line">            console.log(&apos;end&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    let l =new Lesson()</span><br><span class="line">    l.tap()  //注册钩子</span><br><span class="line">    l.start()  //启动钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncParallelHook promise 注册 实现原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class  AsyncParallelHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">        this.tasks=[]...args</span><br><span class="line">    &#125;</span><br><span class="line">    tapPromise(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    promise(...args)&#123;</span><br><span class="line">      let tasks= this.tasks.map(task =&gt;task(...args))</span><br><span class="line">      return Promise.all(tasks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let hook= new SyncWaterfallHook([&apos;name&apos;]);</span><br><span class="line">hook.tapPromise(&apos;react&apos;, (name) =&gt;&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt;</span><br><span class="line">       console.log(&apos;react&apos;, name);</span><br><span class="line">       resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(&apos;node&apos;, (name) =&gt; &#123;</span><br><span class="line">   return new Promise((resolve,reject) =&gt;</span><br><span class="line">       console.log(&apos;node&apos;, name);</span><br><span class="line">       resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(&apos;fdd&apos;).then(function()&#123;</span><br><span class="line">    console.log(&apos;end&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>AsyncSeriesHook 异步串行</p>
<ul>
<li>使用 异步注册 tapAsync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncSeriesHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Less&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new AsyncSeriesHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.hooks.arch.tapAsync(&apos;node&apos;, (name, cb)=&gt;&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">               console.log(&apos;node&apos;, name);</span><br><span class="line">               cb()</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tapAsync(&apos;react&apos;,(name, cb)=&gt;&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">               console.log(&apos;react&apos;, name);</span><br><span class="line">               cb()</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.callAsync(&apos;fdd&apos;,function()&#123;</span><br><span class="line">            console.log(&apos;end&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    let l =new Lesson()</span><br><span class="line">    l.tap()  //注册钩子</span><br><span class="line">    l.start()  //启动钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AsyncSeriesHook 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class  AsyncSeriesHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">        this.tasks=[]...args</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    call(...args)&#123;</span><br><span class="line">        let finalCallback=args.pop() //拿到最后的回调函数</span><br><span class="line">        let index = 0;</span><br><span class="line">        let next = () =&gt; &#123;</span><br><span class="line">            if(index===this.tasks.length)&#123;</span><br><span class="line">                return  finalCallback()</span><br><span class="line">            &#125;</span><br><span class="line">            let task = this.tasks[index++];</span><br><span class="line">            task(...args, next)</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new AsyncSeriesHook([&apos;name&apos;]);</span><br><span class="line">hook.tapAsync(&apos;react&apos;, (name,cb) =&gt;&#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;react&apos;, name);</span><br><span class="line">        cb()</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapAsync(&apos;node&apos;, (name,cb) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;node&apos;, name);</span><br><span class="line">    cb()</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">hook.callAsync(&apos;fdd&apos;,function()&#123;</span><br><span class="line">    console.log(&apos;end&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 promise 注册 tapPromise</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncSeriesHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Less&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arch: new AsyncSeriesHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap(name, task)&#123;</span><br><span class="line">        this.hooks.arch.tapPromise(&apos;node&apos;, (name)=&gt;&#123;</span><br><span class="line">            return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                console.log(&apos;node&apos;, name);</span><br><span class="line">                resolve()</span><br><span class="line">                &#125;,1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arch.tapPromise(&apos;react&apos;,(name)=&gt;&#123;</span><br><span class="line">           return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    console.log(&apos;react&apos;, name);</span><br><span class="line">                    resolve()</span><br><span class="line">                &#125;,1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arch.promise(&apos;fdd&apos;).then(function()&#123;</span><br><span class="line">            console.log(&apos;end&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    let l =new Lesson()</span><br><span class="line">    l.tap()  //注册钩子</span><br><span class="line">    l.start()  //启动钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AsyncSeriesHook promise 实现原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AsyncSeriesHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">    this.tasks=[]</span><br><span class="line">    &#125;</span><br><span class="line">    tapPromise(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    promise(...args)&#123;</span><br><span class="line">    let [ first, ...others]=this.tasks;</span><br><span class="line">    return others.reduce((p,n) =&gt; &#123;</span><br><span class="line">        return  p.then(()=&gt;n(...args))</span><br><span class="line">    &#125;,first(...args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new AsyncSeriesHook([&apos;name&apos;])</span><br><span class="line">hook.tapPromise(&apos;react&apos;,(name) =&gt;&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&apos;react&apos;, name);</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(&apos;node&apos;,(name) =&gt;&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&apos;node&apos;, name);</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(&apos;fdd&apos;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;end1&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncSeriesWaterfallHook 异步串行瀑布流钩子</p>
<ul>
<li>使用 tapAsync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncSeriesWaterfallHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">  class Less&#123;</span><br><span class="line">      constructor()&#123;</span><br><span class="line">          this.hooks=&#123;</span><br><span class="line">              arch: new AsyncSeriesWaterfallHook([&apos;name&apos;])</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tap(name, task)&#123;</span><br><span class="line">          this.hooks.arch.tapAsync(&apos;node&apos;, (name, cb)=&gt;&#123;</span><br><span class="line">              setTimeout(() =&gt; &#123;</span><br><span class="line">                  console.log(&apos;node&apos;, name);</span><br><span class="line">                  cb(null,&apos;result)</span><br><span class="line">              &#125;,1000)</span><br><span class="line">          &#125;)</span><br><span class="line">          this.hooks.arch.tapAsync(&apos;react&apos;,(data, cb)=&gt;&#123;</span><br><span class="line">                  setTimeout(() =&gt; &#123;</span><br><span class="line">                      console.log(&apos;react&apos;, data);</span><br><span class="line">                      cb(null)</span><br><span class="line">                  &#125;,1000)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      start()&#123;</span><br><span class="line">          this.hooks.arch.callAsync(&apos;fdd&apos;,function()&#123;</span><br><span class="line">              console.log(&apos;end&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      let l =new Lesson()</span><br><span class="line">      l.tap()  //注册钩子</span><br><span class="line">      l.start()  //启动钩子</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现原理 tapAsync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AsyncSeriesWaterfallHook&#123;</span><br><span class="line">     constructor(args)&#123;</span><br><span class="line">     this.tasks=[]</span><br><span class="line">     &#125;</span><br><span class="line">     tapAsync(name, task)&#123;</span><br><span class="line">         this.tasks.push(task)</span><br><span class="line">     &#125;</span><br><span class="line">     callAsync(...args)&#123;</span><br><span class="line">     let index =0;</span><br><span class="line"></span><br><span class="line">     let finalCallback = args.pop();</span><br><span class="line">     let next = (err, data)=&gt;&#123;</span><br><span class="line">         let task = this.tasks[index];</span><br><span class="line">         if(!task) return finalCallback();</span><br><span class="line">         if(index===0)&#123;</span><br><span class="line">             task(...args,next)</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             if(err === null)&#123;</span><br><span class="line">                 task(data,next);</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 finalCallback();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         index++</span><br><span class="line">     &#125;</span><br><span class="line">     next()</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let hook= new AsyncSeriesWaterfallHook([&apos;name&apos;])</span><br><span class="line"> hook.tapAsync(&apos;react&apos;,(name, cb) =&gt;&#123;</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">         console.log(&apos;react&apos;, name);</span><br><span class="line">         cb(&apos;1&apos;,111)</span><br><span class="line">     &#125;,1000)</span><br><span class="line"> &#125;)</span><br><span class="line"> hook.tapAsync(&apos;node&apos;,(data, cb) =&gt;&#123;</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">         console.log(&apos;node&apos;, data);</span><br><span class="line">         cb()</span><br><span class="line">     &#125;,1000)</span><br><span class="line"> &#125;)</span><br><span class="line"> hook.callAsync(&apos;fdd&apos;,() =&gt; &#123;</span><br><span class="line">     console.log(&apos;end1&apos;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 promise</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; AsyncSeriesWaterfallHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">class Lesson&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.hooks=&#123;</span><br><span class="line">            arc: new AsyncSeriesWaterfallHook([&apos;name&apos;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tap()&#123;</span><br><span class="line">        this.hooks.arc.tapPromise(&apos;react&apos;,(name) =&gt;&#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    console.log(&apos;react&apos;, name);</span><br><span class="line">                    resolve(111)</span><br><span class="line">                &#125;,1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.hooks.arc.tapPromise(&apos;node&apos;,(data) =&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    console.log(&apos;node&apos;, data);</span><br><span class="line">                    resolve()</span><br><span class="line">                &#125;,1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        this.hooks.arc.promise(&apos;fdd&apos;).then(()=&gt;&#123;</span><br><span class="line">            console.log(&apos;end&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let l = new Lesson()</span><br><span class="line">l.tap()</span><br><span class="line">l.start()</span><br></pre></td></tr></table></figure>
<ul>
<li>实现原理 promise</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AsyncSeriesWaterfallHook&#123;</span><br><span class="line">    constructor(args)&#123;</span><br><span class="line">       this.tasks=[]</span><br><span class="line">    &#125;</span><br><span class="line">    tapPromise(name, task)&#123;</span><br><span class="line">        this.tasks.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    promise(...args)&#123;</span><br><span class="line">        let [ first, ...others] = this.tasks;</span><br><span class="line">        return others.reduce((p,n) =&gt; &#123;</span><br><span class="line">           return p.then((data)=&gt;n(data))</span><br><span class="line">        &#125;,first(...args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hook= new AsyncSeriesWaterfallHook([&apos;name&apos;])</span><br><span class="line">hook.tapPromise(&apos;react&apos;,(name) =&gt;&#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&apos;react&apos;, name);</span><br><span class="line">            resolve(111)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">hook.tapPromise(&apos;node&apos;,(data) =&gt;&#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&apos;node&apos;, data);</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">hook.promise(&apos;fdd&apos;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;end1&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置</title>
    <url>/2019/03/17/webpack%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>webpack 学习笔记</p>
<a id="more"></a>
<h1 id="搭建服务器-webpack-dev-server"><a href="#搭建服务器-webpack-dev-server" class="headerlink" title="搭建服务器 webpack-dev-server"></a>搭建服务器 webpack-dev-server</h1><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    port: 3000, //端口号默认8080</span><br><span class="line">    open: true, //自动打开</span><br><span class="line">    contentBase: path.resolve(__dirname,&apos;dist&apos;) // 指定了服务器资源的根目录，如果不写入contentBase的值，那么contentBase默认是项目的目录</span><br><span class="line">    host:&apos;127.0.0.1&apos;,//主机域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="转化-es6-语法"><a href="#转化-es6-语法" class="headerlink" title="转化 es6 语法"></a>转化 es6 语法</h1><ul>
<li><p>安装 babel-loader loader 核心模块，将 es6 转化成 es5 的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-proposal-class-properties @babel/plugin-transform-runtime    -D</span><br><span class="line">yarn add @babel/runtime</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test:/\.js$/,</span><br><span class="line">        use:&#123;</span><br><span class="line">            loader: babel-loader,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets: [</span><br><span class="line">                    &apos;@babe-preset-env&apos;,//es6-》es5</span><br><span class="line">                ],</span><br><span class="line">                plugins:[</span><br><span class="line">                     &quot;@babel/plugin-proposal-decorators&quot;,//装饰器 必须放在class之前</span><br><span class="line">                    &apos;@babel/plugin-proposal-class-properties&apos;,// es7-es5 class</span><br><span class="line">                    &apos;@babel/plugin-transform-runtime&apos; generator 运行时的</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>class 和 decorator 插件 json 写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">   [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],</span><br><span class="line">   [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot; : true &#125;]</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<ul>
<li>配置好后需要排除 node_modules,否则 warning</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include:path.resolve(__dirname,&apos;src&apos;),</span><br><span class="line">exclude: /node_modules/</span><br></pre></td></tr></table></figure>
<h1 id="使用-eslint-进行代码校验"><a href="#使用-eslint-进行代码校验" class="headerlink" title="使用 eslint 进行代码校验"></a>使用 eslint 进行代码校验</h1><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install eslint-loader eslint --save-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exculde:/node_modules/,</span><br><span class="line">    loader: &quot;eslint-loader&quot;,</span><br><span class="line">    options:&#123;</span><br><span class="line">        enforce: &apos;pre&apos;//在最前面校验代码 normal 普通从下到上，从左到右执行 post后置 内联loader-&gt;expose-loader</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 eslint 官网，配置语法规则，下载配置文件<a href="https://cn.eslint.org/demo/#eyJ0ZXh0IjoidmFyIGZvbyA9IGJhcjsiLCJvcHRpb25zIjp7InBhcnNlck9wdGlvbnMiOnsiZWNtYVZlcnNpb24iOjUsInNvdXJjZVR5cGUiOiJzY3JpcHQiLCJlY21hRmVhdHVyZXMiOnt9fSwicnVsZXMiOnsiY29uc3RydWN0b3Itc3VwZXIiOjIsIm5vLWNhc2UtZGVjbGFyYXRpb25zIjoyLCJuby1jbGFzcy1hc3NpZ24iOjIsIm5vLWNvbXBhcmUtbmVnLXplcm8iOjIsIm5vLWNvbmQtYXNzaWduIjoyLCJuby1jb25zb2xlIjoyLCJuby1jb25zdC1hc3NpZ24iOjIsIm5vLWNvbnN0YW50LWNvbmRpdGlvbiI6Miwibm8tY29udHJvbC1yZWdleCI6Miwibm8tZGVidWdnZXIiOjIsIm5vLWRlbGV0ZS12YXIiOjIsIm5vLWR1cGUtYXJncyI6Miwibm8tZHVwZS1jbGFzcy1tZW1iZXJzIjoyLCJuby1kdXBlLWtleXMiOjIsIm5vLWR1cGxpY2F0ZS1jYXNlIjoyLCJuby1lbXB0eS1jaGFyYWN0ZXItY2xhc3MiOjIsIm5vLWVtcHR5LXBhdHRlcm4iOjIsIm5vLWVtcHR5IjoyLCJuby1leC1hc3NpZ24iOjIsIm5vLWV4dHJhLWJvb2xlYW4tY2FzdCI6Miwibm8tZXh0cmEtc2VtaSI6Miwibm8tZmFsbHRocm91Z2giOjIsIm5vLWZ1bmMtYXNzaWduIjoyLCJuby1nbG9iYWwtYXNzaWduIjoyLCJuby1pbm5lci1kZWNsYXJhdGlvbnMiOjIsIm5vLWludmFsaWQtcmVnZXhwIjoyLCJuby1pcnJlZ3VsYXItd2hpdGVzcGFjZSI6Miwibm8tbWl4ZWQtc3BhY2VzLWFuZC10YWJzIjoyLCJuby1uZXctc3ltYm9sIjoyLCJuby1vYmotY2FsbHMiOjIsIm5vLW9jdGFsIjoyLCJuby1yZWRlY2xhcmUiOjIsIm5vLXJlZ2V4LXNwYWNlcyI6Miwibm8tc2VsZi1hc3NpZ24iOjIsIm5vLXNwYXJzZS1hcnJheXMiOjIsIm5vLXRoaXMtYmVmb3JlLXN1cGVyIjoyLCJuby11bmRlZiI6Miwibm8tdW5leHBlY3RlZC1tdWx0aWxpbmUiOjIsIm5vLXVucmVhY2hhYmxlIjoyLCJuby11bnNhZmUtZmluYWxseSI6Miwibm8tdW5zYWZlLW5lZ2F0aW9uIjoyLCJuby11bnVzZWQtbGFiZWxzIjoyLCJuby11bnVzZWQtdmFycyI6Miwibm8tdXNlbGVzcy1lc2NhcGUiOjIsInJlcXVpcmUteWllbGQiOjIsInVzZS1pc25hbiI6MiwidmFsaWQtdHlwZW9mIjoyfSwiZW52Ijp7ImVzNiI6dHJ1ZSwiY29tbW9uanMiOnRydWUsIm5vZGUiOnRydWUsImpxdWVyeSI6dHJ1ZX19fQ==" target="_blank" rel="noopener">eslintrc.json</a>，修改配置文件名为.eslintrc.json<br>Rules Configuration</li>
</ul>
<h1 id="引入第三方模块"><a href="#引入第三方模块" class="headerlink" title="引入第三方模块"></a>引入第三方模块</h1><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add jquery</span><br><span class="line">yarn add expose-loader -D</span><br></pre></td></tr></table></figure>
<ul>
<li>配置<ul>
<li>直接使用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &apos;jquery&apos;</span><br><span class="line">console.log($)</span><br></pre></td></tr></table></figure>
<ul>
<li>暴露到全局<br>1、模块中配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import $ from &apos;expose-loader?$!jquery&apos;</span><br><span class="line">console.log(window.$)</span><br></pre></td></tr></table></figure>
<p>2、webpack 中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test:require.resolve(&apos;jquery),</span><br><span class="line">        use:&apos;expose-loader?$&apos;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>在每个模块中注入依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">    $:&apos;jquery&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">直接使用$</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 cdn 引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">//使用</span><br><span class="line">console.log(window.$)</span><br></pre></td></tr></table></figure>
<p>同时使用 cdn 和 npm，但是不打包到项目中，这个研究了一下午，这么绕，纯粹扯淡</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &apos;jquery&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    jquery:&apos;$&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>1、js 中创建图片，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logo from &apos;./logo.png&apos;;</span><br><span class="line">let image=new Image();</span><br><span class="line">image.src= logo;</span><br><span class="line">document.body.appendChild(image);</span><br></pre></td></tr></table></figure>
<ul>
<li>loader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add file-loader  url-loader -D</span><br></pre></td></tr></table></figure>
<p>默认会在内部生成一张图片，放到 build 目录下，并返回图片名字</p>
<p>2、css 中背景图片<br>background: url(‘./logo.png’)</p>
<p>3、html 中使用<br>loader:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add html-withimg-loader -D</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    loader:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 url-loader，小于 limit 的时候将图片打包为 base64，减少 url 请求<br>url-loader 内置了 file-loader，不依赖 file-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(png|jpg|gif)/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            limit:1024*200</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打包文件分类"><a href="#打包文件分类" class="headerlink" title="打包文件分类"></a>打包文件分类</h1><ul>
<li>设置打包后文件路径<ul>
<li>打包图片</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(png|jpg|gif)/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            limit: 1024*200,</span><br><span class="line">            outputPath: &apos;img/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>打包 css</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename:&apos;css/main.css&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>同时 MiniCssExtractPlugin.loade 也需要配置 publicPath，否则 css 中的背景图片无法显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    loader:MiniCssExtractPlugin.loader,</span><br><span class="line">    options: &#123;</span><br><span class="line">        publicPath: &apos;../&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>配置打包后资源的公共路径<ul>
<li>所有资源配置相同的地址</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname,&apos;build&apos;),</span><br><span class="line">    publicPath: &apos;http:www.baidu.com&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只处理图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(png|jpg|gif)/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options:&#123;</span><br><span class="line">            limit: 1024*200,</span><br><span class="line">            outputPath: &apos;img/&apos;,</span><br><span class="line">            publicPath: &apos;http:www.baidu.com&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打包为多页面应用"><a href="#打包为多页面应用" class="headerlink" title="打包为多页面应用"></a>打包为多页面应用</h1><p>webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        home: &apos;./src/index.js&apos;,</span><br><span class="line">        other: &apos;./src/other.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename:&apos;[name].js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成多个 html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">plugins:[</span><br><span class="line">    new htmlWebpackPlugin(&#123;</span><br><span class="line">        template:&apos;./public/index.html&apos;,</span><br><span class="line">        filename:&apos;home.html&apos;,</span><br><span class="line">        chunks:[&apos;home&apos;],//如果一个页面包含多个js,chunks:[&apos;home&apos;,&apos;other&apos;]  title:&apos;home&apos;,//配置html的title,&lt;title&gt;&lt;% html%&gt;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &#125;),</span><br><span class="line">    new htmlWebpackPlugin(&#123;</span><br><span class="line">        template:&apos;./public/index.html&apos;,</span><br><span class="line">        filename:&apos;other.html&apos;,</span><br><span class="line">        chunks:[&apos;other&apos;],//如果一个页面包含多个js,chunks:[&apos;home&apos;,&apos;other&apos;]</span><br><span class="line">          title:&apos;other&apos;,</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="配置-source-map"><a href="#配置-source-map" class="headerlink" title="配置 source-map"></a>配置 source-map</h1><p>报错时映射到源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1、源码映射，单独生成映射文件，出错标当前出错的位置 生成文件大，全</span><br><span class="line">devtool:&apos;source-map&apos;</span><br><span class="line">//2、不会产生单独的文件，但是可以显示行和列</span><br><span class="line">devtool:&apos;eval-source-map&apos;</span><br><span class="line">//3、 不会产生列，但是生成单独的映射</span><br><span class="line">devtool:&apos;cheap-module-source-map&apos;</span><br><span class="line">//4、不会产生文件，集成在打包后的文件，不会产生列</span><br><span class="line">devtool: &apos;cheap-module-eval-source-map&apos;</span><br></pre></td></tr></table></figure>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>监控文件的变化，即使打包<br>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:true</span><br><span class="line">watchOptions:&#123;</span><br><span class="line">    pool: 1000, //每秒询问的次数</span><br><span class="line">    aggregateTimeout: 500, //防抖，输入结束5秒后打包</span><br><span class="line">    ignored: /node_modules/,  // 不要监控的文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打包前清空-dist"><a href="#打包前清空-dist" class="headerlink" title="打包前清空 dist"></a>打包前清空 dist</h1><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">new cleanWebpackPlugin()</span><br></pre></td></tr></table></figure>
<h1 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h1><p>在根目录新建 doc 文件夹存放需要拷贝的文件<br>打包时将 webpack 拷贝到 dist 文件中</p>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add copy-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const copyWebpackPlugin = require(&apos;ccopy-webpack-plugin&apos;)</span><br><span class="line">new copyWebpackPlugin([</span><br><span class="line">  &#123;from: &apos;doc&apos;,to:&apos;./&apos;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h1 id="打包代码前面都添加统一的签名"><a href="#打包代码前面都添加统一的签名" class="headerlink" title="打包代码前面都添加统一的签名"></a>打包代码前面都添加统一的签名</h1><p>webpack 自带插件 BannerPlugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.BannerPlugin(&apos;明天和意外&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="webpack-跨域问题"><a href="#webpack-跨域问题" class="headerlink" title="webpack 跨域问题"></a>webpack 跨域问题</h1><p>1）请求后端</p>
<ul>
<li>配置 server.js node server</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express= require(express);</span><br><span class="line">let app= express();</span><br><span class="line">app.get(&apos;/api/user&apos;,(req, res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;name:&apos;略略略&apos;&#125;)</span><br><span class="line">&#125; )</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>
<ul>
<li>发请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">//服务在3000端口，本地是8080</span><br><span class="line">xhr.open(&quot;GET&quot;, &apos;/api/user&quot;, true );</span><br><span class="line">xhr.onload =  function()&#123;</span><br><span class="line">   console.log(xhr.response)</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<ul>
<li>配置代理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">     &quot;/api&quot;: &quot;http://localhost:3000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有以/api 开头的都去访问 3000 端口</p>
<p>如果后端没有约定是以 api 开头的,请求之后重写 api 为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">   proxy: &#123;</span><br><span class="line">       &apos;/api&apos;:&#123;</span><br><span class="line">           target:&apos;http://localhost:3000&apos;,</span><br><span class="line">           pathRewrite:&#123;&apos;/api&apos; :&apos;&apos;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)前端模拟数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    before(app)&#123;</span><br><span class="line">        app.get(&apos;/user&apos;,(req,res)=&gt;&#123;</span><br><span class="line">            res.json(&#123;name:&apos;ddd&apos;&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3)在服务端使用 webpack</p>
<ul>
<li>中间件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-middleware</span><br></pre></td></tr></table></figure>
<p>-<br>server.js 配置，接口会同时配置在 server 的 3000 和 webpack 的 8080</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line">const  webpack= require(&apos;webpack&apos;);</span><br><span class="line">const middle = require(&apos;webpack-dev-middleware&apos;);</span><br><span class="line">const config = require(&apos;./webpack.config.js&apos;);</span><br><span class="line">let compiler = webpack(config);</span><br><span class="line">app.use(middle(compiler));</span><br><span class="line"></span><br><span class="line">app.use(&apos;/user&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;name:&apos;ddd111&apos;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>
<h1 id="resolve-解析第三方包"><a href="#resolve-解析第三方包" class="headerlink" title="resolve 解析第三方包"></a>resolve 解析第三方包</h1><ul>
<li>只在当前文件夹内解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">     modules:[path.resolve(&apos;node-modules&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 bootstrap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add bootstrap</span><br></pre></td></tr></table></figure>
<p>使用 import bootstrap from ‘bootstrap’引入的是 bootstrap.js<br>使用别名直接引入 bootstrap.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">     modules:[path.resolve(&apos;node-modules&apos;)],</span><br><span class="line">     alias:&#123; &apos;bootstrap&apos;: &apos;bootstrap/dist/css/bootstrap.css&apos;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定解析的文件入口顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mainFields:[&apos;styles&apos;,&apos;main&apos;];</span><br><span class="line">// mainFiles指定入口文件的名字，默认index.js</span><br></pre></td></tr></table></figure>
<p>省略文件后缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extensions:[&apos;.css&apos;,&apos;.js&apos;,&apos;.json&apos;]</span><br></pre></td></tr></table></figure>
<h1 id="定义环境变量"><a href="#定义环境变量" class="headerlink" title="定义环境变量"></a>定义环境变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DefinePlugin(&#123;</span><br><span class="line">    DEV: JSON.stringify(&apos;dev&apos;), // 字符串外面再套字符串</span><br><span class="line">    Flag: &apos;true&apos;,</span><br><span class="line">  //  EXPRESSION: JSON.stringify(&apos;1+1&apos;) //&apos;1+1&apos;,</span><br><span class="line">  EXPRESSION: &apos;1+1&apos; //2,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="区分不同环境"><a href="#区分不同环境" class="headerlink" title="区分不同环境"></a>区分不同环境</h1><p>webpack.base.js<br>webpack.dev.js<br>webpack.prod.js</p>
<ul>
<li>合并 webpack 配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-merge -D</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">let &#123; smart &#125; = require(&apos;webpack-merge&apos;);</span><br><span class="line">let base = require(&apos;./webpack.base.js&apos;);</span><br><span class="line">module.exports = smart(base, &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    devServer:&#123;&#125;,</span><br><span class="line">    devtool:&apos;source-map&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//```webpack.prod.js</span><br><span class="line">let &#123; smart &#125; = require(&apos;webpack-merge&apos;);</span><br><span class="line">let base = require(&apos;./webpack.base.js&apos;);</span><br><span class="line">module.exports = smart(base, &#123;</span><br><span class="line">    mode:&apos;production&apos;,</span><br><span class="line">    minimizer:[],</span><br><span class="line">    plugins[]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">noParse:/jquery/, //不去解析jquery中的依赖库</span><br></pre></td></tr></table></figure>
<h1 id="ignorePlugin"><a href="#ignorePlugin" class="headerlink" title="ignorePlugin"></a>ignorePlugin</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">         test: /\.js$/,</span><br><span class="line">         exclude:/node_modules/,   //排除node_modules下的js文件</span><br><span class="line">         include:path.resolve(&apos;src&apos;), //包含src下的文件</span><br><span class="line">         use:&#123;</span><br><span class="line">            loader: &apos;babel-loader&apos;,</span><br><span class="line">            presets:[&apos;@babel/preset-env&apos;, &apos;@babel/preset-resct&apos;]</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略引入文件的内部文件</p>
<ul>
<li>安装 moment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add moment -D</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let r = moment().endOf(&apos;day&apos;).fromNow();</span><br><span class="line">console.log(r)</span><br></pre></td></tr></table></figure>
<ul>
<li>显示中文时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">moment.locale(&apos;zh-cn&apos;)</span><br></pre></td></tr></table></figure>
<p>打包时忽略 moment 的语言包引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.IgnorePlugin(/\.\/locale/,/moment/)</span><br></pre></td></tr></table></figure>
<ul>
<li>手动引入中文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;moment/locale/zh-cn&apos;</span><br></pre></td></tr></table></figure>
<h1 id="动态链接库-dllPlugin"><a href="#动态链接库-dllPlugin" class="headerlink" title="动态链接库 dllPlugin"></a>动态链接库 dllPlugin</h1><p>打包不需要每次更改都需要重新打包的文件</p>
<ul>
<li>安装 react react-dom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<ul>
<li>react 代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; render &#125; from &apos;react-dom&apos;;</span><br><span class="line">render(&lt;h1&gt;JSX&lt;/h1&gt;, window.root);</span><br></pre></td></tr></table></figure>
<ul>
<li>抽离 react，react-dom 单独打包<br>webpack.react.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let path = require(&apos;path&apos;);</span><br><span class="line">let webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports= &#123;</span><br><span class="line">    model:&apos;development&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react:[&apos;react&apos;,react-dom&apos;],</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;_dll_[name].js&apos;,//产生的文件名</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        library:&apos;_dll_[name]&apos;, //打包产生的文件赋值变量名</span><br><span class="line">        //libraryTarget:&apos;commonjs’ //export 默认是var，可以是 umd统一资源 this</span><br><span class="line">    &#125;,</span><br><span class="line">    plugin:[</span><br><span class="line">        new webpack.DllPlugin(&#123; //打包文件的清单</span><br><span class="line">            name: &apos;_dll_[name]&apos;, //name就是输出的filename名字</span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>html 中引入打包后文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&apos;/_dll_react.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>webpack.config.js<br>引用 dll 插件，引用模块的时候会先查找 dll 里面的清单找不到的时候再打包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: path.resolve(__dirname, &apos;dist&apos;, &apos;manifest.json&apos;)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack --config webpack.react.js</span><br></pre></td></tr></table></figure>
<h1 id="多线程打包-happypack"><a href="#多线程打包-happypack" class="headerlink" title="多线程打包 happypack"></a>多线程打包 happypack</h1><ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add happypack -D</span><br></pre></td></tr></table></figure>
<ul>
<li>引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import happypack from &apos;happypack&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            user: &apos;happypack/loader?id=js&apos;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            user: &apos;happypack/loader?id=css&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">plugins: [</span><br><span class="line">    new happypack(&#123;</span><br><span class="line">        id:js,</span><br><span class="line">        use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &apos;babel-loader&apos;,</span><br><span class="line">              presets:[&apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;),</span><br><span class="line">    new happypack(&#123;</span><br><span class="line">        id:css,</span><br><span class="line">        use: [&apos;style-loader&apos;,&apos;css-loader&apos;],</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="多页面打包抽取公共代码"><a href="#多页面打包抽取公共代码" class="headerlink" title="多页面打包抽取公共代码"></a>多页面打包抽取公共代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">   splitChunks:&#123;//分割代码块</span><br><span class="line">        cacheGroups:&#123;//缓存组</span><br><span class="line">            common:&#123;//公共的模块</span><br><span class="line">                chunks:&apos;initial&apos;,//</span><br><span class="line">                minSize:0, //形成一个新代码块最小的体积默认30000</span><br><span class="line">                minChunks:2,//公共模块使用2次以上，默认一次</span><br><span class="line">            &#125;,</span><br><span class="line">            vendor:&#123;//第三方模块</span><br><span class="line">                priority:1,//抽离权重，先后顺序</span><br><span class="line">                test:/node_modules/,</span><br><span class="line">                chunks:&apos;initial&apos;,</span><br><span class="line">                minSize:0,</span><br><span class="line">                minChunks:2</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>安装 js 插件@babel/plugin-syntax-dynamic-import</p>
<ul>
<li>配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.js$/,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;babel-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[</span><br><span class="line">                    &apos;@babel/preset-env&apos;,</span><br><span class="line">                    &apos;@babel/preset-react&apos;</span><br><span class="line">                ],</span><br><span class="line">                plugin:[</span><br><span class="line">                    &apos;@babel/plugin-syntax-dynamic-import&apos;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 获取资源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import(&apos;./source&apos;).then(data=&gt;&#123;</span><br><span class="line"> console.log(&apos;data&apos;,data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h1><ul>
<li>启用热更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    hot:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    new  webpack.NamedModulesPlugin(),//打印更新的模块名d</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()//热更新插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>模块里面的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(module.hot)&#123;</span><br><span class="line">    console.log(111)</span><br><span class="line">    module.hot.accept(&apos;./source&apos;,()=&gt;&#123;</span><br><span class="line">        console.log(&apos;文件更新了&apos;)</span><br><span class="line">        let str=require(&apos;./source&apos;)</span><br><span class="line">        console.log(str)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>’webpack&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native之Android展示GIF</title>
    <url>/2019/03/09/react-native%E4%B9%8BAndroid%E5%B1%95%E7%A4%BAGIF/</url>
    <content><![CDATA[<p>Android无法解析GIF图，只能展示为图片<br><a id="more"></a></p>
<ul>
<li>配置<br>android/app/build.gradle</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"> // 如果你需要支持GIF动图</span><br><span class="line">  compile &apos;com.facebook.fresco:animated-gif:1.5.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>重新启动Android  react-native run-android<br>app直接崩了<br>在网上查了一下解决方法</p>
</li>
<li><p>使用android studio打开Android项目<br>在根目录执行./gradlew -q app:dependencies查看当前项目的依赖情况，从而解决依赖冲突问题。<br><img src="/2019/03/09/react-native之Android展示GIF/de.png" alt="依赖"><br>根据提示将版本从1.5.0-&gt;1.10.0</p>
</li>
</ul>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>使用XLSL读取excel表格</title>
    <url>/2019/03/07/%E4%BD%BF%E7%94%A8XLSL%E8%AF%BB%E5%8F%96excel%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p>使用插件 XLSX 前端读取 excel,转为 table 数据<br><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">https://github.com/SheetJS/js-xlsx</a></p>
<a id="more"></a>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save xlsx</span><br></pre></td></tr></table></figure>
<ul>
<li>引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  XLSX from &apos;xlsx&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>上传组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div className=&apos;input&apos;&gt;</span><br><span class="line">    &lt;div className=&apos;input-file-box&apos;&gt;</span><br><span class="line">    &lt;Icon type=&quot;upload&quot; /&gt;&lt;span style=&#123;&#123;paddingLeft:5&#125;&#125;&gt;上传学生表格&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; className=&quot;form-control&quot;  accept=&#123;SheetJSFT&#125;</span><br><span class="line">    onChange=&#123;this.uploadExcel&#125;  /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>修改 H5 上传组件的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.input&#123;</span><br><span class="line">   margin-top:10px;</span><br><span class="line">   margin-bottom:30px;</span><br><span class="line">    position: relative;</span><br><span class="line">    width:130px;</span><br><span class="line">    height:30px;</span><br><span class="line">&#125;</span><br><span class="line">.form-control&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    opacity:0;</span><br><span class="line">     top:0;</span><br><span class="line">     right:0;</span><br><span class="line">     bottom:0;</span><br><span class="line">     left:0;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    width:100%;</span><br><span class="line">&#125;</span><br><span class="line">.input-file-box&#123;</span><br><span class="line">    border: 1px solid #D9D9D9;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    position: relative;</span><br><span class="line">    text-align: center;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果类似如下<br><img src="/2019/03/07/使用XLSL读取excel表格/img1.jpg" alt="上传组件样式"></p>
<ul>
<li>功能实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> uploadExcel = (e) =&gt; &#123;</span><br><span class="line">       this.setState(&#123;loading:true&#125;)</span><br><span class="line">       const files = e.target.files;</span><br><span class="line"> if(files &amp;&amp; files[0]) this.handleFile(files[0]);</span><br><span class="line">   &#125;</span><br><span class="line">   handleFile = (file/*:File*/) =&gt; &#123;</span><br><span class="line"> const reader = new FileReader();</span><br><span class="line"> reader.onload = (e) =&gt; &#123;</span><br><span class="line">  const bstr = e.target.result;</span><br><span class="line">  const wb = XLSX.read(bstr, &#123;type:&apos;binary&apos;&#125;);//type读取方式为对象key-value，如果type为array,读出来的是数组形式</span><br><span class="line">  const wsname = wb.SheetNames[0];//读取第一个sheet</span><br><span class="line">  const ws = wb.Sheets[wsname];</span><br><span class="line">           const data = XLSX.utils.sheet_to_json(ws);</span><br><span class="line">           console.log(&apos;data&apos;,data)</span><br><span class="line">           this.formData(data);</span><br><span class="line">  this.setState(&#123; studentForm: data, &#125;);</span><br><span class="line"> &#125;;</span><br><span class="line"> reader.readAsBinaryString(file);// 以二进制方式打开文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理数据，将 key 由文字转为字符串，Table 需要的形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//表格数据格式化</span><br><span class="line">  formData = (data) =&gt; &#123;</span><br><span class="line">      let id= this.props.location.pathname.split(&apos;:&apos;)[1];</span><br><span class="line">      data.map(line=&gt;&#123;</span><br><span class="line">           return  Object.keys(line).forEach(function(key)&#123;</span><br><span class="line">              // console.log(key,line[key]);</span><br><span class="line">              switch(key)&#123;</span><br><span class="line">                  case &apos;学号&apos;:</span><br><span class="line">                  line.student_num = line[key];</span><br><span class="line">                  break;</span><br><span class="line">                  case &apos;学生姓名&apos;:</span><br><span class="line">                  line.name = line[key];</span><br><span class="line">                  break;</span><br><span class="line">                  case &apos;班级&apos;:</span><br><span class="line">                  line.class_name = line[key];</span><br><span class="line">                  break;</span><br><span class="line">                  case &apos;院系&apos;:</span><br><span class="line">                  line.college_name = line[key];</span><br><span class="line">                  break;</span><br><span class="line">                  case &apos;修读类别&apos;:</span><br><span class="line">                  line.study_type = line[key];</span><br><span class="line">                  break;</span><br><span class="line">                  default:</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              delete line[key];</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
  </entry>
  <entry>
    <title>重学前端-HTMl语义标签</title>
    <url>/2019/02/26/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTMl%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>重学前端——语义化标签</p>
<a id="more"></a>
<ul>
<li><p>缩写<br>abbr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分隔线<br>hr - 表示故事走向的转变或话题的转变<br>border - 纯粹的视觉效果</p>
</li>
<li><p>注释<br>p 标签+class=’note’</p>
</li>
<li><p>加粗</p>
<ul>
<li>strong 表示文本十分重要</li>
<li>em 表示强调，可以嵌套，越多层级 表示更大程度的强调</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li>blockquote 表示段落级引述内容，</li>
<li>q 表示行内的引述内容</li>
<li>cite 表示引述的作品名</li>
</ul>
</li>
<li><p>时间<br>time</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;time datetime=&apos;2019-01-25&apos;&gt;25 Jan 2019&lt;/time&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文章中的图像<br>figure 用于表示与主文章相关的图像、照片等流内容<br>figcaption 照片图片的描述文字</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">  &lt;img src=&apos;http://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E6%96%B0%E9%B2%9C%E4%BA%8B&amp;tn=SE_PclogoS_8whnvm25&amp;sa=ire_dl_gh_logo&amp;rsv_dl=igh_logo_pcs&apos;&gt;</span><br><span class="line">  &lt;figcaption&gt;百度logo&lt;/figcaption&gt;</span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义 ghh<br>dfn 标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The &lt;dfn&gt;Internet&lt;/dfn&gt; is balalalal</span><br></pre></td></tr></table></figure>
<ul>
<li><p>固定格式</p>
<ul>
<li>samp 计算机输出</li>
<li>pre 格式不根据浏览变化</li>
<li>code 代码段</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">    &lt;code&gt;&gt;</span><br><span class="line">        &amp;lt;html&amp;gt;</span><br><span class="line">              &amp;lt;head&amp;gt;</span><br><span class="line">              &amp;lt;/head&amp;gt;</span><br><span class="line">              &amp;lt;body&amp;gt;</span><br><span class="line">              &amp;lt;/body&amp;gt;</span><br><span class="line">        &amp;lt;/html&amp;gt;</span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JS-语言类型</title>
    <url>/2019/02/26/JS-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>七种语言类型：Undefined，Null，Number, Boolean, String, Symbol, Object<br>类型转换<br>类型判断</p>
<a id="more"></a>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本类型：直接存储在栈（stack）中的数据，值类型</li>
<li>引用数据类型：存储的是该对象在栈中的引用，真实的数据存放在堆中，引用类型</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li><p>Undefined、Null<br>Undefined 类型表示未定义，只有一个值 undefined<br>全局变量 undefined，类型是 Undefined，所以 undefined 是一个变量而非关键字（局部环境可以被赋值），可以使用 void(0)来获取 undefined 的值。<br>Null 表示定义了但为空，值 null，是 js 的关键字</p>
</li>
<li><p>Boolean<br>真/假 true/false</p>
</li>
<li><p>String<br>最大长度 UTF16 编码 2^53-1，</p>
</li>
<li><p>Number<br>特例</p>
<ul>
<li>NaN</li>
<li>Infinity, 无穷大,除以+0</li>
<li>-Infinity，负无穷大,除以-0<br>检测+0 和-0 的方法，检测 1/x 是 Infinity 还是 -Infinity<br>差值比较<br>Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON<br>左右两边的差，绝对值小于最小精度，就认为两者相等</li>
</ul>
</li>
</ul>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li><p>Symbol<br>创建使用全局 Symbol 函数<br>var mySymbol = Symbol(‘my symbol’)<br>括号里面是 Symbol 的描述，即使描述相同，两个 Symbol 值也不会相等</p>
<p>为对象定义了 Symbol.iterator 属性，就可以使用 for of 遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o=new Object</span><br><span class="line">o[Symbol.iterator] = function () &#123;</span><br><span class="line">    var v = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function()&#123;</span><br><span class="line">            return &#123; value:v++, done: v&gt;10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for( var v of o)&#123;</span><br><span class="line">    console.log(v) // 0 2 3 4 5 6 7 8 9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object<br>构造器：Number,String,Boolean,Symbol<br>使用 new+构造器，生成一个对象，<br>直接调用表示强制类型转换，<br>其中 Symbol 不能直接与 new 搭配。</p>
</li>
</ul>
<p>在构造器原型上添加方法，基本类型都可以调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol.prototype.hello = () =&gt; console.log(&apos;hello&apos;);</span><br><span class="line">var a = Symbol(&apos;a&apos;);</span><br><span class="line">console.log(typeof a) //symbol</span><br><span class="line">a.hello() //hello</span><br></pre></td></tr></table></figure>
<p>为什么给对象添加的方法能用在基本类型上？<br>因为点(.)运算符提供装箱操作，会根据基础类型构造一个临时对象，使我们可以在基础类型上调用对应对象的方法。</p>
<h2 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h2><ul>
<li>值传递，会将一个值类型的数值副本传到函数内部，函数内部不影响函数外部传递的参数变量</li>
<li><p>引用类型，会将引用类型的地址值复制给传入函数的参数，函数内部修改会影响外部的引用对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">        console.log(1, a, b) // 11 &#123;value: 222&#125;</span><br><span class="line">        a = 10;</span><br><span class="line">        b.value = 100</span><br><span class="line">        console.log(2, a, b) // 10 &#123;value: 100&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let a = 11,</span><br><span class="line">        b = &#123;</span><br><span class="line">            value: 222</span><br><span class="line">        &#125;;</span><br><span class="line">    f(a, b)</span><br><span class="line">    console.log(3, a, b) // 11 &#123;value: 100&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><ol>
<li><p><code>typeof</code><br>返回一个表示数据类型的字符串<br><code>number</code>、<code>boolean</code>、<code>string</code>、<code>symbol</code>、<code>object</code>、<code>undefined</code>、<code>function</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(typeof 1) //number</span><br><span class="line">console.log(typeof true) //boolean</span><br><span class="line">console.log(typeof &apos;&apos;) //string</span><br><span class="line">console.log(typeof Symbol()) //symbol</span><br><span class="line">console.log(typeof undefined) //undefined</span><br><span class="line">console.log(typeof new Function()) //function</span><br><span class="line">console.log(typeof &#123;&#125;) //object 无效</span><br><span class="line">console.log(typeof []) //object 无效</span><br><span class="line">console.log(typeof null) //object 无效</span><br><span class="line">console.log(typeof new Date()) //object 无效</span><br><span class="line">console.log(typeof new RegExp()) //object 无效</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code><br><strong>A instanceof B</strong>：判断 A 是否是 B 的实例。返回值是 true/false。<br>用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，但是不能检测 null 和 undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([] instanceof Array)   //true</span><br><span class="line">console.log(&#123;&#125; instanceof Object)   //true</span><br><span class="line">console.log(new Date() instanceof Date)   //true</span><br><span class="line">console.log(new RegExp() instanceof RegExp)   //true</span><br><span class="line">console.log(null instanceof Null)   //报错</span><br><span class="line">console.log(undefined instanceof undefined)   //报错</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>constructor</code><br>与 instanceof 相似，但是 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。但是在把类的原型进行重写的过程中，可能把之前的 constructor 覆盖，检测结果不准确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.constructor == Object//obj的构造函数是不是Object</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.prototype.toString.call()</code><br>是准确最常用的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(&apos; &apos;)) //[object String]</span><br><span class="line">console.log(Object.prototype.toString.call(1)) //[object Number]</span><br><span class="line">console.log(Object.prototype.toString.call(true)) //[object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined)) //[object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(null)) //[object Null]</span><br><span class="line">console.log(Object.prototype.toString.call(new Function())) //[object Function]</span><br><span class="line">console.log(Object.prototype.toString.call(new Date())) //[object Date]</span><br><span class="line">console.log(Object.prototype.toString.call(new RegExp())) //[object RegExp]</span><br><span class="line">console.log(Object.prototype.toString.call([])) //[object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(new Error())) //[object Error]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.isArray()</code><br>判断是不是数组</p>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li><p>转化为字符串类型<br>方法：</p>
<ol>
<li><code>.toString()</code>，不可以转换<code>null</code>和<code>undefined</code></li>
<li><code>String()</code></li>
<li><code>+&#39;&#39;</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null =&gt; &apos;null&apos; //通过2，3方法转换</span><br><span class="line">undefined =&gt; &apos;undefined&apos; //通过2，3方法转换</span><br><span class="line">true =&gt; &apos;true&apos;</span><br><span class="line">false =&gt; &apos;false&apos;</span><br><span class="line">[1,2,3] =&gt; 1,2,3</span><br></pre></td></tr></table></figure>
<p>对象转换成字符串会调用对象的<code>toString</code>方法，通常得到<code>&quot;[object Object]&quot;</code></p>
</li>
<li><p>转化为数字<br>方法：Number()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null =&gt; 0</span><br><span class="line">undefined =&gt; NaN</span><br><span class="line">//Boolean</span><br><span class="line">true =&gt; 1</span><br><span class="line">false =&gt; 0</span><br><span class="line">//function</span><br><span class="line">()=&gt;&#123;&#125; =&gt; NaN</span><br><span class="line">function a()&#123;&#125; =&gt; NaN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对对象来说，会先检查该值是否有 valueOf 方法，如果有 valueOf 且返回基本类型，则使用该返回值进行类型转换；否则调用 toString 方法进行类型转换（如果此处返回的不是数字，则会调用上面列举的 4 条规则进行类型转换）；如果以上规则均不返回数字，则报 TypeError 错误</p>
<ul>
<li><p>StringToNumber<br>parseInt(str,base)<br>转换为整数<br>从第一位开始转换，遇到非数字停止，如果第一个字符就是非数字直接返回 NaN。<br>base:转化的进制，默认 10 进制，如果 str 是以 0x 开头的字符，转换进制默认是 16 进制。</p>
<p>parseFloat(str)<br>按照 10 进制将原字符转换为浮点数<br>从第一位开始转换，遇到非数字停止，如果第一个字符就是非数字直接返回 NaN。</p>
</li>
<li><p>转换为布尔值<br><code>undefined</code>,<code>null</code>,<code>false</code>,<code>+0</code>,<code>-0</code>,<code>NaN</code>,<code>&#39;&#39;</code>会被转为<code>false</code>，其他的都会被转换为<code>true</code>。</p>
</li>
</ul>
<h2 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h2><p>把基本类型的转为对应的对象类型<br>Symbol 对象无法调用 new 方法来进行装箱转换，下面是可以让其实现装箱转换的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var symbolObject = (function()&#123;return this;&#125;).call(Symbol(&apos;a&apos;));</span><br><span class="line"></span><br><span class="line">typeof symbolObject //object</span><br><span class="line">symbolObject instanceof Symbol //true</span><br><span class="line">symbolObject.constructor == Symbol //true</span><br></pre></td></tr></table></figure>
<p>装箱机制会产生临时对象，性能要求高的场景应避免使用。<br>内置函数 Object 也可以实现以上功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&apos;a&apos;));</span><br><span class="line"></span><br><span class="line">typeof symbolObject //object</span><br><span class="line">symbolObject instanceof Symbol //true</span><br><span class="line">symbolObject.constructor == Symbol //true</span><br></pre></td></tr></table></figure>
<p>对象私有 Class 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&apos;a&apos;));</span><br><span class="line">Object.prototype.toString.call(symbolObject) //[object Symbol]</span><br></pre></td></tr></table></figure>
<p>这种识别具体对象类型的方法比 instanceof 更加准确</p>
<p>但是 call 会产生装箱操作，所有需要先使用 typeof 排除基本类型，再进行对象类型的判断</p>
<h2 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h2><p>对象类型到基本类型的转换，会调用内置的<code>[ToPrimitive]</code> 函数。<br>对象到 String 和 Number 的转换都遵循“先拆箱再转换”，先把对象变为基本类型，再从基本类型转为对象的 String 或者 Number<br>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，会产生 TypeError</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    valueOf : () =&gt; &#123;console.log(&apos;valueOf&apos;); return &#123;&#125;&#125;,</span><br><span class="line">    toString : () =&gt; &#123;console.log(&apos;toString&apos;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">o*2</span><br><span class="line">// valueOf</span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure>
<p>ES6 之后可以使用显示指定@@toPrimitive Symbol 覆盖原有行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    valueOf : () =&gt; &#123;console.log(&apos;valueOf&apos;); return &#123;&#125;&#125;,</span><br><span class="line">    toString : () =&gt; &#123;console.log(&apos;toString&apos;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">o[Symbol.toPrimitive] = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;toPrimitive&apos;);</span><br><span class="line">    return &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">o + &quot;&quot;</span><br><span class="line">//toPrimitive</span><br><span class="line">//hello</span><br></pre></td></tr></table></figure>
<h2 id="验证是否为有效数字"><a href="#验证是否为有效数字" class="headerlink" title="验证是否为有效数字"></a>验证是否为有效数字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isValidNumber=n=&gt;typeof n===&apos;number&apos;&amp;&amp;!isNaN(n)&amp;&amp;isFinite(n)</span><br></pre></td></tr></table></figure>
<h2 id="两个日期之前相隔天数"><a href="#两个日期之前相隔天数" class="headerlink" title="两个日期之前相隔天数"></a>两个日期之前相隔天数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getDayDiff = (date1, date2) =&gt; ((date2 - date1) / (1000 * 3600 * 24));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之Android启动页配置</title>
    <url>/2019/02/12/react-native%E4%B9%8BAndroid%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>为 react native 项目的 android 端口增加启动页面</p>
<p>IOS 端口可以直接配置启动页面，可参考<react-native 从入门到放弃=""></react-native></p>
<p>插件:<a href="https://github.com/crazycodeboy/react-native-splash-screen" target="_blank" rel="noopener">react-native-splash-screen</a></p>
<a id="more"></a>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i react-native-splash-screen --s</span><br><span class="line">react-native link react-native-splash-screen</span><br></pre></td></tr></table></figure>
<h1 id="在-android-文件中进行配置"><a href="#在-android-文件中进行配置" class="headerlink" title="在 android 文件中进行配置"></a>在 android 文件中进行配置</h1><ol>
<li>在 android/app/src/main/java/com/xxx/MainActivity.java 文件中添加所示的代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.gd;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle; //第一</span><br><span class="line">import com.facebook.react.ReactActivity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.devio.rn.splashscreen.SplashScreen; //第二</span><br><span class="line"></span><br><span class="line">import com.facebook.react.ReactActivityDelegate;</span><br><span class="line">import com.facebook.react.ReactRootView;</span><br><span class="line">import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends ReactActivity &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the name of the main component registered from JavaScript.</span><br><span class="line">     * This is used to schedule rendering of the component.</span><br><span class="line">     */</span><br><span class="line">     @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123; // 第三处</span><br><span class="line">        SplashScreen.show(this);</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getMainComponentName() &#123;</span><br><span class="line">        return &quot;GD&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>android/app/src/main/res 目录中,新建 layout 目录,在此目录下,创建 launch_screen.xml 文件,复制以下内容（ 其中 launchimage 为启动的图片名 )</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;@drawable/launchimage&quot;&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在 android/app/src/main/res 目录中,新建 drawable-xhdpi 和 drawable-xxhdpi 目录,在其中放入启动页图片,launchimage.png</li>
</ol>
<h1 id="在布局挂载完成后，关闭启动页面"><a href="#在布局挂载完成后，关闭启动页面" class="headerlink" title="在布局挂载完成后，关闭启动页面"></a>在布局挂载完成后，关闭启动页面</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import SplashScreen from &apos;react-native-splash-screen&apos;</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">        SplashScreen.hide()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>pdf.js使用</title>
    <url>/2019/01/24/pdf-js%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>需求：将从服务器请求回来的 pdf 文件展示为图片<br>填坑填坑，github 上的项目中的例子很重要，不要怕英文</p>
<a id="more"></a>
<p><a href="https://github.com/mozilla/pdf.js" target="_blank" rel="noopener">https://github.com/mozilla/pdf.js</a><br>如果是直接展示 pdf 文件，window.open(url)就好了<br>也可以使用 pdf.js 中的 viewer.js</p>
<p>这次的需求是将 pdf 渲染为类似 image<br>例子可以参考 github 下 examples/learning/helloworld.html<br>请求 pdf 文件，使用 canvas 渲染到网页</p>
<p> 在 react 项目中使用</p>
<p>在项目 public/index.html 引入 pdf.js\</p>
<ul>
<li>引入网络资源<br><script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.0.943/build/pdf.js"> </script><br>window 对象中增加 pdfjsLib 方法</li>
<li><p>下载到本地引入，放到 server/build 中</p>
<script src="http://localhost:3000/pdf.js"></script>

<p>_使用_<br>js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdfjsLib.getDocument(url).then(pdf=&gt;&#123;</span><br><span class="line">    pdf.getPage(1).then(page=&gt;&#123;</span><br><span class="line">        var scale = 1.5;</span><br><span class="line">        var viewport = page.getViewport(&#123; scale: scale, &#125;);</span><br><span class="line">        var canvas = document.getElementById(&apos;the-canvas&apos;);</span><br><span class="line">        var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        canvas.height = viewport.height;</span><br><span class="line">        canvas.width = viewport.width;</span><br><span class="line">    &#125;)</span><br><span class="line">    var renderContext = &#123;</span><br><span class="line">      canvasContext: context,</span><br><span class="line">      viewport: viewport,</span><br><span class="line">    &#125;;</span><br><span class="line">    page.render(renderContext);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;the-canvas&quot; style=&quot;border:1px  solid black&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>问题</strong><br>url 是 pdf 文件的路径，使用本地的 pdf 文件，采用 es6 的方法引入，可以正常调用<br>但是变成服务器的地址时，产生跨域问题。</p>
<p><strong>解决办法</strong><br>参考 github 下 examples/learning/helloworld64.html<br>需要后台改接口，将返回的文件路径变为二进制文件流，然后使用 window 自带的解码方法 atob 解码，将解码后的数据传给 pdf.js 的方法,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//模拟请求回来的数据,使用 axios/fetch 请求代替</span><br><span class="line">var pdfData = atob(</span><br><span class="line">&apos;JVBERi0xLjcKCjEgMCBvYmogICUgZW50cnkgcG9pbnQKPDwKICAvVHlwZSAvQ2F0YWxvZwog&apos; +</span><br><span class="line">&apos;IC9QYWdlcyAyIDAgUgo+PgplbmRvYmoKCjIgMCBvYmoKPDwKICAvVHlwZSAvUGFnZXMKICAv&apos; +</span><br><span class="line">&apos;TWVkaWFCb3ggWyAwIDAgMjAwIDIwMCBdCiAgL0NvdW50IDEKICAvS2lkcyBbIDMgMCBSIF0K&apos; +</span><br><span class="line">&apos;Pj4KZW5kb2JqCgozIDAgb2JqCjw8CiAgL1R5cGUgL1BhZ2UKICAvUGFyZW50IDIgMCBSCiAg&apos; +</span><br><span class="line">&apos;L1Jlc291cmNlcyA8PAogICAgL0ZvbnQgPDwKICAgICAgL0YxIDQgMCBSIAogICAgPj4KICA+&apos; +</span><br><span class="line">&apos;PgogIC9Db250ZW50cyA1IDAgUgo+PgplbmRvYmoKCjQgMCBvYmoKPDwKICAvVHlwZSAvRm9u&apos; +</span><br><span class="line">&apos;dAogIC9TdWJ0eXBlIC9UeXBlMQogIC9CYXNlRm9udCAvVGltZXMtUm9tYW4KPj4KZW5kb2Jq&apos; +</span><br><span class="line">&apos;Cgo1IDAgb2JqICAlIHBhZ2UgY29udGVudAo8PAogIC9MZW5ndGggNDQKPj4Kc3RyZWFtCkJU&apos; +</span><br><span class="line">&apos;CjcwIDUwIFRECi9GMSAxMiBUZgooSGVsbG8sIHdvcmxkISkgVGoKRVQKZW5kc3RyZWFtCmVu&apos; +</span><br><span class="line">&apos;ZG9iagoKeHJlZgowIDYKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMDEwIDAwMDAwIG4g&apos; +</span><br><span class="line">&apos;CjAwMDAwMDAwNzkgMDAwMDAgbiAKMDAwMDAwMDE3MyAwMDAwMCBuIAowMDAwMDAwMzAxIDAw&apos; +</span><br><span class="line">&apos;MDAwIG4gCjAwMDAwMDAzODAgMDAwMDAgbiAKdHJhaWxlcgo8PAogIC9TaXplIDYKICAvUm9v&apos; +</span><br><span class="line">&apos;dCAxIDAgUgo+PgpzdGFydHhyZWYKNDkyCiUlRU9G&apos;);</span><br><span class="line"></span><br><span class="line">pdfjsLib.GlobalWorkerOptions.workerSrc =</span><br><span class="line">&apos;https://cdn.jsdelivr.net/npm/pdfjs-dist@2.0.943/build/pdf.worker.js&apos;;</span><br><span class="line"></span><br><span class="line">var loadingTask = pdfjsLib.getDocument(&#123; data: pdfData, &#125;);</span><br><span class="line">loadingTask.promise.then(function(pdf) &#123;</span><br><span class="line">// Fetch the first page.</span><br><span class="line">pdf.getPage(1).then(function(page) &#123;</span><br><span class="line">var scale = 1.5;</span><br><span class="line">var viewport = page.getViewport(&#123; scale: scale, &#125;);</span><br><span class="line">// Prepare canvas using PDF page dimensions.</span><br><span class="line">var canvas = document.getElementById(&apos;the-canvas&apos;);</span><br><span class="line">var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">canvas.height = viewport.height;</span><br><span class="line">canvas.width = viewport.width;</span><br><span class="line">// Render PDF page into canvas context.</span><br><span class="line">var renderContext = &#123;</span><br><span class="line">canvasContext: context,</span><br><span class="line">viewport: viewport,</span><br><span class="line">&#125;;</span><br><span class="line">page.render(renderContext);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另外还做了一个拖动和放大  缩小的功能，具体参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import React ,&#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &#123; Modal, Button, &#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">constructor(props)&#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state=&#123;</span><br><span class="line">width:0,</span><br><span class="line">height:0,</span><br><span class="line">show:true,</span><br><span class="line">mouseDownFlag:false,</span><br><span class="line">mouseDownX:null,</span><br><span class="line">mouseDownY:null,</span><br><span class="line">initX:null,</span><br><span class="line">initY:null,</span><br><span class="line">scale:1,</span><br><span class="line">disable:false,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">drawImg=(img,scale=1)=&gt;&#123;</span><br><span class="line">var pdfData = atob(img)</span><br><span class="line">window.pdfjsLib.GlobalWorkerOptions.workerSrc =&apos;http://localhost:8000/pdf.worker.js&apos;</span><br><span class="line">window.pdfjsLib.getDocument(&#123;data:pdfData&#125;).then(pdf=&gt; &#123;</span><br><span class="line">pdf.getPage(1).then(page=&gt;&#123;</span><br><span class="line">var viewport = page.getViewport(scale);</span><br><span class="line">var canvas = document.getElementById(&apos;modal_img&apos;);</span><br><span class="line">var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"> context.clearRect(0,0,canvas.width,canvas.height);</span><br><span class="line"> canvas.height = viewport.height;</span><br><span class="line">canvas.width = viewport.width;</span><br><span class="line">var renderContext = &#123;</span><br><span class="line">canvasContext: context,</span><br><span class="line">viewport: viewport</span><br><span class="line">&#125;;</span><br><span class="line">page.render(renderContext);</span><br><span class="line">this.setState(&#123;width:canvas.width,height:canvas.height,&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">this.drawImg(this.props.img)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> handlerMouseUp=()=&gt;&#123;</span><br><span class="line">this.setState(&#123;mouseDownFlag:false&#125;,()=&gt;&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">handlerMouseDown=(e)=&gt;&#123;</span><br><span class="line">this.setState(&#123;mouseDownFlag:true, mouseDownX:e.pageX,mouseDownY:e.pageY &#125;)</span><br><span class="line">const img=document.getElementById(&apos;modal_img&apos;)</span><br><span class="line">const initX=img.offsetLeft;</span><br><span class="line">const initY=img.offsetTop;</span><br><span class="line">this.setState(&#123;initX,initY&#125;)</span><br><span class="line">&#125;</span><br><span class="line">handlerMouseMove=(e)=&gt;&#123;</span><br><span class="line">e.preventDefault &amp;&amp; e.preventDefault();</span><br><span class="line">const img=document.getElementById(&apos;modal_img&apos;)</span><br><span class="line">const &#123; mouseDownX, mouseDownY,initX,initY,width,height&#125;=this.state</span><br><span class="line"></span><br><span class="line">        const moveX=e.pageX;</span><br><span class="line">        const moveY=e.pageY;</span><br><span class="line"></span><br><span class="line">       if(this.state.mouseDownFlag)&#123;</span><br><span class="line">           let left=parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">           let top=parseInt(moveY)-parseInt(mouseDownY)+parseInt(initY)</span><br><span class="line">            left=left&gt;0?0:</span><br><span class="line">            left&lt;900-width?900-width</span><br><span class="line">            :parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">           top=top&gt;0?0:</span><br><span class="line">            top&lt;650-height?650-height:top</span><br><span class="line">            if (width&lt;920) &#123;</span><br><span class="line">               left=0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (height&lt;650) &#123;</span><br><span class="line">                top=0;</span><br><span class="line">             &#125;</span><br><span class="line">            // console.log(&apos;222&apos;,left,top)</span><br><span class="line">            img.style.left=left+&apos;px&apos;;</span><br><span class="line">            img.style.top=top+&apos;px&apos;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleScale=(value)=&gt;&#123;</span><br><span class="line">       let &#123;scale&#125;=this.state;</span><br><span class="line">       let self=this</span><br><span class="line">        this.setState(&#123;disable:true&#125;,</span><br><span class="line">            ()=&gt;&#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    self.setState(&#123;disable:false&#125;)</span><br><span class="line">                &#125;, 800)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        if(value&gt;0)&#123;</span><br><span class="line">            this.drawImg(this.props.img,scale*1.1)</span><br><span class="line">            this.setState(&#123;scale:scale*1.1&#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.drawImg(this.props.img,scale/1.1)</span><br><span class="line">            this.setState(&#123;scale:scale/1.1&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handlerMouseWheel=(e)=&gt;&#123;</span><br><span class="line">        console.log(e.deltaY)</span><br><span class="line">        if(e.deltaY&lt;0)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        const &#123; img ,name,children&#125;=this.props</span><br><span class="line">        // const &#123;show&#125;=this.state</span><br><span class="line">        return(</span><br><span class="line">            &lt;span&gt;</span><br><span class="line">                &#123;/* &lt;span onClick=&#123;()=&gt;&#123;this.setState(&#123;show:true&#125;)&#125;&#125;&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">              &lt;/span&gt; */&#125;</span><br><span class="line">                &lt;Modal</span><br><span class="line">                    title=&#123;&lt;div&gt;</span><br><span class="line">                    &lt;span style=&#123;&#123;</span><br><span class="line">                        display: &apos;inline-block&apos;,</span><br><span class="line">                        width:6,</span><br><span class="line">                        height:16,</span><br><span class="line">                        marginRight:10,</span><br><span class="line">                        verticalAlign:&apos;center&apos;,</span><br><span class="line">                        backgroundColor: &apos;#4A9478&apos;,</span><br><span class="line">                    &#125;&#125;&gt;</span><br><span class="line">                    &lt;/span&gt;&lt;span&gt;&#123;name&#125;&lt;/span&gt;</span><br><span class="line">                        &lt;div style=&#123;&#123;float:&apos;right&apos;,marginRight:30&#125;&#125;&gt;</span><br><span class="line">                         &lt;Button onClick=&#123;()=&gt;this.handleScale(1)&#125; disabled=&#123;this.state.disable&#125;&gt;放大&lt;/Button&gt;</span><br><span class="line">                         &lt;Button onClick=&#123;()=&gt;this.handleScale(-1)&#125; style=&#123;&#123;marginLeft:10&#125;&#125; disabled=&#123;this.state.disable&#125;&gt;缩小&lt;/Button&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                     &lt;/div&gt;&#125;</span><br><span class="line">                    visible=&#123;true&#125;</span><br><span class="line">                    closable</span><br><span class="line">                    onCancel=&#123;()=&gt;&#123;this.props.showFlatModal(false)&#125;&#125;</span><br><span class="line">                    footer=&#123;null&#125;</span><br><span class="line">                    width=&#123;900&#125;</span><br><span class="line">                    bodyStyle=&#123;&#123;backgroundColor:&apos;#F3F2F6&apos;,borderBottomRightRadius:4,borderBottomLeftRadius:4,</span><br><span class="line">                        height:650,overflow:&apos;scroll&apos;,position:&apos;relative&apos;,padding:0,boxSizing:&apos;border-box&apos;,textAlign:&apos;center&apos;&#125;&#125;</span><br><span class="line">                    destroyOnClose</span><br><span class="line">                    maskClosable</span><br><span class="line">                    &gt;</span><br><span class="line"></span><br><span class="line">                        &lt;canvas id=&apos;modal_img&apos;</span><br><span class="line">                            style=&#123;&#123;</span><br><span class="line">                                width:this.state.width,</span><br><span class="line">                                height:this.state.height,</span><br><span class="line">                                cursor:&apos;pointer&apos;,</span><br><span class="line">                                position:&apos;absolute&apos;,</span><br><span class="line">                                left:0,</span><br><span class="line">                                top:0,</span><br><span class="line">                                // transform:`translate(-50%)`,</span><br><span class="line">                             &#125;&#125;</span><br><span class="line">                            onMouseDown=&#123;this.handlerMouseDown&#125;</span><br><span class="line">                            onMouseUp=&#123;this.handlerMouseUp&#125;</span><br><span class="line">                            onMouseMove=&#123;this.handlerMouseMove&#125;</span><br><span class="line">                            onWheel=&#123;this.handlerMouseWheel&#125;</span><br><span class="line">                            &gt;</span><br><span class="line"></span><br><span class="line">                        &lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">                &lt;/Modal&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native之FlatList</title>
    <url>/2019/01/14/react-native%E4%B9%8BFlatList/</url>
    <content><![CDATA[<p>代替旧版本中的ListView高性能列表组件<br><a id="more"></a></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>完全跨平台</li>
<li>支持水平布局模式</li>
<li>行组件显示或隐藏时可配置回调事件</li>
<li>支持单独的头部组件</li>
<li>支持单独的尾部组件</li>
<li>支持自定义行间分割线</li>
<li>支持下拉刷新</li>
<li>支持上拉加载</li>
<li>支持跳转到指定行（ScrollToIndex）<br>如果需要分组/类/区（section)，请使用<sectionlist><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FlatList data=&#123;[&#123;key:&apos;a&apos;&#125;,&#123;key:&apos;b&apos;&#125;]&#125;</span><br><span class="line">renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text&gt;&#123;item.key&#125;&lt;/Text&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</sectionlist></li>
</ul>
<p>本组件是基于<virtualizedlist>组件的封装，继承了其所有props和<scrollview>的props。</scrollview></virtualizedlist></p>
<ul>
<li>当某行滑出渲染区域之外后，其内部状态将不会保留。请确保你在行组件以外的地方保留了数据。</li>
<li>本组件继承自PureComponent，如果其props在浅比较中相等，则不会重新渲染。 如果renderItem函数所依赖的props数据，包括data属性以及可能用到的父组件的state，如果是一个引用类型，需要先修改其引用地址，然后再修改其值，否则可能不渲染。</li>
<li>为了优化内存占用同时保持滑动的流畅，列表内容会在屏幕外异步绘制。如果用户滑动的速度超过渲染速度，会先看到空白的内容。</li>
<li>默认情况下每行都需要提供一个不重复的key属性，也可以使用keyExtractor函数生成key</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><ul>
<li><p>renderItem<br>renderItem({item:Object,index:number,separators:{highlight:Function,unhighlight:Function, updateProps:Function(select:string,newProps:Object)]}})=&gt;React.Element<br>将data里面的数据循环渲染到列表中</p>
</li>
<li><p>data<br>目前只支持普通数组，如果使用其他特殊数据结构，入immutable请使用底层VirtualizedList组件</p>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FlatList</span><br><span class="line">      data=&#123;[&#123;key:&apos;a&apos;&#125;,&#123;key:&apos;b&apos;&#125;]&#125;</span><br><span class="line">      renderItem=&#123;(&#123;item,separators&#125;)=&gt;&#123;</span><br><span class="line">          return &lt;TouchableHighlight</span><br><span class="line">                  style=&#123;styles.listItem&#125;</span><br><span class="line">                  onPress=&#123;()=&gt;this._onPress(item)&#125;</span><br><span class="line">                  onShowUnderlay=&#123;separators.highlight&#125;</span><br><span class="line">                  onHideUnderlay=&#123;separators.unhighlight&#125;</span><br><span class="line"></span><br><span class="line">              &gt;</span><br><span class="line">                  &lt;View&gt;</span><br><span class="line">                      &lt;Text&gt;&#123;item.key&#125;&lt;/Text&gt;</span><br><span class="line">                  &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">          &lt;/TouchableHighlight&gt;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listItem:&#123;</span><br><span class="line">      width:width,</span><br><span class="line">      backgroundColor:&apos;#ddd&apos;,</span><br><span class="line">      alignItems: &apos;center&apos;,</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2019/01/14/react-native之FlatList/f1.jpg" alt="基本"></p>
</li>
</ul>
</li>
<li><p>ItemSeparatorComponent<br>行与行之间的分隔线组件，不会出现在第一行之前和最后一行之后。渲染函数提供highlighted(当前项是否是高亮状态)和leadingItem(第一项)两个参数</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ItemSeparatorComponent=&#123;(&#123;highlighted,leadingItem&#125;)=&gt;&#123;</span><br><span class="line">console.log(highlighted)</span><br><span class="line">return &lt;View style=&#123;[styles.separator,</span><br><span class="line">    highlighted&amp;&amp;&#123;backgroundColor:&quot;green&quot;&#125;]&#125;&gt;&lt;Text&gt;分隔线&lt;/Text&gt;&lt;/View&gt;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">separator:&#123;</span><br><span class="line">      height:20,</span><br><span class="line">      backgroundColor:&quot;red&quot;,</span><br><span class="line">      width:width,</span><br><span class="line">      alignItems: &apos;center&apos;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2019/01/14/react-native之FlatList/gif1.gif" alt="分隔符"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>ListEmptyComponent<br>列表为空时渲染该组件。可以是React Component，也可以是render函数，或者渲染好的element</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//function</span><br><span class="line"> ListEmptyComponent=&#123;()=&gt;(</span><br><span class="line">    &lt;Text&gt;暂无数据&lt;/Text&gt;</span><br><span class="line">)&#125;</span><br><span class="line">//React Component</span><br><span class="line">ListEmptyComponent=&#123;</span><br><span class="line">    &lt;Text&gt;暂无数据&lt;/Text&gt;</span><br><span class="line">&#125;</span><br><span class="line">// element</span><br><span class="line">let empty=&lt;Text&gt;暂无数据&lt;/Text&gt;</span><br><span class="line">ListEmptyComponent=&#123;empty&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式</p>
</li>
<li>效果<br><img src="/2019/01/14/react-native之FlatList/f2.jpg" alt="暂无数据"></li>
</ul>
</li>
<li><p>ListFooterComponent<br>尾部组件，可以是React Component，也可以是render函数，或者渲染好的element</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListFooterComponent=&#123;&lt;Text&gt;到尾部了&lt;/Text&gt;&#125;</span><br><span class="line">//同上也是三种形式</span><br></pre></td></tr></table></figure>
</li>
<li><p>样式</p>
</li>
<li>效果<br><img src="/2019/01/14/react-native之FlatList/f3.jpg" alt="尾部"></li>
</ul>
</li>
<li><p>ListHeaderComponent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListHeaderComponent=&#123;&lt;Text&gt;我是头部，我骄傲！&lt;/Text&gt;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2019/01/14/react-native之FlatList/f4.jpg" alt="尾部"></p>
</li>
<li><p>numColumns<br>number<br>多列布局，只能在非水平模式下使用，即必须horizontal={false},此时组件内元素会从左到右从上到下按照分组排列，类似启用了flexWrap的布局。组件内元素必须是等高的</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numColumns=&#123;4&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2019/01/14/react-native之FlatList/f5.jpg" alt="分组排布"></p>
</li>
</ul>
</li>
<li><p>columnWrapperStyle<br>如果设置了多列布局（即numColumns值设为大于1的整数),则可以额外指定此样式作用在每行容器上</p>
<ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">columnWrapperStyle=&#123;&#123;backgroundColor:&quot;red&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2019/01/14/react-native之FlatList/f6.jpg" alt="分组布局"></p>
</li>
</ul>
</li>
<li><p>extraData<br>除了data之外的数据用在列表中（不论是用在renderItem还是头部或者尾部组件中），请在此属性中指定。此数据在修改的时候也要先修改其引用地址，否则页面可能不刷新。</p>
</li>
<li><p>getItemLayout<br>(data, index) =&gt; {length:number, offset:number, index:number}<br>一个可选优化，用于避免动态测量内容尺寸的开销，需要提前知道内容的高度。</p>
</li>
<li><p>horizontal<br>设置为true则变为水平布局模式<br><img src="/2019/01/14/react-native之FlatList/f7.jpg" alt="水平布局"></p>
</li>
<li><p>initialNumToRender<br>number<br>指定一开始渲染的元素数量，最好够刚刚填满整个屏幕，保证最短时间给用户呈现可见的内容。<br>注意第一次渲染的元素不会再滑动的过程中被写在，保证在返回顶部的时候，不需要重新渲染首批元素。</p>
</li>
<li><p>initialScrollIndex<br>需要先设置getItemLayout属性<br>开始时屏幕顶端的元素是列表中的第initialScrollIndex个元素，而不是第一个元素。如果设置了该属性，则第一批initialNumToRender范围内的元素不会再保留在内存里，而是直接立刻渲染位于initialScrollIndex位置的元素。<br>（在Android上不生效）</p>
</li>
<li><p>inverted<br>翻转滚动方向。实质是将scale变换设置为-1</p>
</li>
<li><p>keyExtractor<br>（item:object,index:number) =&gt; string<br>此函数用于为给定的 item 生成一个不重复的 key。Key 的作用是使 React 能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。若不指定此函数，则默认抽取item.key作为 key 值。若item.key也不存在，则使用数组下标。</p>
</li>
<li><p>onEndReachedThreshold<br>决定距离内容最底部还有多远时触发onEndReached</p>
</li>
<li><p>onEndReached<br>（info:{distanceFromEnd:number}) =&gt;void<br>当列表被滚动到距离内容最底部不足onEndReachedThreshold的距离时调用。</p>
</li>
<li><p>redreshing<br>在等待加载新数据时将此属性设为true，列表会显示出一个正在加载的符号。</p>
</li>
<li><p>onRefresh<br>() =&gt; void<br>如果设置了此选项会在列表头部添加一个标准的RefreshControl空间，以便实现下拉刷新的功能，同时需要正确设置refreshing属性</p>
</li>
<li><p>viewabilityConfig<br>请参考ViewabilityHelper.js的源码来了解具体的配置。</p>
</li>
<li><p>onViewableItemsChanged<br>（info :{</p>
<pre><code>viewableItems:array,
changed:array,
</code></pre><p>})) =&gt; void<br>在可见行元素变化时调用。可见范围和变化频率等参数的配置请设置ViewabilityConfig属性</p>
</li>
<li><p>progressViewOffset<br>Android<br>当需要在指定的偏移处显示加载指示器的时候设置</p>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li><p>scrollToEnd()<br>滚动到底部，如果不设置getItemLayout可能会比较卡<br>参数：animated（boolean)是否有动画效果，默认true</p>
</li>
<li><p>scrollToIndex()<br>将位于指定位置的元素滚动到可视区域的指定位置。当viewPosition设为0时将它滚动到屏幕顶部，为1时将它滚动到屏幕底部，为0.5时将它滚动到屏幕中央。<br>注意：如果不设置getItemLayout属性的话，无法跳转到当前渲染区域以外的位置。<br>参数：animated（boolean)是否有动画效果，默认true</p>
<pre><code>index(number):滚动到第几个
viewOffset(number):与目标位置的偏移距离
viewPosition(0,0.5,1):滚动到哪个位置
</code></pre></li>
<li><p>scrollToItem()<br>会顺序遍历元素，尽可能使用scrollToIndex代替<br>参数：animated（boolean)是否有动画效果，默认true</p>
<pre><code>item(object):要滚动到的子组件
viewPosition(0,0.5,1):滚动到哪个位置
</code></pre></li>
<li><p>scrollToOffset()<br>滚动列表到指定的偏移（以像素为单位），等同于ScrollView的scrollTo方法。<br>参数：offset(number):偏移距离<br>  animated（boolean)是否有动画效果，默认true </p>
</li>
<li><p>recordInteraction()<br>主动通知列表发生了一个事件，以使列表重新计算可视区域，比如说当waitForInteractions为 true 并且用户没有滚动列表时。一般在用户点击了列表项或发生了导航动作时调用。</p>
</li>
<li><p>flashScrollIndicators()<br>短暂的显示滚动指示器</p>
</li>
</ul>
<h1 id="分别配置IOS和Android的样式"><a href="#分别配置IOS和Android的样式" class="headerlink" title="分别配置IOS和Android的样式"></a>分别配置IOS和Android的样式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  &#123; Platform,StyleSheet &#125;  from &apos;react-native&apos;</span><br><span class="line">const styles=StyleSheet.create(&#123;</span><br><span class="line">    ...PlatForm.select(&#123;</span><br><span class="line">        ios:&#123;</span><br><span class="line">            paddingTop:30</span><br><span class="line">        &#125;,</span><br><span class="line">        android:&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>ES9</title>
    <url>/2019/01/14/ES9/</url>
    <content><![CDATA[<p>ES2018 新特性</p>
<a id="more"></a>
<h2 id="for-await-of"><a href="#for-await-of" class="headerlink" title="for await...of"></a><code>for await...of</code></h2><p>在异步或者同步可迭代对象上创建一个迭代循环，包括<code>String</code>,<code>Array</code>,<code>Array-like</code>对象（比如<code>arguments</code>或者<code>NodeList</code>），<code>TypedArray</code>,<code>Map</code>,<code>Set</code>和自定义的异步或者同步迭代对象。其会调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function* asyncGenerator() &#123;</span><br><span class="line">      var i = 0</span><br><span class="line">      while (i &lt; 3) &#123;</span><br><span class="line">            yield i++</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async function() &#123;</span><br><span class="line">      for await (num of asyncGenerator()) &#123;</span><br><span class="line">            console.log(num)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>ES9 开始，模板字符串允许嵌套支持常见转义序列，移除对 ECMAScript 在带标签的模板字符串中转义序列的语法限制。<br>不过，非法转义序列在”cooked”当中仍然会体现出来。它们将以<code>undefined</code>元素的形式存在于”cooked”之中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function latex(str) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &quot;cooked&quot;: str[0],</span><br><span class="line">        &quot;raw&quot;: str.raw[0]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(latex `\unicode`) // &#123; cooked: undefined,//转义后的字符 raw: &quot;\unicode&quot; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="finally-gt"><a href="#finally-gt" class="headerlink" title=".finally(()=&gt;{})"></a><code>.finally(()=&gt;{})</code></h2><p>同.catch(),.then()一样用于异步操作<br>不管异步操作状态变为 reject 还是 resolve 都会执行 finally 中的回调函数，<br>表示异步操作已经执行完了</p>
<h2 id="正则表达式新特性"><a href="#正则表达式新特性" class="headerlink" title="正则表达式新特性"></a>正则表达式新特性</h2><ul>
<li>点匹配符 dotAll，匹配除了换行符(\n 或\r)之外的所有字符<br>如果想要匹配所有字符可以使用<code>\d</code>和<code>\D</code>表示一切数字和非数字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let regex = /./;</span><br><span class="line"></span><br><span class="line">regex.test(&apos;\n&apos;);       // false</span><br><span class="line">regex.test(&apos;\r&apos;);       // false</span><br><span class="line">regex.test(&apos;\u&#123;2028&#125;&apos;); // false</span><br><span class="line">regex.test(&apos;\u&#123;2029&#125;&apos;); // false</span><br><span class="line"> /one\.two/.test(&apos;one\ntwo&apos;) //false</span><br><span class="line">  /one[\d\D]two/.test(&apos;one\ntwo&apos;) //true</span><br></pre></td></tr></table></figure>
<p>ES2018 可以使用 s 标志配合./dotAll 匹配符，匹配所有的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/one\.two/s.test(&apos;one\ntwo&apos;) //true</span><br><span class="line">/s 表示将字符串视为单行来匹配</span><br></pre></td></tr></table></figure>
<ul>
<li> 匹配组命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const re=/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;</span><br><span class="line">const match=re.exec(&apos;2019-01-10&apos;);</span><br><span class="line">console.log(match.groups);// &#123;year:&apos;2019&apos;,month:&apos;01&apos;,day:&apos;10&apos;&#125;</span><br><span class="line">console.log(match.groups.year) //2019</span><br><span class="line">console.log(match.groups.month) //01</span><br><span class="line">console.log(match.groups.day) //10</span><br></pre></td></tr></table></figure>
<p> 可以使用 <code>\k&lt;name&gt;</code> 使用前面已经命名过得分组名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const re=/\b(?&lt;dup\w+&gt;\s+\k&lt;dup&gt;\b/</span><br><span class="line">\b单词边界</span><br><span class="line">\w+匹配一个或多少个数字、字母、下划线</span><br><span class="line">\s+匹配一个或多个空格</span><br><span class="line">使用&lt;?dup&gt; 表示匹配一个由一个或多个数字字母下划线组成的字符串，然后后面有一个或多个空格，后面是跟前面dup匹配到的一样的字符串</span><br><span class="line">所以上面的正则表达式是匹配两个相同的用空格连接的单词</span><br><span class="line"></span><br><span class="line">const match re.exec(&apos;Get that that cat off the table!&apos;)</span><br><span class="line">match.index   //4，匹配成功开始字符的下标</span><br><span class="line">match[0]     //that that</span><br></pre></td></tr></table></figure>
<p>在 replace 函数里面使用<code>\$&lt;name&gt;</code> 实现替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str=&apos;red &amp; blue&apos;;</span><br><span class="line">str.replace(/(red) &amp; (blue)/, &apos;$2 &amp; $1&apos;);</span><br><span class="line">str.replace(/(?&lt;red&gt;red) &amp; (?&lt;blue&gt;blue)/, &apos;$&lt;blue&gt; &amp; $&lt;red&gt;&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式反向-lookbehind-断言"><a href="#正则表达式反向-lookbehind-断言" class="headerlink" title="正则表达式反向(lookbehind)断言"></a>正则表达式反向(lookbehind)断言</h3><p>断言是一个对当前匹配位置之前或之后的字符的测试，它不会实际消耗任何字符，所以断言也被称为非消耗性匹配或非获取匹配。</p>
<ul>
<li><p><code>(?&lt;=pattern)</code>零宽反向肯定断言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const re=/(?&lt;=\$|£|€)\d+(\.\d*)?/;</span><br><span class="line">re.exec(&apos;199&apos;)</span><br><span class="line">//null</span><br><span class="line">re.exec(&apos;$199)</span><br><span class="line">//[&apos;199&apos;,undefined,index:1,input:&apos;$199&apos;,groups:undefined]</span><br><span class="line">re.exec(&apos;€50&apos;)</span><br><span class="line">//[&quot;50&quot;, undefined, index: 1, input: &quot;€50&quot;, groups: undefined]</span><br><span class="line">&apos;abc123&apos;.match(/(?&lt;=(\d+)(\d+))$/)</span><br><span class="line">// [&quot;&quot;, &quot;1&quot;, &quot;23&quot;, index: 6, input: &quot;abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>(?&lt;!pattern)</code>零宽反向否定断言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const re=/(?&lt;!un)available/;</span><br><span class="line">re.exec(&apos;We regret this service is currently unavailable&apos;)</span><br><span class="line">// null</span><br><span class="line">re.exec(&apos;this service is available)</span><br><span class="line">// [&quot;available&quot;, index: 15, input: &quot;The service is available&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式 Unicode 转义<br>\d 仅匹配数组字符[0,9]<br>\p{类型} 匹配某一类型的字符<br>匹配所有数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const regex = /^\p&#123;Number&#125;+$/u;</span><br><span class="line">regex.test(&apos;²³¹¼½¾&apos;) // true</span><br><span class="line">regex.test(&apos;㉛㉜㉝&apos;) // true</span><br><span class="line">regex.test(&apos;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&apos;) // true</span><br></pre></td></tr></table></figure>
<p>匹配所有空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\p&#123;White_Space&#125;</span><br></pre></td></tr></table></figure>
<p>匹配字母</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str=&apos;ض&apos;;</span><br><span class="line">/\p&#123;Alphabetic&#125;/u.test(str)  //true</span><br><span class="line">/\w/u.test(str)  //false</span><br></pre></td></tr></table></figure>
<p>否定匹配 \P{}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/\P&#123;Number&#125;/u.test(&apos;㉛&apos;)  //false</span><br><span class="line">/\P&#123;Number&#125;/u.test(&apos;ض&apos;)   //true</span><br><span class="line"></span><br><span class="line">/\P&#123;Alphabetic&#125;/u.test(&apos;㉛&apos;)  //true</span><br><span class="line">/\P&#123;Alphabetic&#125;/u.test(&apos;ض&apos;)   //false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象扩展操作符"><a href="#对象扩展操作符" class="headerlink" title="对象扩展操作符"></a>对象扩展操作符</h2><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a><code>Promise.prototype.finally()</code></h2><p>返回一个<code>Promise</code>，当 promise 的状态变更，不管变成<code>rejected</code>或<code>fulfilled</code>，最终都会执行<code>finally()</code>的回调。</p>
]]></content>
      <categories>
        <category>ECMA</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub-学习</title>
    <url>/2019/01/06/GitHub-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>GitHub,Gitlab<br><a id="more"></a></p>
<ul>
<li><p>搜索<br>关键词在readme里面匹配:关键词+ in:readme<br>星数范围：关键词+stars:&gt;5000<br>按照使用语言搜索<br>按照文件名搜索：关键词+filename:gitlab-cli.yml，结果是代码片段</p>
<ul>
<li>团队合作，合并分支：new pull request<ul>
<li>merge pull request</li>
<li>Squash and merge</li>
<li>Rebase and merge 线性，解决fast forward比较麻烦</li>
</ul>
</li>
</ul>
</li>
<li><p>代码合并流程图<br>insights/Network</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>hexo配置填坑</title>
    <url>/2018/12/27/hexo%E9%85%8D%E7%BD%AE%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<p>hexo+next的配置填坑<br><a id="more"></a></p>
<h1 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h1><p>可以使用多种搜索功能可以选择，但是第三方基本都是收费的，一般一个月试用期。<br>我使用过 algolia ,全英文网站，根据网上的教程勉强搞好了，用了20几天就提示收费了。<br>后来又回到本地的搜索功能也很好配置.(配置方法网上一大堆，可以搜索配置一下)</p>
<h2 id="字符报错"><a href="#字符报错" class="headerlink" title="字符报错"></a>字符报错</h2><p>首先，之前用过，但是写个几个页面后，再搜索发现一直在loading，控制也没有报错<br>可以在根路由后添加/search.xml，查看搜索功能使用的xml文件，发现报错<br><img src="/2018/12/27/hexo配置填坑/img1.jpg" alt="xml报错" title="xml报错"><br>说是xml里面有不是UTF-8的字符，但是XML上面明明写着，encoding=’utf-8’</p>
<p><strong>解决办法：</strong><br>把xml里面的不合法字符替换为空格<br>我用的是vsCode,可以直接使用正则表达式替换 ([\x00-\x1F\x7F])<br><img src="/2018/12/27/hexo配置填坑/img2.jpg" alt="正则替换" title="正则替换"><br>在public找到search.xml，直接替换到不合法字符</p>
<h2 id="xml里的一堆数字"><a href="#xml里的一堆数字" class="headerlink" title="xml里的一堆数字"></a>xml里的一堆数字</h2><p>打开search.xml还发现好多数字<br><img src="/2018/12/27/hexo配置填坑/img3.jpg" alt="数字" title="数字"><br>本来以为是复制粘贴过程，粘贴后的内容含有样式<br>后来发现只有代码有这个问题，且根据数字的规律发现是代码段的行数<br><img src="/2018/12/27/hexo配置填坑/img4.jpg" alt="codes" title="codes"><br>把文字章内容转为xml的时候把行数也看做了内容，花了一晚上也没研究出是哪里转的，或是怎么去掉行数，最后，还得再search.xml上做文章，</p>
<p><strong>两个解决办法</strong><br>1.不理他反正也不报错，就是搜索数子的时候会出来一堆乱七八糟的东西<br>2.手动删除<br>就是这么low实在是在好多配置文章下留言都没有回复，加了qq群也没有人回复，只能靠自己的能力解决。暂时就这样吧。</p>
<p>这个主题配置费了太多时间，还是花更多时间在自己文章上面，才有意义。加油</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之ScrollView</title>
    <url>/2018/12/26/react-native%E4%B9%8BScrollView/</url>
    <content><![CDATA[<p>ScrollView 是一个通用的可滚动的容器，可以包含多个组件和视图<br>不仅可以垂直滚动也可以水平滚动</p>
<a id="more"></a>
<h1 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;ScrollView&gt;</span><br><span class="line">        &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;1 Scroll me plz&lt;/Text&gt;</span><br><span class="line">        &lt;Image source=&#123;&#123;uri: &quot;https://facebook.github.io/react-native/img/favicon.png&quot;, width: 160, height: 160&#125;&#125; /&gt;</span><br><span class="line">        &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;2 Scroll me plz&lt;/Text&gt;</span><br><span class="line">        &lt;Image source=&#123;&#123;uri: &quot;https://facebook.github.io/react-native/img/favicon.png&quot;, width: 160, height: 160&#125;&#125; /&gt;</span><br><span class="line">        &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;3 Scroll me plz&lt;/Text&gt;</span><br><span class="line">        &lt;Image source=&#123;&#123;uri: &quot;https://facebook.github.io/react-native/img/favicon.png&quot;, width: 160, height: 160&#125;&#125; /&gt;</span><br><span class="line">        &lt;Text style=&#123;&#123;fontSize:96&#125;&#125;&gt;4 Scroll me plz&lt;/Text&gt;</span><br><span class="line">        &lt;Image source=&#123;&#123;uri: &quot;https://facebook.github.io/react-native/img/favicon.png&quot;, width: 160, height: 160&#125;&#125; /&gt;</span><br><span class="line">    &lt;/ScrollView&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2018/12/26/react-native之ScrollView/gif1.gif" alt="react-image-magnify"></p>
<p><strong>注意事项</strong></p>
<ul>
<li>必须有一个固定的高度</li>
<li>不建议直接  设置高度</li>
<li>使用 flex:1，使其自动填充父容器的剩余空间。前提条件是所有的父容器本身也设置了 flex 或指定高度。</li>
<li>ScrollView 内部的其他响应者尚无法阻止 ScrollView 本身成为响应者。</li>
<li>只适用于简单数据的渲染，逻辑复杂的数据可以使用 Flatlist</li>
</ul>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ul>
<li><p>horizontal<br>默认是垂直方向上排成一列<br>horizontal={true}，子视图会在水平方向上排列<br><strong>效果</strong><br><img src="/2018/12/26/react-native之ScrollView/gif2.gif" alt="horizontal"></p>
</li>
<li><p>alwaysBounceVertical<br>IOS 属性<br>默认为 true，垂直方向即使内容比滚动视图本身还要小，也可以弹性拉动。<br>当 horizontal={true}时默认值为 false,否则为 true</p>
</li>
<li><p>alwaysBounceHorizontal<br>IOS<br>默认为 true，即使水平方向比滚动视图小，也可以弹性拉动。<br>当 horizontal={true}时默认值为 false,否则为 true</p>
</li>
<li><p>keyboardDismissMode<br>用户拖动视图的时候，是否要隐藏软键盘<br>通用值：</p>
<ul>
<li>none（默认值），拖动时不隐藏软键盘</li>
<li>on-frag，开始拖拽的时候隐藏软键盘<br> IOS：</li>
<li>interactive, 软键盘在拖动的时候逐渐消失，并且上滑会恢复键盘。android 设置此属性和 none 效果一致</li>
</ul>
</li>
<li><p>keyboardShouldPersistTaps<br>点击 scrollView 后是否收起软键盘</p>
<ul>
<li>never(默认值)，点击 TextInpt 以为的子组件会使当前的软键盘收起。子元素不会收到点击事件</li>
<li>always，键盘不会收起，ScrollView 也不捕捉到点击事件，但子组件可以捕获</li>
<li>handled，当点击事件被子组件捕获时，键盘不会自动收起。切换 TextInput 时键盘可以保持状态，多个 TextInput 的 scrollView 可以使用这个组件。</li>
</ul>
</li>
<li><p>pagingEnabled<br>当值为 true 时，滚动条会停在滚动视图尺寸的整数倍位置。<br>默认为 false，可以用在水平分页上。<br>垂直分页在 Android 上不支持</p>
</li>
<li><p>refreshControl<br>指定 RefreshControl 组件，用于为 ScrollView 提供下拉刷新功能，只能用于垂直视图，即 horizontal 不能为 true</p>
</li>
<li><p>removeClippedSubviews(使用特性)<br>默认为 true，屏幕之外的子视图（overflo 为 hidden）被移除。可以提高滚动性能</p>
</li>
<li><p>scrollEnable<br>默认为 true，为 false 的时候禁止用户滚动，但是可以调用 scrollTo 滚动</p>
</li>
<li><p>showHorizontalScrollIndicator<br>默认为 true，当 horizontal={true}显示水平方向的滚动条<br>为 false 时不显示水平滚动条</p>
</li>
<li><p>showVerticalScrollIndicator<br>默认为 true，垂直滚动的时候显示垂直方向的滚动条<br>为 false 时不显示垂直滚动条</p>
</li>
<li><p>enFillColor<br>滚动视图占据比实际内容更多的空间，可以使用此属性指定某种颜色填充多余的空间。</p>
</li>
<li><p>automaticallAdjustContentInsets<br>当滚动视图放在一个导航条或工具条后的时候，IOS 系统是否自动调整内容的范围。<br>默认为 true。<br>如果你的 ScrollView 或 FlatList 的头部出现莫名其妙的空白，尝试此属性设为 false</p>
</li>
<li><p>overScrollMode(Android 没发现效果)<br>覆盖默认的 overScroll 模式</p>
<ul>
<li>auto 默认值，允许用户在内容超出视频高度后可以滚动</li>
<li>always，无论内容尺寸，用户始终可滚动视图</li>
<li>never，始终不允许用户滚动视图</li>
</ul>
</li>
<li><p>bounces （IOS）<br>为 true（默认）时，范围比滚动视图本身大，到达内容尾部的时候，可以弹性拉动一截。<br>为 false，尾部的所有弹性都会被禁用。即使 alwaysBounce 属性为 true</p>
</li>
<li><p>bouncesZoom（IOS）<br>为 true 时，使用手势缩放内容可以超过 min/max 限制，然后在手指抬起之后弹回 min/max 的缩放比例。<br>为 false 时，缩放不能超出限制</p>
</li>
<li><p>canCancelContentTouches（IOS）<br>为 false 时，一旦子节点响应触摸操作，即使手指开始移动也不会拖动滚动视图。<br>默认为 true</p>
</li>
<li><p>centerContent（IOS）<br>值为 true 时，如果滚动视图的内容比视图本身小，则会自动把内容居中放置。当内容比滚动视图大的时候，此属性没有作用。<br>默认为 false</p>
</li>
<li><p>contentInset（IOS）<br>内容范围相对视图边缘的坐标。默认为{top:0,left:0,bottom:0,right:0}</p>
</li>
<li><p>contentOffset（IOS）<br>用来手动设置初始的滚动坐标，默认值{x:0,y:0}</p>
</li>
<li><p>decelerationRate<br>一个浮点数，决定用户抬起手指后，滚动视图减速停下的速度。<br>可以设为 normal 或 fast。分别对应是 IOS 上的 UIScrollViewDecelerationRateNormal 和 UIScrollViewDecelerationRateFast</p>
<ul>
<li>normal：IOS 上是 0，998，Android 上是 0.985（默认值）</li>
<li>fast：0.99</li>
</ul>
</li>
<li><p>directionalLockEnabled IOS）<br>为 true 时，滚动视图在拖拽的时候会锁定只有垂直或水平方向可以滚动，<br>默认为 false</p>
</li>
<li><p>indicatorStyle（IOS）<br>设置滚动条的样式，</p>
<ul>
<li>default 默认值，等同 black</li>
<li>black 黑白滚动条</li>
<li>white 白色滚动条</li>
</ul>
</li>
<li><p>maximumZoomScale（IOS）<br>允许的最大缩放比例。默认为 1.0</p>
</li>
<li><p>minimumZoomScale (IOS)<br>允许最小的缩放比例。默认为 1.0</p>
</li>
<li><p>pinchGestureEnabled(IOS)<br>设置为 true 时，ScrollView 会允许用过使用双指缩放操作。默认为 true</p>
</li>
<li><p>scrollEventThrottle（IOS）<br>控制滚动过程中，scroll 事件被调用的频率（单位是每秒的实际数量）。<br>数值越小越能及时追踪滚动位置，不过会带来性能问题。<br>由于 JS 事件循环需要和屏幕刷新率同步，设置 1-16 之间的数值不会有实质区别。<br>默认为 0，每次视图滚动，scroll 事件只会被调用一次。</p>
</li>
<li><p>scrollIndicatorInsets（IOS）<br>决定滚动条距离视图边缘的坐标。这个值应该和 contentInset 一样<br>默认为{top:0,left:0,right:0,bottom:0}</p>
</li>
<li><p>scrollToTop<br>为 true 时，点击状态栏的时候视图会滚动到顶部。<br>默认为 true</p>
</li>
<li><p>snapToInterval<br>数字类型<br>设置了此属性，会让滚动视图停止后，停止在 snapToInterval 的倍数的位置。<br>可以在一些子视图比滚动视图小的时候用于实现分页，需要与 snapToAlignment 组合使用。</p>
</li>
<li><p>snapTopAlignment<br>当设置了，snapToInterval，snapToAlignment 会定义停住点与滚动视图之间的关系</p>
<ul>
<li>start（默认）会将停住点对齐在左侧（水平）或顶部（垂直）</li>
<li>center 会将停住点对齐到中间</li>
<li>end 会将停驻点对齐到右侧（水平）或底部（垂直）</li>
</ul>
</li>
<li><p>zoomScale<br>滚动视图内容当前的缩放比例。默认为 1.0</p>
</li>
<li><p>onContentSizeChange<br>ScrollView 内部可滚动内容的视图发生变化的时候调用。<br>参数为内容视图的宽高:(contentWidth,contentHeight)<br>此方法是通绑定在内容容器上的 onLayout 来实现</p>
</li>
<li><p>onMomentumScrollBegin<br>滚动动画开始的时候调用</p>
</li>
<li><p>onMomentumScrollEnd<br>滚动动画结束时调用</p>
</li>
<li><p>onScroll<br>在滚动过程中，每帧最多调用一次此回调函数，调用的频率可以使用 scrollEventThrottle 属性来控制</p>
</li>
<li><p>onScrollBeginDrag<br>用户开始拖动此视图调用此函数</p>
</li>
<li><p>onScrollBeginEnd<br>用户停止拖动视图的时候调用此函数</p>
</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p>scrollTo()<br>(y: number | { x?: number, y?: number, animated?: boolean }, x: number, animated: boolean)<br>滚动到指定的 x,y 偏移处。第三参数为是否开启平滑滚动视图<br>scrollTo({x:0,y:0,animated:true})</p>
</li>
<li><p>scrollToEnd(([options]:object))<br>滚动到视图底部（水平方向的视图则滚动到最右边）<br>加上动画参数 scrollToEnd({animated:true}),启动平滑滚动动画。<br>scrollToEnd({animated:false})立即跳转。<br>不使用参数，默认启动动画</p>
</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="轮播"><a href="#轮播" class="headerlink" title="轮播"></a>轮播</h2><p><strong>效果</strong><br><img src="/2018/12/26/react-native之ScrollView/gif3.gif" alt="轮播"><br><strong>填坑</strong><br>使用分页的时候，利用偏移的位置/宽度得到当前页数，但是宽度相除得到的不是整数，要处理一下，才能实现原点 的效果<br><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var imageData= require(&apos;./images/ImageData.json&apos;)</span><br><span class="line">var imgAry=imageData.data;</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  Platform,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  TextInput,</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button,</span><br><span class="line">  TouchableOpacity,</span><br><span class="line">  TouchableWithoutFeedback,</span><br><span class="line">  TouchableHighlight,</span><br><span class="line">  ScrollView,</span><br><span class="line">  Image</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line">// 获取屏幕宽高</span><br><span class="line">import Dimensions from &apos;Dimensions&apos;</span><br><span class="line"></span><br><span class="line">const width=Dimensions.get(&apos;window&apos;).width;</span><br><span class="line">const height=Dimensions.get(&apos;window&apos;).height;</span><br><span class="line"></span><br><span class="line">export default class SetUp extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        var timer=null;</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            currentPage:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        //自动轮播</span><br><span class="line">        let &#123;currentPage&#125;=this.state</span><br><span class="line">        this.timer= setInterval(()=&gt;&#123;</span><br><span class="line">            currentPage=currentPage&lt;imgAry.length-1?++currentPage:0</span><br><span class="line">            this.scroll.scrollTo(&#123;x:width*currentPage,y:0&#125;)</span><br><span class="line">            this.setState(&#123;currentPage&#125;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnMount()&#123;</span><br><span class="line">        this.timer&amp;&amp;clearInterval(this.timer)</span><br><span class="line">    &#125;</span><br><span class="line">    //渲染图片</span><br><span class="line">    renderItem()&#123;</span><br><span class="line">        var itemAry=[];</span><br><span class="line">        itemAry= imgAry.map((item,index)=&gt;&lt;Image key=&#123;index&#125; style=&#123;styles.itemStyle&#125; source=&#123;&#123;uri:item.img&#125;&#125;/&gt;)</span><br><span class="line">        return itemAry</span><br><span class="line">    &#125;</span><br><span class="line">    //渲染原点</span><br><span class="line">    renderPagingIndicator()&#123;</span><br><span class="line">        var itemAry=[];</span><br><span class="line">        itemAry=imgAry.map((item,index)=&gt;&lt;TouchableOpacity key=&#123;index&#125;  onPress=&#123;() =&gt;this.handlePress(index)&#125;&gt;</span><br><span class="line">            &lt;Text  style=&#123;&#123;fontSize:50,color:Number(this.state.currentPage)===Number(index)?&apos;red&apos;:&apos;#ddd&apos;&#125;&#125;&gt;·&lt;/Text&gt;</span><br><span class="line">            &lt;/TouchableOpacity&gt;)</span><br><span class="line">        return  itemAry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handlePress = index =&gt;&#123;</span><br><span class="line">        this.setState(&#123;currentPage:index&#125;)</span><br><span class="line">        this.scroll.scrollTo(&#123;x:width*index,y:0&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //轮播动画</span><br><span class="line">    handleAnimate = (e) =&gt; &#123;</span><br><span class="line">        //水平方向偏移量</span><br><span class="line">        var offsetX=e.nativeEvent.contentOffset.x;</span><br><span class="line">        console.log(&apos;offsetX&apos;,offsetX)</span><br><span class="line">        var currentPage=(offsetX.toFixed(0)/width.toFixed(0)).toFixed(0);</span><br><span class="line">        console.log(&apos;currentPage&apos;,currentPage)</span><br><span class="line">        this.setState(&#123;currentPage&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;ScrollView</span><br><span class="line">                 ref=&#123;ref=&gt;this.scroll=ref&#125;</span><br><span class="line">                 style=&#123;styles.scrollViewStyle&#125;</span><br><span class="line">                 horizontal=&#123;true&#125;</span><br><span class="line">                 pagingEnabled=&#123;true&#125;</span><br><span class="line">                 showsHorizontalScrollIndicator=&#123;false&#125;</span><br><span class="line">                 showsHorizontalScrollIndicator=&#123;false&#125;</span><br><span class="line">                 //一帧滚动完毕的时候调用</span><br><span class="line">                 onMomentumScrollEnd=&#123;this.handleAnimate&#125;</span><br><span class="line">                &gt;</span><br><span class="line"></span><br><span class="line">                    &#123;this.renderItem()&#125;</span><br><span class="line">                &lt;/ScrollView&gt;</span><br><span class="line">                &lt;View style=&#123;styles.renderPagingIndicatorStyle&#125;&gt;</span><br><span class="line">                    &#123;this.renderPagingIndicator()&#125;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    backgroundColor:&apos;white&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  itemStyle:&#123;</span><br><span class="line">      width:width,</span><br><span class="line">      height:200,</span><br><span class="line">      //图片等比例缩放</span><br><span class="line">      resizeMode:&apos;contain&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  scrollViewStyle:&#123;</span><br><span class="line">      backgroundColor:&apos;yellow&apos;,</span><br><span class="line">      marginTop:20</span><br><span class="line">  &#125;,</span><br><span class="line">  renderPagingIndicatorStyle:&#123;</span><br><span class="line">      backgroundColor:&apos;transparent&apos;,</span><br><span class="line">      flexDirection:&apos;row&apos;,</span><br><span class="line">      justifyContent:&apos;center&apos;,</span><br><span class="line">      width:width,</span><br><span class="line">      position:&apos;absolute&apos;,</span><br><span class="line">      bottom:0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>图片</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;img&quot;:&quot;https://upload.jianshu.io/admin_banners/web_images/4590/7f1edd154f90446a038d6ecd10bebf6e8929fbf5.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540&quot;,</span><br><span class="line">            &quot;title&quot;:&quot;图片一&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            &quot;img&quot;:&quot;https://upload.jianshu.io/admin_banners/web_images/4600/67db00190e013279ccac4b00bc5702c5f974b9aa.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540&quot;,</span><br><span class="line">            &quot;title&quot;:&quot;图片二&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            &quot;img&quot;:&quot;https://upload.jianshu.io/admin_banners/web_images/4592/cd1030acd8a908397ed53775bcb0dbd5a05727ef.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540&quot;,</span><br><span class="line">            &quot;title&quot;:&quot;图片三&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            &quot;img&quot;:&quot;https://upload.jianshu.io/admin_banners/web_images/4588/c9d175a9865206d371742d53c41ed4a042c5d00b.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540&quot;,</span><br><span class="line">            &quot;title&quot;:&quot;图片四&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            &quot;img&quot;:&quot;https://upload.jianshu.io/admin_banners/web_images/4596/1686f2fe090d3a75481c6fad69aba5396f82d260.png?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540&quot;,</span><br><span class="line">            &quot;title&quot;:&quot;图片五&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;other&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;:&quot;其它信息&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之练习demo</title>
    <url>/2018/12/25/react-native%E4%B9%8B%E7%BB%83%E4%B9%A0demo/</url>
    <content><![CDATA[<p>使用react-native写一个简书App登录页面<br>本来想使用一些阿里的IconFont，貌似超出目前的能力范围，暂时搁置。<br><a id="more"></a></p>
<p><strong>需求</strong></p>
<p><img src="/2018/12/25/react-native之练习demo/img1.jpeg" title="手机APP截图"><br><strong>效果</strong><br><img src="/2018/12/25/react-native之练习demo/img2.jpg" title="IOS/"></p>
<p><img src="/2018/12/25/react-native之练习demo/img3.jpg" title="Android/"></p>
<p>本来看着IOS的效果好点，谁知道莫名其妙xcode估计升级了，变成全面屏了，丑爆了</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="样式的复用"><a href="#样式的复用" class="headerlink" title="样式的复用"></a>样式的复用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//两个类</span><br><span class="line">style=&#123;[style.color1,style.btn]&#125;</span><br><span class="line">//类+内联</span><br><span class="line">style=&#123;[style.btn,&#123;color:&apos;red&apos;&#125;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>效果是两个输入框紧靠着，就需要将上边的下边框或者下边的上边框宽度变为0，react-native有属性，borderTopWidth和borderBottomWidth,我是将下面输入框borderTopWidth:0,在IOS上可行，但是Android不生效，百度半天也没找到这类样式问题<br>我的解决:不用border属性，而是将下面输入框的marginTop=-1。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他 "></a>其他 </h3><p>react-native已经废弃了Button，按钮使用Touchable<br>总体跟react差不多，样式上没有太大问题<br>主要是怎么适用多个屏幕，这个还需要后面多加学习</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &#123;</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View,</span><br><span class="line">    Image,</span><br><span class="line">    TextInput,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">    </span><br><span class="line">&#125; from &apos;react-native&apos;</span><br><span class="line">import Dimensions from &apos;Dimensions&apos;</span><br><span class="line">const width=Dimensions.get(&apos;window&apos;).width;</span><br><span class="line">const height=Dimensions.get(&apos;window&apos;).height;</span><br><span class="line"></span><br><span class="line">const inputHeight=60</span><br><span class="line">const viewInputPadding=15</span><br><span class="line">const iconWH=20</span><br><span class="line"></span><br><span class="line">export default class Login extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &#123;/* logo */&#125;</span><br><span class="line">                &lt;Image  source=&#123;require(&apos;./images/logo.png&apos;)&#125;/&gt;</span><br><span class="line">                &lt;View style=&#123;styles.form&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;&#123;color:&apos;#EB857B&apos;&#125;&#125;&gt;上次登入方式:微信&lt;/Text&gt;</span><br><span class="line">                    &#123;/* 用户名 */&#125;</span><br><span class="line">                    &lt;View style=&#123;[styles.inputView,styles.user]&#125; &gt;</span><br><span class="line">                        &lt;Image style=&#123;styles.inputImg&#125;  source=&#123;require(&apos;./images/user.png&apos;)&#125;/&gt;</span><br><span class="line">                        &lt;TextInput  </span><br><span class="line">                            style=&#123;styles.userInput&#125;</span><br><span class="line">                            placeholder=&apos;手机或邮箱&apos;</span><br><span class="line">                            placeholderTextColor=&apos;#939293&apos;</span><br><span class="line">                            underlineColorAndroid=&apos;transparent&apos;</span><br><span class="line">                            /&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                     &#123;/* 密码 */&#125;</span><br><span class="line">                    &lt;View style=&#123;[styles.inputView,styles.password]&#125; &gt;</span><br><span class="line">                        &lt;Image style=&#123;styles.inputImg&#125; source=&#123;require(&apos;./images/password.png&apos;)&#125;/&gt;</span><br><span class="line">                        &lt;TextInput</span><br><span class="line">                         style=&#123;styles.psdInput&#125;</span><br><span class="line">                         placeholder=&apos;密码&apos; </span><br><span class="line">                         secureTextEntry=&#123;true&#125;</span><br><span class="line">                         placeholderTextColor=&apos;#939293&apos;</span><br><span class="line">                         underlineColorAndroid=&apos;transparent&apos;</span><br><span class="line">                         /&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                    &lt;TouchableOpacity  </span><br><span class="line">                         style=&#123;styles.btn&#125;</span><br><span class="line">                         onPress=&#123;()=&gt;alert(&apos;登录&apos;)&#125;</span><br><span class="line">                        &gt;   </span><br><span class="line">                        &lt;Text style=&#123;styles.btnText&#125; &gt;登录&lt;/Text&gt;</span><br><span class="line">                    &lt;/TouchableOpacity&gt;</span><br><span class="line">                    &lt;TouchableOpacity</span><br><span class="line">                     onPress=&#123;()=&gt;alert(&apos;忘记密码&apos;)&#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                     &lt;Text style=&#123;&#123;marginTop:20,fontSize:18,color:&apos;#929192&apos;&#125;&#125;&gt;忘记密码?&lt;/Text&gt; </span><br><span class="line">                    &lt;/TouchableOpacity&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                &lt;View &gt;</span><br><span class="line">                    &lt;View style=&#123;styles.title&#125;&gt;</span><br><span class="line">                        &lt;View style=&#123;styles.line&#125;&gt;&lt;/View&gt;</span><br><span class="line">                        &lt;Text style=&#123;&#123;color:&apos;#939293&apos;,marginLeft:15,marginRight:15,fontSize:16&#125;&#125;&gt;社交账号直接登录&lt;/Text&gt;</span><br><span class="line">                        &lt;View  style=&#123;styles.line&#125;&gt;&lt;/View&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                    &lt;View style=&#123;styles.appIconList&#125;&gt;</span><br><span class="line">                         &lt;TouchableOpacity</span><br><span class="line">                            style=&#123;[styles.appIconView,&#123;backgroundColor:&apos;#51B340&apos;&#125;]&#125;</span><br><span class="line">                         &gt;</span><br><span class="line">                            &lt;Image style=&#123;styles.appIcon&#125; source=&#123;require(&apos;./images/wechat.png&apos;)&#125;/&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                        &lt;TouchableOpacity </span><br><span class="line">                            style=&#123;[styles.appIconView,&#123;backgroundColor:&apos;#5987C7&apos;&#125;]&#125;</span><br><span class="line">                        &gt;</span><br><span class="line">                             &lt;Image style=&#123;styles.appIcon&#125;  source=&#123;require(&apos;./images/qq.png&apos;)&#125;/&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                        &lt;TouchableOpacity</span><br><span class="line">                            style=&#123;[styles.appIconView,&#123;backgroundColor:&apos;#D35A4C&apos;&#125;]&#125;</span><br><span class="line">                        &gt;</span><br><span class="line">                          &lt;Image  style=&#123;styles.appIcon&#125;  source=&#123;require(&apos;./images/xl.png&apos;)&#125;/&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                        &lt;TouchableOpacity</span><br><span class="line">                            style=&#123;[styles.appIconView,&#123;borderColor:&apos;#CECDCE&apos;,borderWidth:1&#125;]&#125;</span><br><span class="line">                        &gt;</span><br><span class="line">                          &lt;Text style=&#123;&#123;color:&apos;#757475&apos;,fontSize:12&#125;&#125;&gt;其它&lt;/Text&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">                &lt;View style=&#123;styles.other&#125;&gt;</span><br><span class="line">                        &lt;TouchableOpacity onPress=&#123;()=&gt;alert(&apos;注册&apos;)&#125; style=&#123;styles.otherTouch&#125;&gt;</span><br><span class="line">                            &lt;Text style=&#123;&#123;color:&apos;#EB857B&apos;,fontSize:18,&#125;&#125; &gt;注册&lt;/Text&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                        &lt;TouchableOpacity onPress=&#123;()=&gt;alert(&apos;随便看看&apos;)&#125; style=&#123;styles.otherTouch&#125;&gt;</span><br><span class="line">                            &lt;Text style=&#123;&#123;color:&apos;#8B8A8B&apos;,fontSize:18&#125;&#125; &gt;随便看看&lt;/Text&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                        &lt;TouchableOpacity onPress=&#123;()=&gt;alert(&apos;登录遇到问题&apos;)&#125; style=&#123;&#123;paddingLeft:10&#125;&#125;&gt;</span><br><span class="line">                            &lt;Text style=&#123;&#123;color:&apos;#8B8A8B&apos;,fontSize:18&#125;&#125; &gt;登录遇到问题?&lt;/Text&gt;</span><br><span class="line">                        &lt;/TouchableOpacity&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const styles=StyleSheet.create(&#123;</span><br><span class="line">    container:&#123;</span><br><span class="line">        flex:1,</span><br><span class="line">        width:width,</span><br><span class="line">        height:height,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">        paddingTop: &apos;20%&apos;,</span><br><span class="line">        paddingBottom:&apos;10%&apos;,</span><br><span class="line">        justifyContent:&apos;space-between&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    form:&#123;</span><br><span class="line">       width:0.9*width ,</span><br><span class="line">       alignItems: &apos;center&apos;,</span><br><span class="line">     </span><br><span class="line">    &#125;,</span><br><span class="line">    inputView:&#123;</span><br><span class="line">        width:&apos;100%&apos;,</span><br><span class="line">        alignItems:&apos;center&apos;,</span><br><span class="line">        flexDirection: &apos;row&apos;,</span><br><span class="line">        borderColor:&apos;#ddd&apos;,</span><br><span class="line">        borderRadius:5,</span><br><span class="line">        borderWidth:1,</span><br><span class="line">        height:inputHeight,</span><br><span class="line">        paddingLeft:viewInputPadding,</span><br><span class="line">        justifyContent:&apos;space-between&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    user:&#123;</span><br><span class="line">        marginTop:10,</span><br><span class="line">        borderBottomLeftRadius:0,</span><br><span class="line">        borderBottomRightRadius: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    password:&#123;</span><br><span class="line">        marginTop:-1,</span><br><span class="line">        borderTopLeftRadius:0,</span><br><span class="line">        borderTopRightRadius: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    inputImg:&#123;</span><br><span class="line">        width:iconWH,</span><br><span class="line">        height:iconWH</span><br><span class="line">    &#125;,</span><br><span class="line">    userInput:&#123;</span><br><span class="line">        width:0.9*width-(viewInputPadding*2+iconWH),</span><br><span class="line">        borderWidth:0</span><br><span class="line">    &#125;,</span><br><span class="line">    psdInput:&#123;</span><br><span class="line">        width:0.9*width-(viewInputPadding*2+iconWH),</span><br><span class="line">        borderWidth:0</span><br><span class="line">    &#125;,</span><br><span class="line">    btn:&#123;</span><br><span class="line">        width:0.9*width,</span><br><span class="line">        backgroundColor:&apos;#A1C5E2&apos;,</span><br><span class="line">        height:50,</span><br><span class="line">        marginTop:20,</span><br><span class="line">        borderRadius:5,</span><br><span class="line">        justifyContent:&apos;center&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    btnText:&#123;</span><br><span class="line">        textAlign:&apos;center&apos;,</span><br><span class="line">        color:&apos;#fff&apos;,</span><br><span class="line">        fontSize:20,</span><br><span class="line">    &#125;,</span><br><span class="line">    title:&#123;</span><br><span class="line">        flexDirection:&apos;row&apos;,</span><br><span class="line">        justifyContent:&apos;center&apos;,</span><br><span class="line">        alignItems:&apos;center&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    line:&#123;</span><br><span class="line">        width:50,</span><br><span class="line">        height:1,</span><br><span class="line">        backgroundColor:&apos;#D3D2D3&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    appIconList:&#123;</span><br><span class="line">        flexDirection:&apos;row&apos;,</span><br><span class="line">        marginTop:30,</span><br><span class="line">        width:0.9*width-(viewInputPadding*2+iconWH),</span><br><span class="line">        justifyContent:&apos;space-around&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    appIconView:&#123;</span><br><span class="line">        width:46,</span><br><span class="line">        height:46,</span><br><span class="line">        borderRadius:23,</span><br><span class="line">        alignItems:&apos;center&apos;,</span><br><span class="line">        justifyContent:&apos;center&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    appIcon:&#123;</span><br><span class="line">        width:28,</span><br><span class="line">        height:28</span><br><span class="line">    &#125;,</span><br><span class="line">    other:&#123;</span><br><span class="line">        flexDirection:&apos;row&apos;,</span><br><span class="line">        justifyContent:&apos;center&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    otherTouch:&#123;</span><br><span class="line">        paddingLeft:10,</span><br><span class="line">        paddingRight:10,</span><br><span class="line">        borderRightWidth:1,</span><br><span class="line">        borderColor:&apos;#CBCACB&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>DOM操作</title>
    <url>/2018/12/21/DOM%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>DOM Element 对象</p>
<a id="more"></a>
<h1 id="Document-节点"><a href="#Document-节点" class="headerlink" title="Document 节点"></a>Document 节点</h1><h2 id="Document-节点属性"><a href="#Document-节点属性" class="headerlink" title="Document 节点属性"></a>Document 节点属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.doctype //返回当前文档的文档类型</span><br><span class="line">document.documentElement //返回当前文档的根节点</span><br><span class="line">document.defaultView //返回document对象所在的window对象</span><br><span class="line">document.body   //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head   //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement //返回当前文档中获得焦点的元素</span><br><span class="line"></span><br><span class="line">//节点集合属性</span><br><span class="line">document.links // 返回当前文档的所有a元素</span><br><span class="line">document.forms //返回页面所有表单元素</span><br><span class="line">document.images //返回页面中所有图片元素</span><br><span class="line">document.embeds //返回网页中所有嵌入对象</span><br><span class="line">document.scripts //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">//文档信息属性</span><br><span class="line">document.documentURI //表示当前文档的网址</span><br><span class="line">document.URL //返回当前文档的网址</span><br><span class="line">document.domain //返回当前文档的域名</span><br><span class="line">document.lastModified  //返回当前文档最后修改的时间戳</span><br><span class="line">document.location  //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer  //返回当前文档的访问来源</span><br><span class="line">document.title    //返回当前文档的标题</span><br><span class="line">document.characterSet //属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span><br><span class="line">document.readyState  //返回当前文档的状态</span><br><span class="line">document.designMode  //控制当前文档是否可编辑，可读写</span><br><span class="line">document.cookie   //用来操作Cookie</span><br></pre></td></tr></table></figure>
<h2 id="Document-节点方法"><a href="#Document-节点方法" class="headerlink" title="Document 节点方法"></a>Document 节点方法</h2><h2 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.open()   //用于新建并打开一个文档</span><br><span class="line">document.close()   //不安比open方法所新建的文档</span><br><span class="line">document.write()   //用于向当前文档写入内容</span><br><span class="line">document.writeIn()  //用于向当前文档写入内容，尾部添加换行符</span><br></pre></td></tr></table></figure>
<h2 id="节点查找-API"><a href="#节点查找-API" class="headerlink" title="节点查找 API"></a>节点查找 API</h2><ul>
<li><code>document.getElementById(&#39;id&#39;)</code><br>返回指定 ID 的元素</li>
<li><code>document.getElementsByTagName(&#39;tagName&#39;)</code><br>返回拥有指定标签名的所有子元素的集合。如果是*，表示查询所有标签</li>
<li><code>document.getElementsByClassName(&#39;class&#39;)</code><br>返回指定 class 的对象集合</li>
<li><code>document.getElementsByName(&#39;name&#39;)</code><br>根据元素的 name 属性查找，返回一个 NodeList 。</li>
<li><code>document.querySelector(&#39;#id&gt;.class&#39;)</code><br>返回第一符合条件的节点</li>
<li><code>document.querySelectorAll(&#39;#id&gt;.class&#39;)</code><br>返回所有符合条件的节点集合</li>
</ul>
<h2 id="节点创建-API"><a href="#节点创建-API" class="headerlink" title="节点创建 API"></a>节点创建 API</h2><ul>
<li><p><code>document.createElement(&#39;div&#39;)</code> 创建元素</p>
</li>
<li><p><code>document.createTextNode(&#39;文本内容&#39;)</code> 创建文本节点</p>
</li>
<li><p><code>cloneNode(true/false)</code> 克隆节点，参数表示是否克隆子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const form=document.getElementById(&apos;test&apos;);</span><br><span class="line">let clone=form.cloneNode(true)</span><br><span class="line">clone.id=&apos;test2&apos;;</span><br><span class="line">document.body.appendChild(clone)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>document.createAttribute(name)</code> 生成一个新的属性对象节点，并返回它</p>
</li>
<li><code>document.createDocumentFragment()</code> 生成一个 DocumentFragment 对象</li>
</ul>
<h2 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture)  //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture)  //注销事件</span><br><span class="line">document.dispatchEvent(event)  //触发事件</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span><br><span class="line">document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。</span><br><span class="line">document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。</span><br></pre></td></tr></table></figure>
<h1 id="Element-节点"><a href="#Element-节点" class="headerlink" title="Element 节点"></a>Element 节点</h1><h2 id="与元素本身特征相关的属性"><a href="#与元素本身特征相关的属性" class="headerlink" title="与元素本身特征相关的属性"></a>与元素本身特征相关的属性</h2><ol>
<li><code>element.attributes</code> 返回指定节点的属性集合（类数组对象）</li>
<li><code>element.id</code> 返回指定元素的 id 属性，可读写</li>
<li><code>element.tagName</code> 返回指定元素的大写标签名</li>
<li><p><code>element.innerHTML</code> 设置或返回元素的内容<br>如果设置该属性为空，就是删除它包含的所有节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">el.innerHTML=&apos;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>element.tagName</code> 返回指定元素的大写标签名</p>
</li>
<li><code>element.outerHTML</code> 返回指定元素节点的所有 HTML 代码，包括它自身和包含的的所有子元素，可读写</li>
<li><code>Element.className</code> //返回当前元素的 class 属性，可读写</li>
<li><code>Element.classList</code> //返回当前元素节点的所有 class 集合</li>
<li><code>Element.dataset</code> 返回节点 data-开头的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;user&quot; data-id=&quot;1234567890&quot; data-user=&quot;johndoe&quot; data-date-of-birth&gt;John Doe&lt;/div&gt;</span><br><span class="line">ele.dataset.id === &apos;1234567890&apos;</span><br></pre></td></tr></table></figure>
<h2 id="查找节点方法"><a href="#查找节点方法" class="headerlink" title="查找节点方法"></a>查找节点方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.querySelector()</span><br><span class="line">Element.querySelectorAll()</span><br><span class="line">Element.getElementsByTagName()</span><br><span class="line">Element.getElementsByClassName()</span><br></pre></td></tr></table></figure>
<h2 id="插入节点-API"><a href="#插入节点-API" class="headerlink" title="插入节点 API"></a>插入节点 API</h2><ul>
<li><p><code>appendChild</code> 向父节点的最后一个子节点后追加新节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.appendChild(child)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>insertBefore</code> 向父节点的某个特定子节点之前插入新节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.insertBefore(newChild,existingChild)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改节点-API"><a href="#修改节点-API" class="headerlink" title="修改节点 API"></a>修改节点 API</h2><ul>
<li><p><code>replaceChild</code> 用新节点替换父节点中已有的子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.replaceChild(newChild,existingChild)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删除节点-API"><a href="#删除节点-API" class="headerlink" title="删除节点 API"></a>删除节点 API</h2><ul>
<li><p><code>removeChild</code> 删除已有节点，返回值为删除节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent.removeChild(existingChild)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="节点判断"><a href="#节点判断" class="headerlink" title="节点判断"></a>节点判断</h2><ul>
<li><code>parent.contains(node)</code> 返回 Boolean,表示参数节点是否为当前节点的后代节点</li>
<li><code>Node.isEqualNode(node)</code> 返回 Boolean,用于检查两个节点是否相等，指的是两个节点的类型相同、属性相同、子节点相同</li>
<li><code>Node.normalize()</code> 用于清理当前节点内部的所有 Text 节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</li>
</ul>
<h2 id="节点属性-API"><a href="#节点属性-API" class="headerlink" title="节点属性 API"></a>节点属性 API</h2><ul>
<li><p>获取属性</p>
<ul>
<li><code>Node.nodeName</code>，返回节点名称，只读</li>
<li><code>Node.nodeType</code>，返回节点类型的常数值，只读</li>
<li><code>Node.nodeValue</code>，返回 Text 或 Comment 节点的文本值，只读</li>
<li><code>Node.textContent</code>，返回当前节点和它的所有后代节点的文本内容，可读写</li>
<li><code>Node.baseURI</code>，返回当前网页的绝对路径</li>
<li><code>Node.ownerDocument</code>，返回当前节点所在的顶层文档对象，即 document</li>
</ul>
</li>
<li><p><code>element.className</code> 设置或返回元素的 class 属性</p>
</li>
<li><p><code>getAttribute</code> 获取节点属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.getAttribute(&apos;src&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>setAttribute</code> 修改节点属性,如果属性已存在，则仅设置/更改值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.setAttribute(attributeName,attributeValue)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>removeAttribute</code> 删除具有指定属性名称的属性，无返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.removeAttribute(&apos;属性名&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hasAttribute()</code> 元素是否有指定属性，返回 Boolean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.hasAttribute(&apos;onclick&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="节点关系-API"><a href="#节点关系-API" class="headerlink" title="节点关系 API"></a>节点关系 API</h2><ol>
<li><p>父关系</p>
<ul>
<li><p><code>parentNode</code> 返回父节点，父节点可能是 Element，Document 或 DocumentFragment；如果没有返回 null</p>
</li>
<li><p><code>parentElement</code> 返回元素的父元素节点，其父节点必须是一个 Element 元素，如果不是，则返回 null；</p>
</li>
</ul>
</li>
<li><p>子节点</p>
<ul>
<li><code>children</code> 返回 HTMLCollection，子节点都是 Element，IE9 以下浏览器不支持；</li>
<li><code>childNodes</code> 返回 NodeList，子节点可能包含文本节点、注释节点等</li>
<li><code>firstChild</code> 第一个字节点，不存在返回 null</li>
<li><code>lastChild</code> 最后一个字节点，不存在返回 null</li>
<li><code>Node.firstElementChild</code> //返回当前节点的第一个 Element 子节点</li>
<li><code>Node.lastElementChild</code> //返回当前节点的最后一个 Element 子节点</li>
<li><code>Node.childElementCount</code> //返回当前节点所有 Element 子节点的数目。</li>
</ul>
</li>
<li><p>兄弟关系</p>
<ul>
<li><p><code>previousSibling</code> 前一个节点，可能包含文本节点、注释节点等</p>
</li>
<li><p><code>nextSibling</code> 后一个节点，可能包含文本节点、注释节点等</p>
</li>
<li><p><code>previousElementSibling</code> 返回前一个元素节点，前一个节点必须是 Element，注意 IE9 以下浏览器不支持。</p>
</li>
<li><code>nextElementSibling</code> 返回后一个元素节点，后一个节点必须是 Element，注意 IE9 以下浏览器不支持。</li>
</ul>
</li>
</ol>
<h2 id="Element-节点的方法"><a href="#Element-节点的方法" class="headerlink" title="Element 节点的方法"></a>Element 节点的方法</h2><ul>
<li><code>Element.getBoundingClientRect()</code><br>位置，返回一个对象，包含 top,left,right,bottom,width,height<ul>
<li>top 元素上外边界距窗口最上面的距离</li>
<li>right 元素右外边界距窗口最上面的距离</li>
<li>bottom 元素下外边界距窗口最上面的距离</li>
<li>left 元素左外边界距窗口最上面的距离</li>
<li>width 元素自身宽(包含 border,padding)</li>
<li>height 元素自身高(包含 border,padding)</li>
</ul>
</li>
<li><code>Element.getClientRects()</code><br>返回一个指向客户端中每一个盒子的边界矩形的矩形集合。</li>
</ul>
<p><strong>元素在页面上的偏移量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rect = el.getBoundingClientRect()</span><br><span class="line">return &#123;</span><br><span class="line">  top: rect.top + document.body.scrollTop,</span><br><span class="line">  left: rect.left + document.body.scrollLeft</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Element-对象盒状模型属性"><a href="#Element-对象盒状模型属性" class="headerlink" title="Element 对象盒状模型属性"></a>Element 对象盒状模型属性</h2><ol>
<li><p><code>element.clientHeight,element.clientWidth</code><br><code>element.clientHeight</code>：返回元素的可见高度<br><code>element.clientWidth</code>：返回元素的可见宽度<br><code>Element.clientLeft</code>：返回元素节点左边框的宽度<br><code>Element.clientTop</code>：返回元素节点顶部边框的宽度<br>包含 padding+CSS 高度<br>不包括溢出（overflow）、滚动条、边框、和 margin</p>
<p>对于整个网页来说，当前可见高度（即视口高度）要从 document.documentElement 对象（即<html>节点）上获取，<br>等同于 window.innerHeight-水平滚动条的高度，window.innerWidth-垂直滚动条宽度。<br>没有滚动条时两值相等，有滚动条前者小于后者</html></p>
<p>视口的高度和宽度（包括滚动条），有两种方法可以获得。<br>对于整个网页，基本都不会设置 border，所以只考虑 padding 和滚动条的影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 视口高度</span><br><span class="line">window.innerHeight // 包括滚动条</span><br><span class="line">document.documentElement.clientHeight // 不包括滚动条</span><br><span class="line"></span><br><span class="line">// 视口宽度</span><br><span class="line">window.innerWidth // 包括滚动条</span><br><span class="line">document.documentElement.clientWidth // 不包括滚动条</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>element.offsetHeight,element.offsetWidth</code><br><code>element.offsetHeight</code>：返回元素的高度<br><code>element.offsetWidth</code>：返回元素的宽度<br>包含 Padding+Border+滚动条<br>如果不存在内容溢出，element.offsetHeight 比 element.clientHeight 多了边框的高度</p>
<p>整张网页的高度，可以在 document.documentElement 和 document.body 上读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//网页总高度</span><br><span class="line">document.documentElement.offsetHeight</span><br><span class="line">document.body.offsetHeight</span><br><span class="line">//网页总宽度</span><br><span class="line">document.documentElement.offsetWidth</span><br><span class="line">document.body.offsetWidth</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>element.offsetLeft,element.offsetTop</code>（可读 像素）<br><code>element.offsetLeft</code>：返回元素左上角相对于 Element.offsetParent 节点的水平偏移位置<br><code>element.offsetTop</code>：返回元素的垂直偏移位置，通常，这两个值指相对于父节点的位移</p>
</li>
<li><p><code>element.scrollHeight,element.scrollWidth</code>（只读）（像素）<br><code>element.scrollHeight</code>：返回元素的整体高度<br><code>element.scrollWidth</code>：返回元素的整体宽度</p>
<p>它们返回的是整个元素的高度或宽度，包括由于存在滚动条和不可见的部分。默认情况下，它们包括 Padding，但不包括 Border 和 Margin。</p>
<p>整张网页的总高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.documentElement.scrollHeight</span><br><span class="line">document.body.scrollHeight</span><br></pre></td></tr></table></figure>
<p>如果内容没有溢出，element.scrollHeight=element.clientHeight<br>存在溢出时当滚动条到内容底部时，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.scrollHeight-element.scrollTop===element.clientHeight //true</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>element.scrollTop,element.scrollLeft</code>（可读 像素）<br><code>element.scrollTop</code>：返回元素的水平滚动条向右侧滚动的距离<br><code>element.scrollLeft</code>：返回元素水平滚动条向下滚动的距离<br>对于那些没有滚动条的网页元素，这两个属性总是等于 0。</p>
<p>整张网页的水平或垂直滚动距离</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.documentElement.scrollLeft</span><br><span class="line">document.documentElement.scrollTop</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Element.style</code> 返回元素节点的行内样式</p>
</li>
</ol>
<h2 id="事件方法-1"><a href="#事件方法-1" class="headerlink" title="事件方法"></a>事件方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.addEventListener()：添加事件的回调函数</span><br><span class="line">Element.removeEventListener()：移除事件监听函数</span><br><span class="line">Element.dispatchEvent()：触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">// event对象</span><br><span class="line">var event = window.event||event;</span><br><span class="line"></span><br><span class="line">// 事件的目标节点</span><br><span class="line">var target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">// 事件代理</span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123;</span><br><span class="line">    console.log(event.target.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析 HTML 字符串，然后将生成的节点插入 DOM 树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString);</span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入</span><br><span class="line">Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入</span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入</span><br><span class="line">Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove() //用于将当前元素节点从 DOM 中移除</span><br><span class="line">Element.focus() //用于将当前页面的焦点，转移到指定元素上</span><br></pre></td></tr></table></figure>
<h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ol>
<li><p>直接修改元素的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ele.style.color=&apos;red&apos;;</span><br><span class="line">ele.setAttribute(&apos;style&apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line"></span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName]</span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&apos;:after&apos;)[attrName]</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态添加样式规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var style=document.createElement(&apos;style&apos;);</span><br><span class="line">style.innerHTML=&apos;body&#123;color:red&#125; #top:hover&#123;background-color: red;color: white;&#125;&apos;</span><br><span class="line">document.head.appendChild(style)</span><br></pre></td></tr></table></figure>
</li>
<li><p>类名操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &apos; &apos; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&apos;gi&apos;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">//ie10</span><br><span class="line">ele.classList.remove(&apos;foo&apos;,&apos;bar&apos;);</span><br><span class="line">ele.classList.add(&apos;anotherClass&apos;,&apos;bar&apos;);</span><br><span class="line">ele.classList.toggle(&apos;visible&apos;);//存在就去掉，不存在就添加</span><br><span class="line">ele.classList.toggle(&apos;visible&apos;,i&lt;10)//根据条件增加、删除属性</span><br><span class="line">ele.classList.contains(&apos;foo&apos;);//是否包含属性</span><br><span class="line">ele.classList.replace(&apos;foo&apos;,&apos;bar&apos;);//替换属性</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>window对象</title>
    <url>/2018/12/21/window%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>使用 window 创建全局变量，遇到坑。<br>来学习一下 window 对象到底是什么？</p>
<a id="more"></a>
<p>首先记录一下遇到的坑：<br>在 react 项目里面使用向 window 对象添加新属性的方式创建一个全局变量，以便在整个项目中复用该变量，<br>天真的以为将 window.SERVERHOST=’<a href="http://localhost:3000&#39;放在任何地方都可以，" target="_blank" rel="noopener">http://localhost:3000&#39;放在任何地方都可以，</a><br>所以就偷懒放到了封装请求 api.js,以便打包部署的时候一起改变请求 Server 地址 。<br>测试发现刷新某些页面之后 window.SERVERHOST 拿到的永远是 undefined，<br><strong>注意</strong> window 对象在刷新页面之后会重置<br>之所以有些页面还可以拿到，是因为页面刷新同时发送请求，执行了 api.js，重新设置 window.SERVERHOST=’<a href="http://localhost:3000&#39;" target="_blank" rel="noopener">http://localhost:3000&#39;</a></p>
<p>解决方法：<br>1、将 window.SERVERHOST=’<a href="http://localhost:3000&#39;放到所有页面都要执行的路由配置文件中，" target="_blank" rel="noopener">http://localhost:3000&#39;放到所有页面都要执行的路由配置文件中，</a><br>这样刷新后重新判断路由，就可以创建新的全局 SERVERHOST<br>2、创建一个 js 文件，创建常量 const SERVERHOST=’<a href="http://localhost:3000&#39;,然后export" target="_blank" rel="noopener">http://localhost:3000&#39;,然后export</a> { SERVERHOST},<br>在其他需要使用的页面就可以通过 import 引入该变量。同样，其他全局需要使用的一些变量或方法也可以都放在该文件中。</p>
<p>由于其他均使用了 window.SERVERHOST，所有我采用的方法一，其实方法二更合理一些</p>
<h1 id="Wndow-对象"><a href="#Wndow-对象" class="headerlink" title="Wndow 对象"></a>Wndow 对象</h1><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>指当前浏览器窗口，是所有对象的顶层对象<br>JS 规定，浏览器环境的所有全局变量，都是 window 对象的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a=1;</span><br><span class="line">window.a //1</span><br></pre></td></tr></table></figure>
<h4 id="Window-对象的属性"><a href="#Window-对象的属性" class="headerlink" title="Window 对象的属性"></a>Window 对象的属性</h4><ol>
<li><p>window.window 指向自身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.window===this //true</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.name 用于设置当前浏览器窗口的名字</p>
</li>
<li><p>window.location<br>返回一个 location 对象，用于获取窗口当前的 URL 信息。<br>等同于 document.location 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.location===document.location //true</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.closed 返回一个布尔值，表示窗口是否关闭<br>一般用来检查使用脚本打开的新窗口是否关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x=window.open();</span><br><span class="line">x.closed //false</span><br><span class="line">if(x!=null &amp;&amp; !x.closed)&#123;</span><br><span class="line">   console.log(&apos;窗口仍然打开&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.opener<br>窗口是用 javascript 打开时，指向打开它的那人窗口（开启者）<br>如果没有父窗口则返回 null</p>
</li>
<li><p>window.screenX，window.screenY，<br>window.screenLeft 和 window.screenTop</p>
<p>window.screenX/window.screenLeft：返回浏览器窗口左上角相对于当前屏幕左上角((0,0))的水平距离；<br>window.screenY/window.screenTop：返回浏览器窗口左上角相对于当前屏幕左上角((0,0))的垂直距离</p>
<p>IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY。</p>
</li>
<li><p>window.innerHeight,window.innerWidth（只读属性）<br>window.innerHeight：返回当前窗口中可见部分的高度，即视口（viewport），单位为像素<br>window.innerWidth：返回当前窗口中可见部分的宽度，即视口（viewport），单位像素<br><strong>注意</strong>,<br>这两个属性不包括菜单栏、工具栏及滚动条的高度和宽度（在 Mac Chrome 上测试的）<br>IE 不支持这些属性，用 document.documentElement 或 document.body 的 clientWidth 和 clientHeight 属性作为代替</p>
</li>
<li><p>window.outHeight,window.outWidth（只读整数）<br>window.outHeight：返回浏览器窗口的高度，包括浏览器菜单和边框，单位为像素<br>window.outWidth：返回浏览器窗口的宽度，包括浏览器菜单和边框，单位为像素<br><strong>注意</strong>，IE 不支持此属性，没有替代属性</p>
</li>
<li><p>window.pageXOffset,window.pageYOffset（像素）<br>window.pageXOffset：设置或返回当前页面相对于窗口显示区左上角的  水平距离（滚动距离）。<br>window.pageYOffset：设置或返回当前页面相对于窗口显示区左上角的垂直距离（滚动距离）。</p>
</li>
</ol>
<h4 id="Window-对象的方法"><a href="#Window-对象的方法" class="headerlink" title="Window 对象的方法"></a>Window 对象的方法</h4><p><strong>窗体控制</strong></p>
<ul>
<li><code>moveBy(x,y)</code><br>从当前位置水平移动窗体 x 个像素，垂直移动窗体 y 个像素，x 为负数，将向左移动窗体，y 为负数，将向上移动窗体</li>
<li><code>moveTo(x,y)</code><br>移动窗体左上角到相对于屏幕左上角的(x,y)点，当使用负数做为参数时会吧窗体移出屏幕的可视区域</li>
<li><code>resizeBy(w,h)</code><br>相对窗体当前的大小，宽度调整 w 个像素，高度调整 h 个像素。如果参数为负值，将缩小窗体，反之扩大窗体</li>
<li><code>resizeTo(w,h)</code><br>把窗体宽度调整为 w 个像素，高度调整为 h 个像素</li>
</ul>
<p><strong>窗体滚动轴控制</strong></p>
<ol>
<li><p>window.scrollTo(x,y)把内容滚动到指定的坐标<br>x:内容显示区左上角相对于浏览器窗口的 x 坐标<br>y:内容显示区左上角相对于浏览器窗口的 y 坐标</p>
</li>
<li><p>window.scrollBy(x ,y)内容滚动指定的像素数<br>x：把文档向右滚动的像素数<br>y：把文档向下滚动的像素数</p>
</li>
</ol>
<p><strong>新建窗体</strong><br>window.open(URL,name,features,replace)<br>用于新建另一个浏览器窗口，并返回该窗口对象或查找一个已命名的窗口</p>
<ul>
<li>URL：可选字符串，要在新窗口中显示的文档的 URL，<br>如果省略该参数（about:blank） 或是空字符串，新窗口不会显示任何文档</li>
<li>name：可选字符串，新窗口的名字， 包含数字、 字母、下划线<br>如果该名字的窗口已存在，则跳到该窗口，就不再新建窗口。<br>如果省略默认使用_blank，新建一个没有名字的窗口</li>
<li>features：可选字符串，内容为逗号分隔的键值对<br> 声明新窗口要显示的标准浏览器的特征。如果省略，新窗口将显示所有标准特征。</li>
<li>replace：可选布尔值，规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：<br>true - URL 替换浏览历史中的当前条目。<br>false - URL 在浏览历史中创建新的条目。</li>
</ul>
<p><strong>关闭窗体</strong><br>window.close()<br>一般用来关闭 window.open 方法新建的窗口<br>将关闭有 window 指定的顶层浏览器窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = window.open(&apos;baidu.html&apos;,&apos;baidu&apos;);</span><br><span class="line">a.close()</span><br></pre></td></tr></table></figure>
<h3 id="子对象"><a href="#子对象" class="headerlink" title="子对象"></a>子对象</h3><ul>
<li>document 对象</li>
<li>frames 对象</li>
<li>history 对象</li>
<li>location 对象</li>
<li>navigator 对象</li>
<li>screen 对象</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之Touchable介绍与使用</title>
    <url>/2018/12/20/react-native%E4%B9%8BTouchable%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>react-native 的点击事件或手势监听</p>
<a id="more"></a>
<p>使用事件响应事件做手势监听， 但是在不同标签上有的属性是不能做出相应的响应的，比如下面的例子,同样的属性，在 View 上不可使用，在 Text 上就可以<br>_效果_</p>
<p><img src="/2018/12/20/react-native之Touchable介绍与使用/gif1.gif" alt="onPress"></p>
<p>示例组件</p>
<h3 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h3><p>用于封装视图，使其正确响应触摸操作，当按下的时候，封装视图的透明度会提高。<br>通过将子元素封装在一个 Animated.View 中实现，这个动画视图会被添加到视图层级中，少数情况下有可能影响到布局<br>与 TouchableHighlight 的区别在于没有而外的颜色变化，更适于一般场景</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; TouchableOpacity&#125; from &apos;react-native&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TouchableOpacity Touchable属性&gt;</span><br><span class="line">    &lt;需要包装的标签&gt;&lt;/需要包装的标签&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>
<p>使用 TouchableOpacity 包装一下上面的两个组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;TouchableOpacity</span><br><span class="line">    onPress=&#123;()=&gt;alert(&apos;点击了View&apos;)&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;View style=&#123;styles.view&#125;&gt;&lt;/View&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br><span class="line">&lt;TouchableOpacity</span><br><span class="line">    onPress=&#123;()=&gt;alert(&apos;点击了Text&apos;)&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;Text style=&#123;styles.text&#125;&gt;Text组件&lt;/Text&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif3.gif" alt="IOS"><br>在 Android 里面  貌似没有透明度变化的效果<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif2.gif" alt="Android"></p>
<h3 id="Touchable-常用属性"><a href="#Touchable-常用属性" class="headerlink" title="Touchable 常用属性"></a>Touchable 常用属性</h3><p>Touchable 中包含四类：</p>
<ul>
<li>TouchableWithoutFeedback：不带任何反馈的可触摸组件</li>
<li>TouchableHighlight：高亮触摸</li>
<li>TouchableOpacity：不透明触摸</li>
<li><p>TouchableNativeFeedback(仅支持 Android，水波纹效果)</p>
<p><strong>详细</strong></p>
</li>
</ul>
<ol>
<li><p>TouchableWithoutFeedback<br> 触发后没有效果，一般不建议使用。<br>只支持一个子节点(必须有一个)，如果想要  包含多个子节点可以使用 View 包装起来。<br><strong>译注</strong>常见的使用场景比如想实现点击空白处触发某个操作，那么就可以把空白部分用 TouchableWithoutFeedback 包起来，或者绝对定位覆盖住。</p>
<p>_属性_ - disable：bool，如果为 true，禁止此组件的一切交互 - accessible：bool，设置该组件是否可以  访问 - accessibilityTraits： 设置访问特性 - accessibilityComponentType：设置可访问的组件类型 - delayLongPress：从 onPressIn 开始到 onLongPress 被调用的延迟， 单位：毫秒 - delayPressIn：从触摸操作开始到 onPressIn 被调用的延迟， 单位：毫秒 - delayPressOut：从触摸操作结束  为开始到 OnPressOut 被调用的延迟， 单位：毫秒 - hitSlop： 定义触摸对象的偏移范围，会使 pressRetentionOffset 变得更大，但是不会超出父视图的边界，且保留原先的触摸优先级。<br>值：object:{top:number,left:number,bottom:number,right:number} - pressRetentionOffset：当前视图不能滚动的前提下  指定这个属性，可以决定当手指移开多远距离之后，不会激活按钮，但是如果手指再次  移回范围内，按钮会再次激活。<br>值：object:{top:number,left:number,bottom:number,right:number}<br>_方法_ - onFocus：组件获取焦点 - onBlur：组件失去焦点</p>
<pre><code>- onLongPress：长按
- onPress：触摸操作结束时调用，但如果被取消则不调用（例如响应被一个滚动操作取代）
- onPressIn：按下，在onPress之前调用
- onPressOut：触摸释放之后就调用，在onPress之前
- onLayout：当加载或布局改变的时候被调用，获取当前组件宽高即位置或用于检测设备竖横屏
参数为{nativeEvent:{layout:{x,y,width,height}}}，
</code></pre><p><strong>例子 onPressIn 和 onPressOut</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//布局</span><br><span class="line"> &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableWithoutFeedback</span><br><span class="line">        onPressIn=&#123;()=&gt;alert(&apos;PressIn&apos;)&#125;</span><br><span class="line">        onPressOut=&#123;()=&gt;alert(&apos;PressOut&apos;)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">             &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableWithoutFeedback&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line"></span><br><span class="line">//style</span><br><span class="line">container: &#123;</span><br><span class="line">    width:width,</span><br><span class="line">    backgroundColor: &apos;#F5FCFF&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">view:&#123;</span><br><span class="line">    marginTop:50,</span><br><span class="line">    width:width,</span><br><span class="line">    height:80,</span><br><span class="line">    backgroundColor:&apos;#ddd&apos;,</span><br><span class="line">    justifyContent:&apos;center&apos;,</span><br><span class="line">    alignItems:&apos;center&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">text:&#123;</span><br><span class="line">    color:&apos;red&apos;,</span><br><span class="line">    fontSize:16,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif4.gif" alt="onPressIn、onPressOut"></p>
<p>添加两个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delayPressIn=&#123;1000&#125;</span><br><span class="line">delayPressOut=&#123;3000&#125;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif7.gif" alt="delayPressIn、delayPressOut"></p>
<font color="#FF0000"> 试了  几遍，delayPressIn 貌似没有效果。点击了立马跳出来 </font>

<p><strong>例子 onPress 和 onLongPress</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableWithoutFeedback</span><br><span class="line">        onPress=&#123;()=&gt;alert(&apos;Press&apos;)&#125;</span><br><span class="line">        onLongPressOut=&#123;()=&gt;alert(&apos;LongPress&apos;)&#125;</span><br><span class="line"></span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableWithoutFeedback&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif5.gif" alt="Press、LongPress"></p>
<p><strong>例子 onLayout</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableWithoutFeedback</span><br><span class="line">        onLayout=&#123;(props)=&gt;&#123;console.log(props.nativeEvent)&#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">            &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableWithoutFeedback&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>加载的时候 console.log 打印出<br><img src="/2018/12/20/react-native之Touchable介绍与使用/img1.jpg" alt="onLayout"><br><strong>例子 hitSlop</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//布局</span><br><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableWithoutFeedback</span><br><span class="line">        onPress=&#123;()=&gt;alert(&apos;Press&apos;)&#125;</span><br><span class="line">        hitSlop=&#123;&#123;top:100,bottom:100,left:50,right:50&#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableWithoutFeedback&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line"></span><br><span class="line">//样式</span><br><span class="line">container: &#123;</span><br><span class="line">    flex:1,</span><br><span class="line">    backgroundColor: &apos;red&apos;,</span><br><span class="line">    justifyContent:&apos;center&apos;,</span><br><span class="line">    alignItems:&apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  view:&#123;</span><br><span class="line">    backgroundColor:&apos;#999&apos;,</span><br><span class="line">    borderColor:&apos;#333&apos;,</span><br><span class="line">    borderWidth:10,</span><br><span class="line">    height:300,</span><br><span class="line">    width:200,</span><br><span class="line">    justifyContent:&apos;center&apos;,</span><br><span class="line">    alignItems:&apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  text:&#123;</span><br><span class="line">    color:&apos;red&apos;,</span><br><span class="line">    fontSize:26,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif6.gif" alt="Press、LongPress"><br><strong>例子 pressRetentionOffset</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableWithoutFeedback</span><br><span class="line">        onPress=&#123;()=&gt;&#123;alert(&apos;响应&apos;)&#125;&#125;</span><br><span class="line">        pressRetentionOffset=&#123;&#123;top:100,bottom:100,left:50,right:50&#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableWithoutFeedback&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<font color="#FF0000"> 试了半天，没有  想象中的效果 </font>

<ol>
<li><p>TouchableHighlight<br>用于封  装视图，使其可以正确响应触摸操作。当按下时，封装视图的不透明度会降低，同时底层颜色会显示， 使视图变亮或变暗。<br>实现方法是，创建一个  新的视图到视图层级，如果使用方法不正确，会导致出现一些不希望出现的视觉  效果。例如没有给视图的 backgroundColor 显示声明一个不透明的颜色。<br>只支持一个子节点(必须有一个)，如果想要  包含多个子节点可以使用 View 包装起来。</p>
<p><em>属性和方法</em></p>
<ul>
<li>继承 TouchableWithoutFeedback 所有属性和方法</li>
<li>activeOpacity： 指定封装的视图在触摸操作激活时以多少不透明度显示（0-1，默认 0.25）</li>
<li>style：设置控件的风格演示，参考 View 组件的 style</li>
<li><p>underlayColor：有触摸操作时显示的底层颜色</p>
</li>
<li><p>onHideUnderlay：底层颜色被隐藏的时候掉用</p>
</li>
<li>onShowUnderlay： 底层颜色被显示的时候调用</li>
</ul>
</li>
</ol>
<p><strong>例子 activeOpacity</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableHighlight</span><br><span class="line">        activeOpacity=&#123;0.5&#125;</span><br><span class="line">        onPress=&#123;()=&gt;&#123;&#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">            &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableHighlight&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_<br><img src="/2018/12/20/react-native之Touchable介绍与使用/gif8.gif" alt="underlayColor"><br><strong>例子 underlayColor</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableHighlight</span><br><span class="line">        underlayColor=&apos;red&apos;</span><br><span class="line">        onPress=&#123;()=&gt;&#123;&#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableHighlight&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_</p>
<p><img src="/2018/12/20/react-native之Touchable介绍与使用/gif9.gif" alt="underlayColor"><br><strong>例子 onHideUnderlay 和 onShowUnderlay</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableHighlight</span><br><span class="line">        activeOpacity=&#123;0.5&#125;</span><br><span class="line">        underlayColor=&apos;red&apos;</span><br><span class="line">        onPress=&#123;()=&gt;&#123;&#125;&#125;</span><br><span class="line">        onHideUnderlay=&#123;()=&gt;alert(&apos;HideUnderlay&apos;)&#125;</span><br><span class="line">        onShowUnderlay=&#123;()=&gt;alert(&apos;ShowUnderlay&apos;)&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;styles.view&#125;&gt;</span><br><span class="line">            &lt;Text style=&#123;styles.text&#125;&gt; TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableHighlight&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_</p>
<p><img src="/2018/12/20/react-native之Touchable介绍与使用/gif10.gif" alt="underlayColor"></p>
<ol>
<li><p>TouchableOpacity<br>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。<br>不透明度的变化是通过把子元素封装在一个 Animated.View 中实现的，这个动画会被添加到视图层， 可能影响到布局</p>
<pre><code>*属性和方法*
- 继承TouchableWithoutFeedback所有属性和方法
- activeOpacity：指定封装的视图在触摸操作激活时以多少不透明度显示（0-1，默认0.2）,用法同TouchableHighlight
- style：设置控件的风格演示，参考View组件的style
- setOpacityTo：将本组件的不透明设为指定值（动画） setOpacityTo((value:number),(duration:number))
</code></pre><p><strong>例子 setOpacityTo</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">    &lt;TouchableOpacity</span><br><span class="line">        ref=&apos;opacity&apos;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;View style=&#123;[styles.touchable,styles.viewBox]&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.test&#125;&gt;TEST&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    &lt;/TouchableOpacity&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        style=&#123;&#123;marginTop:20&#125;&#125;</span><br><span class="line">        title=&apos;测试opacity&apos;</span><br><span class="line">        //组件方法调用</span><br><span class="line">        onPress=&#123;()=&gt;&#123;this.refs.opacity.setOpacityTo(0.1,1)&#125;&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>
<p>_效果_</p>
<p><img src="/2018/12/20/react-native之Touchable介绍与使用/gif11.gif" alt="setOpacityTo"></p>
<ol>
<li><p>TouchableNativeFeedback<br> 在 Android 设备上，利用元素状态来渲染触摸效果。<br> 目前只支持一个单独的 View 实例作为子节点。在底层实现上，实际会创建一个新的 RCTView 节点替换当前的子 View，并附带一些额外的属性。<br>原生触摸操作反馈的背景可以使用 backgroun 属性来定义</p>
<p><em>属性和方法</em></p>
<ul>
<li>继承 TouchableWithoutFeedback 所有属性和方法</li>
<li>background：在触摸反馈的时候  显示的背景。值是 type 属性或是一些基于 type 熟悉的额外数据对象。推荐使用本组件的静态方法创建这个对 象。</li>
<li>SelectableBackground()：静态方法，会创建一个对象，表示安卓主题默认的对于被选中对象的背景</li>
<li>SelectableBackgroundBorderless():会创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景(android:attr/selectableItemBackgroundBorderless)。只适用于 Android API level 21+</li>
<li>Ripple()：静态方法， 会创建一个对象，当按钮被按下时  产生  水波纹背景，可以通过 color 指定颜色。参数：color 和 borderless，如果 borderless 为 true，涟漪还会渲染到视图范围外。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>react-native从入门到放弃</title>
    <url>/2018/12/15/react-native%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>react native 实在太多坑，<br>项目跑起来就废了很大劲<br>全部按照<a href="https://reactnative.cn/docs/getting-started/" target="_blank" rel="noopener">中文网</a>的步骤配置 mac 的 Android 和 IOS</p>
<p>开始记录一下遇到的问题吧</p>
<a id="more"></a>
<p>转入 IOS<br>0.50 以上版本按照官网配置无法运行，<br>退回 0.44.3 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native init MyApp --version 0.44.3</span><br></pre></td></tr></table></figure>
<p>需要关闭安卓模拟器，或者重启几次，再执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure>
<h4 id="1、Error-watching-file-for-changes-EMFILE-及-brew-link-autoconf-automake"><a href="#1、Error-watching-file-for-changes-EMFILE-及-brew-link-autoconf-automake" class="headerlink" title="1、Error watching file for changes: EMFILE 及`brew link autoconf automake"></a>1、Error watching file for changes: EMFILE 及`brew link autoconf automake</h4><p>解决方法</p>
<ul>
<li><p>卸载原来安装的 watchman:brew uninstall –force watchman</p>
</li>
<li><p>删除原来的安装文件:rm -rf /usr/local/var/run/watchman/</p>
</li>
<li><p>重新安装 watchman:brew install watchman</p>
</li>
</ul>
<h4 id="2、报错-No-bundle-URL-present，报错信息要看运行时弹出的窗口"><a href="#2、报错-No-bundle-URL-present，报错信息要看运行时弹出的窗口" class="headerlink" title="2、报错 No bundle URL present，报错信息要看运行时弹出的窗口"></a>2、报错 No bundle URL present，报错信息要看运行时弹出的窗口</h4><p>解决方法：删除 ios/build 文件夹，重新运行</p>
<h4 id="3、Android，不启动-android-studio-直接运行模拟器"><a href="#3、Android，不启动-android-studio-直接运行模拟器" class="headerlink" title="3、Android，不启动 android studio,直接运行模拟器"></a>3、Android，不启动 android studio,直接运行模拟器</h4><p>执行 emulator -avd First(创建的模拟器的名字),<br>报错：PANIC: Missing emulator engine program for ‘x86’ CPU.</p>
<p>解决方法：直接打开一个终端，<br>cd ~进入电脑根路径<br>open Library 打开文件夹 Library<br>找到 Android/sdk，将 emulator 文件夹的东西复制粘贴到 tools。<br><strong>注意</strong></p>
<ul>
<li>试了一下，貌似每次重新执行都要这么操作一下，嫌麻烦的可以通过 android studio 打开模拟器</li>
<li>如果想要恢复，可以先保存一份 tools 里面的文件，压缩一下就可以</li>
</ul>
<h4 id="4、模拟器内调用开发者菜单"><a href="#4、模拟器内调用开发者菜单" class="headerlink" title="4、模拟器内调用开发者菜单"></a>4、模拟器内调用开发者菜单</h4><p>IOS：command+D<br>Android：command+M</p>
<p>Enable Live Debugging 自动刷新</p>
<h4 id="5、IOS-模拟器选中输入框不弹出键盘"><a href="#5、IOS-模拟器选中输入框不弹出键盘" class="headerlink" title="5、IOS 模拟器选中输入框不弹出键盘"></a>5、IOS 模拟器选中输入框不弹出键盘</h4><p> 解决方法： 1.选中模拟器，屏幕上的菜单 Hardware-》keyboard-》Connect Hardware keyBoard 取消选中</p>
<p><img src="/2018/12/15/react-native从入门到放弃/img1.jpg" title="ios-keyboard/"></p>
<pre><code>但是取消选中之后，电脑键盘快捷键调用开发者模式失效
2.第二中，不取消选中第二个选项Connect Hardware keyBoard，每次需要调用菜单的时候选上图第三个操作，或快捷键 commond+K
</code></pre><h3 id="6、IOS-配置-APP-的图标、启动页面-、修改名字"><a href="#6、IOS-配置-APP-的图标、启动页面-、修改名字" class="headerlink" title="6、IOS 配置 APP 的图标、启动页面 、修改名字"></a>6、IOS 配置 APP 的图标、启动页面 、修改名字</h3><ul>
<li><p>使用 Xcode 打开 ios 工程</p>
</li>
<li><p>将图片和启动页面放置到工程目录下 ios/新建的项目名称/Images.xcassets</p>
</li>
</ul>
<p><img src="/2018/12/15/react-native从入门到放弃/img2.jpg" alt="放置APP的图标和启动页面"></p>
<ul>
<li><p>设置<br><img src="/2018/12/15/react-native从入门到放弃/img3.jpg" alt="配置APP的图标和启动页面"></p>
</li>
<li><p>修改 App 名字<br>ios/新建的项目名称/info.plist<br><img src="/2018/12/15/react-native从入门到放弃/img4.jpg" alt="配置APP的名字"></p>
</li>
</ul>
<h3 id="7、Android-配置-APP-的图标、修改名字"><a href="#7、Android-配置-APP-的图标、修改名字" class="headerlink" title="7、Android 配置 APP 的图标、修改名字"></a>7、Android 配置 APP 的图标、修改名字</h3><ul>
<li>使用 Android studio 打开 android 工程</li>
<li>android/app/src/res/values/strings.xml<br><img src="/2018/12/15/react-native从入门到放弃/img5.jpg" alt="配置APP的名字"></li>
<li>将图标文件夹放入工程目录<br>drawable 放入 android/app/src/res<br>在 app/src/main/AndroidManifest.xml 中修改 android:icon 的值，替换为放入的 icon<br><img src="/2018/12/15/react-native从入门到放弃/img6.jpg" alt="配置APP的图标和启动页面"></li>
</ul>
<h3 id="8、添加-Mobx-状态管理"><a href="#8、添加-Mobx-状态管理" class="headerlink" title="8、添加 Mobx 状态管理"></a>8、添加 Mobx 状态管理</h3><ul>
<li>下载 mobx 插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i mobx mobx-react --save</span><br></pre></td></tr></table></figure>
<ul>
<li>配置装饰器插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  //bable 7.0</span><br><span class="line">yarn add  @babel/plugin-proposal-decorators --save-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>.babelrc 增加配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel/plugin-proposal-decorators&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;legacy&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>android 报错 can’t find varivable:Symbol<br>原因是因为 mobx 的版本用的最新版本..用到了 Symbol 部分 es6 的 api 特性.<br>把 mobx 降版本到 4.3.1 . mobx-react 降版本到 5.1.0 即可.</p>
</li>
<li><p>android 键盘把底部导航栏顶起<br>解决：android/app/src/AndroidManifest.xml<br>改变配置：android:windowSoftInputMode=”stateAlwaysHidden|adjustPan”&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>Git-学习</title>
    <url>/2018/12/13/Git-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近在极客时间购买了一份视频，学习 git，github，gitlab。<br>虽然用过 git 和 github，还是系统学习一下，毕竟是必备开发工具</p>
<a id="more"></a>
<h1 id="常用-Git-命令"><a href="#常用-Git-命令" class="headerlink" title="常用 Git 命令"></a>常用 Git 命令</h1><p><img src="/2018/12/13/Git-学习/git命令.png" alt="常用命令"></p>
<h2 id="git-基本命令"><a href="#git-基本命令" class="headerlink" title="git 基本命令"></a>git 基本命令</h2><p><strong>基本配置</strong></p>
<ul>
<li>全局配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config -global user.name &apos;&apos;</span><br><span class="line">git config -global user.email &apos;&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>本地配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config -local user.name &apos;&apos;</span><br><span class="line">git config -local user.email &apos;&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list [--local|--global]</span><br></pre></td></tr></table></figure>
<p><strong>初始化仓库</strong></p>
<ul>
<li>已存本地项目，在根路径下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化空仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init 仓库名</span><br></pre></td></tr></table></figure>
<p><strong>将  有变动的添加到暂存区</strong></p>
<ul>
<li>单个文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add 文件名/文件夹名</span><br></pre></td></tr></table></figure>
<ul>
<li>所有有变动文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure>
<p><strong>将变更提交</strong></p>
<ul>
<li>提交暂存区变更</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;变更信息&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>未存入暂存区，直接提交</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;变更信息&quot;</span><br></pre></td></tr></table></figure>
<p><strong>查看仓库状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><strong> 已提交文件重命名的简便方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv readme readme.md</span><br></pre></td></tr></table></figure>
<p><strong>日志</strong></p>
<ul>
<li>当前分支版本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<ul>
<li>查看简洁版本历史信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>
<ul>
<li>查看最近几次提交版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -n (最近n次)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有分支版本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --all</span><br></pre></td></tr></table></figure>
<ul>
<li>查看图形化版本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>
<ul>
<li>多个命令组合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//所有分支，最近三次提交，图形化信息</span><br><span class="line">git log --all -3 --graph</span><br></pre></td></tr></table></figure>
<p><strong>分支</strong></p>
<ul>
<li>查看当前分支信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有分支  名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有分支信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure>
<ul>
<li>基于原来的分支创建新分支并切换到该分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;新分支名&gt; &lt;旧分支名/commit Hash&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li> 切换分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>强制删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Git 对象</strong><br>commit -&gt; tree(文件夹）-&gt;blob（具体文件）</p>
<ul>
<li>查看 git 里面的对象的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cat-file -p &lt;文件hash&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看 git 对象的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cat-file -t &lt;文件hash&gt;</span><br></pre></td></tr></table></figure>
<p><strong> 图形化查看 git 版本</strong></p>
<ul>
<li>当前分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitk all</span><br></pre></td></tr></table></figure>
<p><strong>分离头指针</strong></p>
<ul>
<li>新提交的 commit 没有挂在任何分支上，会直接被 git 丢弃</li>
<li>建立新的分支保存分离头指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;新分支名字&gt; &lt;commit的hash&gt;</span><br></pre></td></tr></table></figure>
<p><strong>差异</strong></p>
<ul>
<li>比较暂存和工作区的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<ul>
<li>两个 commit 的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff commit1 commit2</span><br></pre></td></tr></table></figure>
<ul>
<li>不同分支的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff branch1 branch2</span><br></pre></td></tr></table></figure>
<ul>
<li>不同分支/commit 的指定文件的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff branch1/commit  branch2/commit -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前 HEAD(最近提交的 commit)和父级 commit 的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff HEAD HEAD^</span><br></pre></td></tr></table></figure>
<ul>
<li>当前 HEAD 和父级的父级 commit 比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff HEAD HEAD^^/HEAD~2</span><br></pre></td></tr></table></figure>
<ul>
<li>比较暂存和当前 HEAD 的差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<p><strong>修改最近提交的一次 commit 的 message</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p><strong>修改老旧 commit 的 message</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//交互式</span><br><span class="line">git rebase -i &lt;父级commit的hash&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据提示信息选择不同命令 ，除了命令不修改其他信息。</li>
<li><p>然后保存退出，弹出新的交互窗口，改变 commit 的 message<br> 1.pick：仅使用该 commit<br>2.reword：修改 commit 的 message 信息<br>3.edit：修改 commit<br>4.squash：合并 commit</p>
</li>
<li><p>将几个连续的 commit 合并到一个 commit 上<br><img src="/2018/12/13/Git-学习/img1.jpg" alt="要合并的commit"><br><img src="/2018/12/13/Git-学习/img2.jpg" alt="修改合并后的meaasge"></p>
</li>
<li><p>将几个不连续的 commit 合并到一个 commit 上<br>顶级 commit 无父级 commit，就 rebase 当前 commit,并将 commit 添加到<br><img src="/2018/12/13/Git-学习/img3.jpg" alt="顶级commit"><br><img src="/2018/12/13/Git-学习/img4.jpg" alt="要合并的commit放到一起"><br><img src="/2018/12/13/Git-学习/img5.jpg" alt="提示信息执行--continue"><br><img src="/2018/12/13/Git-学习/img6.jpg" alt="修改合并后的message756"></p>
</li>
</ul>
<p><strong>恢复</strong></p>
<ul>
<li>将暂存区的文件全部恢复成当前 HEAD(删除暂存区所有文件)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD  //此时执行git diff --cached不返回任何内容</span><br></pre></td></tr></table></figure>
<ul>
<li>将暂存区和工作区恢复成 HEAD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD //暂存区被清空</span><br></pre></td></tr></table></figure>
<ul>
<li>将暂存区某个或几个的文件恢复当前 HEAD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gut reset HEAD -- &lt;file1&gt; &lt;file2&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>将暂存区和工作区恢复成某个历史状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p><strong>删除文件</strong></p>
<ul>
<li>删除文件并保存状态到暂存区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><strong>开发时加塞紧急任务</strong></p>
<ul>
<li>存入 stash，不存入暂存区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash list //查看所有的stash</span><br></pre></td></tr></table></figure>
<ul>
<li>恢复最近的 stash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply //不会删除stash的记录</span><br><span class="line">git stash  pop //删除stash的记录</span><br></pre></td></tr></table></figure>
<ul>
<li>恢复某个 stash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;2&#125;//默认是git stash apply stash@&#123;0&#125;</span><br><span class="line">git stash pop stash@&#123;2&#125;//默认是git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.gitignore<br>忽略不需要提交的文件<br>github 新建项目时，可以根据不同语言的项目匹配不同的.gitignore 文件<br><img src="/2018/12/13/Git-学习/img7.jpg" alt="gi
thub"></li>
</ul>
<ol>
<li>doc 忽略所有名字为 doc 文件和文件夹</li>
<li>doc/ 忽略名字为 doc 的文件夹，不忽略文件</li>
<li>doc<br>!doc/ 忽略名字为 doc 的文件， 不忽略文件夹</li>
<li><p>忽略已经提交的文件<br>把要忽略的文件名  添加到.gitignore,<br>删掉仓库里要忽略的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -- cached &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>git 备份</strong></p>
<ol>
<li>四种传输协议<ul>
<li>哑协议：/path/to/repo.git (传输进度不可见)</li>
<li>智能协议：file:///path/to/repo.git（传输进度可见，比哑协议快)</li>
<li>http/https 协议：<a href="http://git-server.com:port/path/to/repo.git" target="_blank" rel="noopener">http://git-server.com:port/path/to/repo.git</a><br><a href="https://git-server.com:port/path/to/repo.git" target="_blank" rel="noopener">https://git-server.com:port/path/to/repo.git</a></li>
<li>ssh 协议：<a href="mailto:user@git-server.com" target="_blank" rel="noopener">user@git-server.com</a>:path/to/repo.git</li>
</ul>
</li>
<li>从远端仓库克隆项目到本地</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --bare &lt;server-path&gt; &lt;local-name&gt; //--bare仅克隆git，不带工作区的仓库</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img8.jpg" alt="克隆仓库"></p>
<ol start="3">
<li><p>将本地项目同步到远端仓库</p>
<ul>
<li>查看有无远端仓库连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<ul>
<li>建立与远端的联系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote  add  &lt;server-file-name&gt;  &lt;server-path&gt; //用名字指代地址</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img9.jpg" alt="建立与仓库的连接"><br>删除已存在的 remote</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>提交变更</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push &lt;server-file-name&gt;</span><br><span class="line">//当前分支没有与远程分支关联</span><br><span class="line">git push --set-upstream &lt;server-file-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img010.jpg" alt="提交变更"></p>
</li>
</ol>
<ul>
<li><p>获取远端的其他人提交的变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch &lt;server-file-name&gt;</span><br><span class="line">//&lt;server-file-name&gt;给定拉取哪个远端的数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;/hash</span><br></pre></td></tr></table></figure>
</li>
<li><p>从远端拉去代码并合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交代码非 fast forward,变基操作<br>在 master 新建分支上要提交的多个 commit</p>
<ul>
<li>切换到需要变基的分支：git rebase origin/master<br>变基为 master 分支</li>
<li>提示冲突，根据提示文件解决冲突</li>
<li>变更文件加入暂存区 git add .</li>
<li>git rebase –continue</li>
<li>提示冲突，根据提示文件解决冲突</li>
<li>。。。</li>
<li>git push origin Shanghai //非 fast forword</li>
<li>git push -f origin Shanghai</li>
<li>继续执行 pull request</li>
</ul>
</li>
<li><p>rebse 多次解决冲突，其他的解决办法</p>
<ul>
<li>解决一次冲突，记录冲突</li>
<li>配置项 git config –global rerere.enabled true</li>
<li>将要提交的分支和 master 分支 merge 一下</li>
<li>解决冲突，然后 git add，记录一下</li>
<li>再将分支退回到前一个 commit， git reset –hard HEAD~1</li>
<li>git rebase origin/master</li>
<li>git rebase –continue</li>
<li>虽然提示冲突，但是已经解决好了</li>
<li>将解决完冲突的文件放入暂存区 git add .</li>
<li>git rebase –continue</li>
<li>。。。。</li>
<li>git push -f origin Shanghai</li>
</ul>
</li>
</ul>
<p><strong>将本地仓库同步到 Github</strong></p>
<ul>
<li>注册 Github</li>
<li>新建仓库</li>
<li>建立本地仓库与远端的联系，git remote</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add github https://github.com/Dorisfeng/git_learning.git</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img11.jpg" alt="建立联系"></p>
<hr>
<p>采用 ssh（<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Dorisfeng/git_learning.git）建立连接，push 时报错:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong><br>就是本地的 ssh 失效</p>
<ul>
<li>根目录 :cd ~</li>
<li>打开.ssh: open .ssh(没有就新建)</li>
<li>将三个文件备份删除</li>
<li>新建 ssh：ssh-keygen -t rsa -C “<a href="mailto:871609506@qq.com" target="_blank" rel="noopener">871609506@qq.com</a>“</li>
<li>在 github 设置里面新建 ssh,将 id_rsa.pub 里面的内容复制粘贴到 key 里面</li>
<li>测试连接是否成功：ssh -T -v <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></li>
</ul>
<blockquote>
<p>Hi Dorisfeng! You’ve successfully authenticated, but GitHub does not provide shell access.<br>表示连接成功</p>
</blockquote>
<hr>
<ul>
<li><p>提交，git push</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push github --all</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img12.jpg" alt="push"></p>
<blockquote>
<p>红色错误是 github 新建仓库时，在已经新建分支 master 存放了 license,本地分支 master 无法提交</p>
</blockquote>
</li>
<li><p>拉取远端分支</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch &lt;server-name&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/13/Git-学习/img13.jpg" alt="fetch"></p>
<ul>
<li><p>将本地仓库中的 master 分支与远端分支合并 git merge</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge github1/master</span><br><span class="line">//fatal: refusing to merge unrelated histories 没有关系的树，无法合并,根据git merge -h查看参数是否可以合并无关系 的树</span><br><span class="line">git merge --allow-unrelated-histories github1/master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/12/13/Git-学习/img14.jpg" alt="merge"></p>
<ul>
<li><p>提交 master 分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push github1 master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/12/13/Git-学习/img15.jpg" alt="push"></p>
<hr>
<h2 id="github-一个-bug，如果-github-注册邮箱和本地配置的-git-的-user-email-一-致将不会-commit-将不会显示本地配置的-user-name-而是显示-github-的头像和名字"><a href="#github-一个-bug，如果-github-注册邮箱和本地配置的-git-的-user-email-一-致将不会-commit-将不会显示本地配置的-user-name-而是显示-github-的头像和名字" class="headerlink" title="github 一个 bug，如果 github 注册邮箱和本地配置的 git 的 user.email 一  致将不会 commit 将不会显示本地配置的 user.name,而是显示 github 的头像和名字"></a>github 一个 bug，如果 github 注册邮箱和本地配置的 git 的 user.email 一  致将不会 commit 将不会显示本地配置的 user.name,而是显示 github 的头像和名字</h2><ul>
<li><p>同时修改了同一文件的不同内容<br> 直接使用 git pull 拉取并自动合并冲突，git 会自动保留两部分修改内容</p>
</li>
<li><p>同时修改了同一文件名<br>使用 git pull 拉取,git 会同时保留两个文件，并且两个文件完全相同，diff 不出内容。<br>使用 git status 的提示，通过同事间沟通保留文件名字<br><img src="/2018/12/13/Git-学习/img16.jpg" alt="同时修改文件名1"><br><img src="/2018/12/13/Git-学习/img17.jpg" alt="同时修改文件名2"></p>
</li>
</ul>
<h2 id="mac-终端命令"><a href="#mac-终端命令" class="headerlink" title="mac 终端命令"></a>mac 终端命令</h2><p><strong>清空屏幕</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>
<p><strong>当前文件路径</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p><strong>拷贝文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 文件相对路径 存放的相对路径</span><br></pre></td></tr></table></figure>
<p><strong>*改变当前目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd dirname进入下一层一路径</span><br><span class="line">cd .. 返回上一层</span><br><span class="line">cd  ~ 返回根路径</span><br></pre></td></tr></table></figure>
<p><strong>拷贝文件夹</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r &lt;文件夹相对路径&gt; &lt;存放的相对路径&gt;</span><br></pre></td></tr></table></figure>
<p><strong>创建文件夹</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir name</span><br></pre></td></tr></table></figure>
<p><strong>删除文件夹</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmkdir name</span><br></pre></td></tr></table></figure>
<p><strong>移动或重命名一个目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvdir dir1 dir2</span><br></pre></td></tr></table></figure>
<p><strong>在命令行里打开当前文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi name</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑使用 vi 打开的文件 ，输入 i-变成可编辑状态</li>
<li>vi 编辑状态回到命令行：按 esc 取消编辑 然后</li>
<li>:w 保存文件但不退出 vi</li>
<li>:w file 将修改另外保存到 file 中，不退出 vi</li>
<li>:w! 强制保存，不推出 vi</li>
<li>:wq 保存文件并退出 vi</li>
<li>:wq! 强制保存文件，并退出 vi</li>
<li>q: 不保存文件，退出 vi</li>
<li>:q! 不保存文件，强制退出 vi</li>
<li>:e! 放弃所有修改，从上次保存文件开始再编辑<br><strong>显示当前目录内容</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure>
<p><strong>改变文件名或移动文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv name1 name2 //将name1重命名为name2</span><br><span class="line">mv dir1  dir2 //将路经dir1下的文件移动到dir2下</span><br></pre></td></tr></table></figure>
<p><strong>创建文件和内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;hello world&apos; &gt;readme</span><br></pre></td></tr></table></figure>
<p><strong>查看.git/objects 文件夹里面的类型为文件的文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .git/objects -type f/file</span><br></pre></td></tr></table></figure>
<p><strong>将普通文件内容打印到屏幕上</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat+文件名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之TextInput</title>
    <url>/2018/12/12/react-native%E4%B9%8BTextInput/</url>
    <content><![CDATA[<p>TextInput 输入框，受控组件<br>继承自 View</p>
<a id="more"></a>
<h4 id="基本输入框-placeholder"><a href="#基本输入框-placeholder" class="headerlink" title="基本输入框 placeholder"></a>基本输入框 placeholder</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&apos;searching&apos; style=&#123;styles.textInput&#125; /&gt;</span><br><span class="line">xc</span><br><span class="line">//样式</span><br><span class="line">textInput:&#123;</span><br><span class="line">width:Dimensions.get(&apos;window&apos;).width;,</span><br><span class="line">height:40,</span><br><span class="line">marginTop:30,</span><br><span class="line">backgroundColor:&apos;#ddd&apos;,</span><br><span class="line">fontSize:16</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>效果展示</em><br><img src="/2018/12/12/react-native之TextInput/gif1.gif" title="placeholder"></p>
<h4 id="value-属性"><a href="#value-属性" class="headerlink" title="value 属性"></a>value 属性</h4><p>TextInput 是受控组件，设置 value 属性，如果不配合 onChangeText，输入框无法输入或删除内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&apos;searching&apos;</span><br><span class="line">value=&apos;有本事你就删掉我&apos;</span><br><span class="line">style=&#123;styles.textInput&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><em>效果展示</em><br><img src="/2018/12/12/react-native之TextInput/gif2.gif" title="value属性/"></p>
<h4 id="keyboardType"><a href="#keyboardType" class="headerlink" title="keyboardType"></a>keyboardType</h4><p>决定弹出的键盘是什么类型的</p>
<p>_取值_</p>
<p>1、通用</p>
<ul>
<li>default ：默认</li>
<li>number-pad</li>
<li>numeric</li>
<li>decimal-pad</li>
<li>email-address</li>
<li>phone-pad</li>
</ul>
<p>2、仅 IOS 可用的  属性</p>
<ul>
<li>ascii-capable</li>
<li>numbers-and-punctuation</li>
<li>url</li>
<li>name-phone-pad</li>
<li>twitter</li>
<li>web-search</li>
</ul>
<p>3、仅 Android 可用的  属性</p>
<ul>
<li>visible-password</li>
</ul>
<p><img src="/2018/12/12/react-native之TextInput/gif3.gif" title="键盘样式/"></p>
<h4 id="multiline-多行"><a href="#multiline-多行" class="headerlink" title="multiline 多行"></a>multiline 多行</h4><p>默认 false ，<br>multiline={true}，文本框可用输入多行</p>
<p><img src="/2018/12/12/react-native之TextInput/gif4.gif" title="多行文本/"></p>
<h4 id="secureTextEntry"><a href="#secureTextEntry" class="headerlink" title="secureTextEntry"></a>secureTextEntry</h4><p>默认为 false<br>secureTextEntry={true}时会用点遮住之前的输入，密码等安全信息输入<br>IOS 环境还可以使用 password={true}<br>当 multiline={true}时，该属性不生效</p>
<p><img src="/2018/12/12/react-native之TextInput/gif5.gif" title="密码输入框/"></p>
<h4 id="placeholderTextColor"><a href="#placeholderTextColor" class="headerlink" title="placeholderTextColor"></a>placeholderTextColor</h4><p>用于设置占位符显示文字的颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&quot;password&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    placeholderTextColor=&apos;red&apos;</span><br><span class="line">    secureTextEntry=&#123;true&#125;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/img1.jpg" title="占位符颜色设置/"></p>
<h4 id="autoCapitalize"><a href="#autoCapitalize" class="headerlink" title="autoCapitalize"></a>autoCapitalize</h4><p>控制 TextInput 是不是自动将特定字符切换为大写，不支持键盘 name-phone-pad<br><strong>取值</strong></p>
<ul>
<li>characters：所有字符</li>
<li>words：每个字符的第一个字母</li>
<li>sentences（默认）：每句话的第一个字母</li>
<li>none：不切换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&quot;默认&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;TextInput placeholder=&quot;characters&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    autoCapitalize=&apos;characters&apos;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;TextInput placeholder=&quot;words&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    autoCapitalize=&apos;words&apos;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;TextInput placeholder=&quot;none&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    autoCapitalize=&apos;none&apos;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/gif6.gif" title="占位符颜色设置/"></p>
<h4 id="autoFocus"><a href="#autoFocus" class="headerlink" title="autoFocus"></a>autoFocus</h4><p>autoFocus={true}输入框在 componentDidMount 自动获取焦点，默认为 false</p>
<p><img src="/2018/12/12/react-native之TextInput/gif7.gif" title="输入框自动获取焦点/"></p>
<h4 id="autoCorrect"><a href="#autoCorrect" class="headerlink" title="autoCorrect"></a>autoCorrect</h4><p>autoCorrect={false}关闭拼写自动修复，默认为 true<br>Android 好多属性不生效，下面以 IOS 系统做演示</p>
<p><img src="/2018/12/12/react-native之TextInput/gif8.gif" title="拼写自动修复/"></p>
<h4 id="clearButtonMode（IOS"><a href="#clearButtonMode（IOS" class="headerlink" title="clearButtonMode（IOS)"></a>clearButtonMode（IOS)</h4><p> 清除按钮出现时间<br>never（默认）:从不出现<br>while-editing:编辑的时候出现<br>unless-editing:不编辑的时候出现<br>always:总是出现</p>
<p><img src="/2018/12/12/react-native之TextInput/gif9.gif" title="" 清除按钮出现时间=""></p>
<h4 id="clearTextOnFocus（IOS"><a href="#clearTextOnFocus（IOS" class="headerlink" title="clearTextOnFocus（IOS)"></a>clearTextOnFocus（IOS)</h4><p>默认为 false<br>clearTextOnFocus={true}每次开始输入清除文本的内容</p>
<p><img src="/2018/12/12/react-native之TextInput/gif10.gif" title="清除文本/"></p>
<h4 id="editable（Android-IOS"><a href="#editable（Android-IOS" class="headerlink" title="editable（Android+IOS)"></a>editable（Android+IOS)</h4><p>默认为 true<br>editable={false}文本框不可以编辑</p>
<h4 id="enablesReturnKeyAutomatically（IOS）"><a href="#enablesReturnKeyAutomatically（IOS）" class="headerlink" title="enablesReturnKeyAutomatically（IOS）"></a>enablesReturnKeyAutomatically（IOS）</h4><p>默认为 false<br>enablesReturnKeyAutomatically={true}文本框中没有内容的时候禁用确认按钮</p>
<p><img src="/2018/12/12/react-native之TextInput/gif11.gif" title="禁用确认按钮/"></p>
<h4 id="returnKeyType"><a href="#returnKeyType" class="headerlink" title="returnKeyType"></a>returnKeyType</h4><p>返回键的样式</p>
<p><strong>取值</strong></p>
<p>跨平台：</p>
<ul>
<li>done</li>
<li>go</li>
<li>next</li>
<li>search</li>
<li>send<br>Android：</li>
<li>none</li>
<li>previous<br>IOS：</li>
<li>default</li>
<li>emergency</li>
<li>google</li>
<li>join</li>
<li>route</li>
<li>yahoo</li>
</ul>
<p><i>IOS 效果</i><br><img src="/2018/12/12/react-native之TextInput/gif12.gif" title="返回按钮"><br></p>
<p><i>Android 效果</i><br><img src="/2018/12/12/react-native之TextInput/gif13.gif" title="返回按钮"></p>
<h4 id="onChange"><a href="#onChange" class="headerlink" title="onChange"></a>onChange</h4><p>文本框内容发生变化时调用此函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;TextInput placeholder=&quot;默认&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    onChange=&#123;()=&gt;&#123;alert(&apos;输入框内容发生变化&apos;)&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/gif14.gif" title="onChange"><br></p>
<h4 id="onChangeText"><a href="#onChangeText" class="headerlink" title="onChangeText"></a>onChangeText</h4><p> 当文本内容发生变化时调用此函数， 改变后的文字内容会作为参数传入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&quot;默认&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    onChangeText=&#123;(text)=&gt;&#123;alert(&apos;输入内容为&apos;+text)&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/gif15.gif" title="onChangeText"><br></p>
<h4 id="onFocus-onBlur"><a href="#onFocus-onBlur" class="headerlink" title="onFocus onBlur"></a>onFocus onBlur</h4><p>onFocus：文本框获取焦点时调用此函数<br>onBlur：文本框失去焦点时调用此函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;TextInput placeholder=&quot;go&quot;</span><br><span class="line">    style=&#123;styles.textInput&#125;</span><br><span class="line">    returnKeyType=&apos;go&apos;</span><br><span class="line">    onFocus=&#123;()=&gt;&#123;alert(&apos;获取焦点&apos;)&#125;&#125;</span><br><span class="line">    onBlur=&#123;()=&gt;&#123;alert(&apos;失去焦点&apos;)&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/gif16.gif" title="" 焦点=""><br></p>
<h4 id="onEndEditing"><a href="#onEndEditing" class="headerlink" title="onEndEditing"></a>onEndEditing</h4><p>结束编辑是调用此函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;TextInput placeholder=&apos;默认&apos;</span><br><span class="line">   style=&#123;styles.textInput&#125;</span><br><span class="line">   onEndEditing=&#123;()=&gt;alert(&apos;结束编辑&apos;)&#125;</span><br><span class="line">   /&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/12/react-native之TextInput/gif17.gif" title="onEndEditing"><br></p>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之FlexBox</title>
    <url>/2018/12/12/react-native%E4%B9%8BFlexBox/</url>
    <content><![CDATA[<p>进军react-native，不知道会走到哪一步。。。。<br>搭个环境花了两天功夫，完全根据<a href="https://reactnative.cn/docs/getting-started/" target="_blank" rel="noopener">react-native中文官网</a><br>热更新研究了半天发现不支持0.57的版本，暂时搁置，手动更新吧<br><a id="more"></a></p>
<h3 id="FlexBox"><a href="#FlexBox" class="headerlink" title="FlexBox"></a>FlexBox</h3><p>与PC端的flex基本一致，弹性布局，<br>不同是，flex的 flexDirection 默认是row，而 FlexBox 默认是column<br>flexDirection 布局的主轴方向<br>    row:主轴为水平方向，起点在左端<br>    row-reverse:主轴为水平方向，起点在右端<br>    column:主轴为垂直方向，起点在上端<br>    column-reverse:主轴为垂直方向，起点在下端<br>justifyContent 子元素在主轴线的对齐方式<br>    flex-start（默认）:向主轴起点靠齐<br>    flex-end:向主轴终点靠齐<br>    space-between:两端对齐，第一个和最后一个元素在最边上，两个元素之间距离相等<br>    space-around:元素会平均分布在行内，两端距离父元素边界的距离是两个元素距离的一半<br>    center:居中<br>alignItems 元素在与主轴垂直的交叉轴上的分部<br>    flex-start：交叉轴轴的起点对齐<br>    flex-end:向交叉轴轴终点靠齐<br>    center：交叉轴的中点对齐<br>    stretch（默认):如果子元素没有设置高度或设置为 auto，将占满整个容器高度<br>flexWrap 元素在主轴上排列是否可以换行<br>    nowrap(默认)不换行，<br>    wrap:换行</p>
<p>子元素的属性flex<br>（flex-grow、flex-shrink、flex-basis三个属性的缩写，第二个参数和第三个参数是可选参数）：默认值为 “0 1 auto”<br>当前元素的flex/所有元素的flex之和是该元素在主轴上占的宽度或高度<br>如果主轴是column，设置flex后，元素的宽度失效，根据flex计算宽度，<br>如果设置了高度元素按照高度布局否则撑满父元素的高度<br><strong>例子</strong><br>初始布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class HelloWorldApp extends Component &#123;</span><br><span class="line">    </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">            &lt;View style=&#123;styles.subViewStyle1&#125;&gt;&lt;/View&gt;</span><br><span class="line">            &lt;View style=&#123;styles.subViewStyle2&#125;&gt;&lt;/View&gt;</span><br><span class="line">            &lt;View style=&#123;styles.subViewStyle3&#125;&gt;&lt;/View&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const styles=StyleSheet.create(&#123;</span><br><span class="line">    container:&#123;</span><br><span class="line">        width:Dimensions.get(&apos;window&apos;).width,</span><br><span class="line">        height:Dimensions.get(&apos;window&apos;).height,</span><br><span class="line">        backgroundColor:&apos;#ddd&apos;,</span><br><span class="line">        flexDirection:&apos;row&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    subViewStyle1:&#123;</span><br><span class="line">        backgroundColor:&apos;red&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">    &#125;,</span><br><span class="line">    subViewStyle2:&#123;</span><br><span class="line">        backgroundColor:&apos;yellow&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">    &#125;,</span><br><span class="line">    subViewStyle3:&#123;</span><br><span class="line">        backgroundColor:&apos;blue&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><em>效果</em></p>
<p><img src="/2018/12/12/react-native之FlexBox/FlexBox1.jpg" alt="图片alt" title="初始"><br>将第一个子元素的flex设为1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subViewStyle1:&#123;</span><br><span class="line">        backgroundColor:&apos;red&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">        flex:1</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>除去第二和第三个子元素所占位置，第一个元素撑满剩下的位置</p>
<p><em>效果</em></p>
<p><img src="/2018/12/12/react-native之FlexBox/FlexBox2.jpg" alt="图片alt" title="flex"></p>
<p>将第二个子元素的flex也设为1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subViewStyle2:&#123;</span><br><span class="line">        backgroundColor:&apos;red&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">        flex:1</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>元素1和元素2的宽度平分除了元素3剩下的所有宽度</p>
<p><em>效果</em></p>
<p><img src="/2018/12/12/react-native之FlexBox/FlexBox3.jpg" alt="图片alt" title="flex"></p>
<p>将第三个子元素的flex也设为1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subViewStyle3:&#123;</span><br><span class="line">        backgroundColor:&apos;red&apos;,</span><br><span class="line">        height:60,</span><br><span class="line">        width:60,</span><br><span class="line">        flex:1</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p>
<p>元素1、元素2、元素3的宽度平分所有宽度</p>
<p><em>效果</em></p>
<p><img src="/2018/12/12/react-native之FlexBox/FlexBox4.jpg" alt="图片alt" title="flex"></p>
<p>修改三个子元素flex的值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subViewStyle1:&#123;</span><br><span class="line">       backgroundColor:&apos;red&apos;,</span><br><span class="line">       height:60,</span><br><span class="line">       width:60,</span><br><span class="line">       flex:1,</span><br><span class="line">   &#125;,</span><br><span class="line">   subViewStyle2:&#123;</span><br><span class="line">       backgroundColor:&apos;yellow&apos;,</span><br><span class="line">       height:60,</span><br><span class="line">       width:60,</span><br><span class="line">       flex:2,</span><br><span class="line">   &#125;,</span><br><span class="line">   subViewStyle3:&#123;</span><br><span class="line">       backgroundColor:&apos;blue&apos;,</span><br><span class="line">       height:60,</span><br><span class="line">       width:60,</span><br><span class="line">       flex:3,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>所占宽度正好是flex的比值</p>
<p><em>效果</em></p>
<p><img src="/2018/12/12/react-native之FlexBox/FlexBox5.jpg" alt="图片alt" title="flex"></p>
<p><strong>获取当前设备屏幕宽高</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入</span><br><span class="line">import Dimensions from &apos;Dimensions&apos;</span><br><span class="line">//使用</span><br><span class="line">Dimensions.get(&apos;window&apos;).width</span><br><span class="line">Dimensions.get(&apos;window&apos;).height</span><br></pre></td></tr></table></figure>
<p>可以使用在页面布局里面，也可以使用在style里面，设置某个元素占满整个屏幕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 样式</span><br><span class="line">    const styles = StyleSheet.create(&#123;</span><br><span class="line">        container: &#123;</span><br><span class="line">            backgroundColor:&apos;blue&apos;,</span><br><span class="line">            height:Dimensions.get(&apos;window&apos;).height,</span><br><span class="line">            width:Dimensions.get(&apos;window&apos;).width,</span><br><span class="line">            flex:1</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>react-native之Image</title>
    <url>/2018/12/12/react-native%E4%B9%8BImage/</url>
    <content><![CDATA[<p>Image 标签使用</p>
<a id="more"></a>
<ul>
<li>常用属性<br>属性：source 图片源数据（远程 URL 地址或本地数据）。<br>举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;/* 加载本地图片  */&#125;</span><br><span class="line">&lt;Image</span><br><span class="line">    source=&#123;require(&apos;./img/35fd838fc8288242dc3b80635c49764d.jpg&apos;)&#125;</span><br><span class="line">    style=&#123;styles.imgStyle&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#123;/* 加载网络图片 */&#125;</span><br><span class="line">&#123;/* 网络图片必须设置大小 还要设置填充方式 cover contain stretch填充*/&#125;</span><br><span class="line">&lt;Image</span><br><span class="line">    source=&#123;&#123;uri: &apos;https://img.alicdn.com/tps/TB1OvT9NVXXXXXdaFXXXXXXXXXX-520-280.jpg&apos;&#125;&#125;</span><br><span class="line">    style=&#123;styles.imgStyle&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#123;/* base64格式 必须设置大小*/&#125;</span><br><span class="line">&lt;Image</span><br><span class="line">    style=&#123;&#123;width: 66, height: 58&#125;&#125;</span><br><span class="line">    source=&#123;&#123;uri: &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==&apos;&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> imgStyle:&#123;</span><br><span class="line">    width:100,</span><br><span class="line">    height:200,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img1.jpg" alt="图片" title="img"></p>
<p><strong>属性</strong>：resizeMode 当图片尺寸与组件的尺寸不一致时，如何调整图片大小<br><strong>属性值</strong>：<br>cover（默认）：图片等比例缩放，直到图片宽高都大于等于容器的宽高， 超出容器宽高的部分被  隐藏（减去 padding）<br>本地图片且未设置容器（Image 标签）的宽高属性，按照原图显示，否则按照容器宽高显示（减去 padding）<br>网络图片按照 Image 宽高显示</p>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img2.jpg" alt="img2"></p>
<p>contain： 图片等比例缩放,直到图片宽高都小于容器宽高<br> 可能出现图片未覆盖区域</p>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img3.jpg" alt="图片" title="img3"></p>
<p>stretch：图片根据 Image 大小进行调整，占满整个标签<br>图片可能变形</p>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img4.jpg" alt="图片"></p>
<p>repeat：重复平铺图片直到填满容器，当尺寸超过容器时，图片会保持原有尺寸缩放到容器中</p>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img5.jpg" alt="图片"></p>
<p>center：居中显示不拉伸图片</p>
<p>_效果_</p>
<p><img src="/2018/12/12/react-native之Image/img6.jpg" alt="图片" title="img6"></p>
<ul>
<li><p>常用方法<br>onLoad 加载成功完成时调用此回调函数。<br>onLoadEnd 加载结束后，不管成功还是失败，调用此回调函数。<br>onLoadStart 图片开始加载时调用<br>onLayout 图片加载或布局改变时调用。参数为{nativeEvent:{layout{x,y,width,height}}}</p>
</li>
<li><p>样式属性<br>FlexBox：支持弹性布局<br>Transforms：支持动画属性<br>backgroundColor： 背景颜色<br>borderWidth：边框宽度<br>borderColor：边框颜色（需要设定宽度后才有颜色）<br>borderRadius： 边框圆角<br>overflow：设置图片  尺寸超出容器时， 显示或隐藏（visible，hidden(默认））<br>tintColor：为所有非透明的像素设置颜色,一旦设置，该  标签  区域内所有内容均被该颜色覆盖<br>opacity：透明度<br>overlayColor：当图片有圆角时， 指定颜色填充圆角处的空白，<br>Android 在 resizeMode 是 contain 或 GIF 动画不支持圆角透明，可任以使用该属性设置圆角颜色为背景颜色</p>
</li>
</ul>
<p>填坑：使 Android 上支持 GIF 和 WebP 格式图片<br>在 android/app/build.gradle 文件中添加一下模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 如果你需要支持Android4.0(API level 14)之前的版本</span><br><span class="line">  compile &apos;com.facebook.fresco:animated-base-support:1.10.0&apos;</span><br><span class="line"></span><br><span class="line">  // 如果你需要支持GIF动图</span><br><span class="line">  compile &apos;com.facebook.fresco:animated-gif:1.10.0&apos;</span><br><span class="line"></span><br><span class="line">  // 如果你需要支持WebP格式，包括WebP动图</span><br><span class="line">  compile &apos;com.facebook.fresco:animated-webp:1.10.0&apos;</span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:1.10.0&apos;</span><br><span class="line"></span><br><span class="line">  // 如果只需要支持WebP格式而不需要动图</span><br><span class="line">  compile &apos;com.facebook.fresco:webpsupport:1.10.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title>未登录效果</title>
    <url>/2018/12/08/%E7%AE%80%E4%B9%A6%E6%9C%AA%E7%99%BB%E5%BD%95%E6%97%B6%E7%82%B9%E5%87%BB%E5%86%99%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>来源：简书项目<br>效果：未登录弹出 warning,并且在几秒后后路由重新跳转</p>
<a id="more"></a>
<p>这个项目使用的 styled-component，使用 js 编写 css 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.props.loginStatus?&lt;WriteWrapper&gt;&lt;WriteWrapper&gt;:&lt;Alter ref=&#123;(alter)=&gt;this.alter=alter&#125;&gt;继续登录前请登录或注册.&lt;/Alter&gt;</span><br></pre></td></tr></table></figure>
<p>loginStatus 表示登录状态，<br>登录时显示写文章组件 WriteWrapper<br>未登录时显示弹框组件<alter><br>Alter 采用固定定位，类似 js 里面的 alter</alter></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const Alter=styled.div`</span><br><span class="line">  position:fixed;</span><br><span class="line">    top:10px;</span><br><span class="line">    left:50%;</span><br><span class="line">    transform:translateX(-50%);</span><br><span class="line">    padding:8px 28px;</span><br><span class="line">    border:2px solid #ec7259;</span><br><span class="line">    border-radius:5px;</span><br><span class="line">    background:#fff;</span><br><span class="line">    box-shadow:1px 0 3px 0px #fff;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>最重要的是采用 ref 来标记元素，相当于 js 里面的 document.getElementById,元素挂载后可以将元素放到 this 里面，就可以随时修改元素属性</p>
<p>在页面挂载后，如果未登录就启动定时器，并且设置  固定时间后弹窗隐藏，路由跳转<br> 记得组件销毁时，清除定时器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">     if(!this.props.loginStatus)</span><br><span class="line">     this.timerID=setTimeout(()=&gt;&#123;this.alter.style.display=&apos;none&apos;;window.location.href=&apos;/login&apos;;&#125;,1500)</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnMount() &#123;</span><br><span class="line">    clearInterval(this.timerID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>小效果</tag>
      </tags>
  </entry>
  <entry>
    <title>图片拖动组件</title>
    <url>/2018/12/07/%E5%9B%BE%E7%89%87%E6%8B%96%E5%8A%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>来源：用房管理系统<br>作用：大图片小窗口查看时可以用左右上下拖动<br>框架：react<br>UI 库：ant design</p>
<a id="more"></a>
<p>客户需要展示楼层图，但是楼层图的大小不一，为了页面布局，展示时是适应的宽高，图片是变形的，且太小。<br>本来寻找了一个放大镜插件，向淘宝的图片展示一样的。</p>
<p><strong>组件</strong></p>
<p><a href="https://github.com/ethanselzer/react-image-magnify" target="_blank" rel="noopener">react-image-magnify</a></p>
<p><strong>使用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ReactImageMagnify from &apos;react-image-magnify&apos;;</span><br><span class="line"></span><br><span class="line">&lt;ReactImageMagnify &#123;...&#123;</span><br><span class="line">    smallImage: &#123;</span><br><span class="line">        alt: &apos;Wristwatch by Ted Baker London&apos;,</span><br><span class="line">        isFluidWidth: true,</span><br><span class="line">        src: watchImg300</span><br><span class="line">    &#125;,</span><br><span class="line">    largeImage: &#123;</span><br><span class="line">        src: watchImg1200,</span><br><span class="line">        width: 1200,</span><br><span class="line">        height: 1800</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>优点：效果很好，交互性好<br>缺点：smallImage 宽高必须写死，或者 isFluidWidth: true,展示的效果其实都不太好。<br>具体可看开源项目</p>
<p>调好大图小图的宽高，展示效果还好，结果客户不满意，还是要弹框展示楼层原图，并且要拖动图片查看。<br>然后我百度到一堆原生 js 的方法，根据坐标的变化，改变图的位置的方法，写成了一个 react 的组件。<br>组件直接用的 antd 的 modal 弹框<br>该组件也用到了原生的方法获取元素设置位置，这个是我作为菜鸟想到的唯一方法</p>
<h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">    id=&apos;img&apos;</span><br><span class="line">    style=&#123;&#123;cursor:&apos;pointer&apos;,position:&apos;absolute&apos;&#125;&#125; src=&#123;img&#125;</span><br><span class="line">    onMouseDown=&#123;this.handlerMouseDown&#125;</span><br><span class="line">    onMouseUp=&#123;this.handlerMouseUp&#125;</span><br><span class="line">    onMouseMove=&#123;this.handlerMouseMove&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p> 主要为图片绑定了三个事件，<br>onMouseDown：按下鼠标<br>onMouseUp：松开按住鼠标<br>onMouseMove：按住并移动鼠标</p>
<blockquote>
<p>字面意思构够详细了吧</p>
</blockquote>
<p><strong>鼠标按下时的方法</strong></p>
<p>offsetLeft：是当前元素左边框相对于 body 的偏移量，<br>clientLeft:clientleft=offsetleft-该对象的 border 值。</p>
<p>目前没弄太懂这俩的区别，看了好多介绍文章， 可能空间想象能力不太好，还是没看懂。</p>
<p>按照上面的额  概念，如果元素没有 border 两个是相等的，但是这里使用 client， 每次  选中图片 ，图片不会在上次移动后的位置基础上移动，而是复原到初始状态再移动。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlerMouseDown=(e)=&gt;&#123;</span><br><span class="line">      this.setState(&#123;mouseDownFlag:true, mouseDownX:e.pageX,mouseDownY:e.pageY &#125;)</span><br><span class="line">      //1、状态值变为true，表示图片可以拖动了</span><br><span class="line">      //2、记录当前鼠标按下的相对页面的位置</span><br><span class="line">      const img=document.getElementById(&apos;img&apos;)</span><br><span class="line">      const initX=img.offsetLeft;</span><br><span class="line">      const initY=img.offsetTop;</span><br><span class="line">      this.setState(&#123;initX,initY&#125;)</span><br><span class="line">      //3、记录图片当前相对body的位置</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>松开按住鼠标的  方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlerMouseUp=()=&gt;&#123;</span><br><span class="line">      this.setState(&#123;mouseDownFlag:false&#125;)</span><br><span class="line">     //2、鼠标松开。状态值变为false，表示图片不再拖动了</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>鼠标移动时的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlerMouseMove=(e)=&gt;&#123;</span><br><span class="line">    e.preventDefault &amp;&amp; e.preventDefault();</span><br><span class="line">    //去掉鼠标的默认拖动事件</span><br><span class="line">    const img=document.getElementById(&apos;img&apos;)</span><br><span class="line">    const &#123; mouseDownX, mouseDownY,initX,initY,width,height&#125;=this.state</span><br><span class="line">    //鼠标拖动后的相对页面的位置</span><br><span class="line">    const moveX=e.pageX;</span><br><span class="line">    const moveY=e.pageY;</span><br><span class="line"></span><br><span class="line">    if(this.state.mouseDownFlag)&#123;</span><br><span class="line">        //计算鼠标移动了的距离+图片原来相对body的位置</span><br><span class="line">        let left=parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">        let top=parseInt(moveY)-parseInt(mouseDownY)+parseInt(initY)</span><br><span class="line">        //这里的限制是为了避免图片被完全移开，页面出现过多的空白。保证整个弹框里面展示的都是部分图片</span><br><span class="line">        left=left&gt;0?0:</span><br><span class="line">            left&lt;900-width?900-width</span><br><span class="line">            :parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">            +&apos;px&apos;</span><br><span class="line">        top=top &gt;0?0:</span><br><span class="line">        top&lt;650-height?650-height:top</span><br><span class="line">        +&apos;px&apos;</span><br><span class="line">        img.style.left=left;</span><br><span class="line">        img.style.top=top</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是整个组件的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React ,&#123; Component &#125; from &apos;react&apos;</span><br><span class="line">import &#123; Modal &#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Index extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            width:0,</span><br><span class="line">            height:0,</span><br><span class="line">            show:false,</span><br><span class="line">            mouseDownFlag:false,</span><br><span class="line">            mouseDownX:null,</span><br><span class="line">            mouseDownY:null,</span><br><span class="line">            initX:null,</span><br><span class="line">            initY:null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUpdate(props)&#123;</span><br><span class="line">        const img=new Image();</span><br><span class="line">        img.src=props.img</span><br><span class="line">        img.onload=()=&gt;&#123;</span><br><span class="line">            let width=img.width;</span><br><span class="line">            let height=img.height;</span><br><span class="line">            this.setState(&#123;height,width&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handlerMouseUp=()=&gt;&#123;</span><br><span class="line">        this.setState(&#123;mouseDownFlag:false&#125;,()=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    handlerMouseDown=(e)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;mouseDownFlag:true, mouseDownX:e.pageX,mouseDownY:e.pageY &#125;)</span><br><span class="line">        const img=document.getElementById(&apos;img&apos;)</span><br><span class="line">        const initX=img.offsetLeft;</span><br><span class="line">        const initY=img.offsetTop;</span><br><span class="line">        // const initX=img.clientLeft;</span><br><span class="line">        // const initY=img.clientTop;</span><br><span class="line">        this.setState(&#123;initX,initY&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    handlerMouseMove=(e)=&gt;&#123;</span><br><span class="line">         e.preventDefault &amp;&amp; e.preventDefault();</span><br><span class="line"></span><br><span class="line">        const img=document.getElementById(&apos;img&apos;)</span><br><span class="line">        const &#123; mouseDownX, mouseDownY,initX,initY,width,height&#125;=this.state</span><br><span class="line">        const moveX=e.pageX;</span><br><span class="line">        const moveY=e.pageY;</span><br><span class="line">        console.log(1,initX,initY)</span><br><span class="line">        console.log(2,mouseDownX,mouseDownY)</span><br><span class="line">        console.log(3,moveX,moveY)</span><br><span class="line"></span><br><span class="line">       if(this.state.mouseDownFlag)&#123;</span><br><span class="line">           let left=parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">           let top=parseInt(moveY)-parseInt(mouseDownY)+parseInt(initY)</span><br><span class="line">            left=left&gt;0?0:</span><br><span class="line">                left&lt;900-width?900-width</span><br><span class="line">                :parseInt(moveX)-parseInt(mouseDownX)+parseInt(initX)</span><br><span class="line">                +&apos;px&apos;</span><br><span class="line">           top=top &gt;0?0:</span><br><span class="line">            top&lt;650-height?650-height:top</span><br><span class="line">            +&apos;px&apos;</span><br><span class="line">            console.log(&apos;222&apos;,left,top)</span><br><span class="line">            img.style.left=left;</span><br><span class="line">            img.style.top=top</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        const &#123; img ,name,children&#125;=this.props</span><br><span class="line">        const &#123;show&#125;=this.state</span><br><span class="line">        return(</span><br><span class="line">            &lt;span&gt;</span><br><span class="line">                &lt;span onClick=&#123;()=&gt;&#123;this.setState(&#123;show:true&#125;)&#125;&#125;&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">              &lt;/span&gt;</span><br><span class="line">                &lt;Modal</span><br><span class="line">                    title=&#123;&lt;div&gt;</span><br><span class="line">                    &lt;span style=&#123;&#123;</span><br><span class="line">                        display: &apos;inline-block&apos;,</span><br><span class="line">                        width:6,</span><br><span class="line">                        height:16,</span><br><span class="line">                        marginRight:10,</span><br><span class="line">                        verticalAlign:&apos;center&apos;,</span><br><span class="line">                        backgroundColor: &apos;#4A9478&apos;,verticalAlign:&apos;center&apos;</span><br><span class="line">                    &#125;&#125;&gt;</span><br><span class="line">                    &lt;/span&gt;&#123;name&#125;&lt;/div&gt;&#125;</span><br><span class="line">                    visible=&#123;show&#125;</span><br><span class="line">                    closable</span><br><span class="line">                    onCancel=&#123;()=&gt;&#123; this.setState(&#123;show:false&#125;)&#125;&#125;</span><br><span class="line">                    footer=&#123;null&#125;</span><br><span class="line">                    width=&#123;900&#125;</span><br><span class="line">                    bodyStyle=&#123;&#123;backgroundColor:&apos;#F3F2F6&apos;,borderBottomRightRadius:4,borderBottomLeftRadius:4,</span><br><span class="line">                        height:650,overflow:&apos;scroll&apos;,position:&apos;relative&apos;,padding:0&#125;&#125;</span><br><span class="line">                    destroyOnClose</span><br><span class="line">                    maskClosable</span><br><span class="line">                    &gt;</span><br><span class="line">                        &lt;img</span><br><span class="line">                            id=&apos;img&apos;</span><br><span class="line">                            style=&#123;&#123;cursor:&apos;pointer&apos;,position:&apos;absolute&apos;&#125;&#125; src=&#123;img&#125;</span><br><span class="line">                            onMouseDown=&#123;this.handlerMouseDown&#125;</span><br><span class="line">                            onMouseUp=&#123;this.handlerMouseUp&#125;</span><br><span class="line">                            onMouseMove=&#123;this.handlerMouseMove&#125;</span><br><span class="line">                        /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &lt;/Modal&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Index</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; DragImg name=&quot;图片名称&quot; img=&#123;Img&#125;&gt;</span><br><span class="line">    &lt;img  style=&#123;&#123;width:500,height:600&#125;&#125; src=&#123;Img&#125;/&gt;</span><br><span class="line">&lt;/DragImg&gt;</span><br></pre></td></tr></table></figure>
<p>img 传入的是图片信息，可以是路径或是处理好的 base64 编码的图片信息<br></p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
  </entry>
  <entry>
    <title>异步打包详情页面</title>
    <url>/2018/12/05/%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>来源：简书项目<br>组件：react-loadable<br>作用：异步加载详情页面<br>具体：页面首先打包首页，打开详情页的时候，再打包详情页</p>
<a id="more"></a>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-loadable</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1、在当前页面 index 所在文件夹下，创建 loadable.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Loadable from &apos;react-loadable&apos;;</span><br><span class="line">import Loading from &apos;./my-loading-component&apos;;</span><br><span class="line"></span><br><span class="line">const LoadableComponent = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&apos;./my-component&apos;),</span><br><span class="line">  //需要异步加载的页面，本例是./index.js,index.js可省略</span><br><span class="line">  loading: Loading,</span><br><span class="line">  //页面加载时展示的loading，可以是一个自己写的组件，或者</span><br><span class="line">  //loading()&#123;</span><br><span class="line">  //   return &lt;div&gt;正在加载&lt;/div&gt;</span><br><span class="line">  //&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;LoadableComponent/&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、修改详情页面路由配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Detail from &apos;./pages/detail/&apos;;</span><br><span class="line">//变为</span><br><span class="line">import Detail from &apos;./pages/detail/loadable&apos;;</span><br></pre></td></tr></table></figure>
<p>3、这样详细页面无法直接访问项目到路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route component=&#123;component&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>只有写在该标签中的页面才能直接在 this.props.match 访问到路由<br>修改在 detail 页面代码<br>引入 withRouter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; withRouter &#125; from &apos;react-router-dom&apos;</span><br></pre></td></tr></table></figure>
<p>同时包裹 detail 组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(mapStateToProps,mapDispatchToProps)(withRouter(Detail))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown</title>
    <url>/2018/11/21/MarkDown/</url>
    <content><![CDATA[<h4 id="MarkDown-使用方法"><a href="#MarkDown-使用方法" class="headerlink" title="MarkDown 使用方法"></a>MarkDown 使用方法</h4><p><strong>注意</strong><br>如果有语法错误，search 功能无法使用</p>
<a id="more"></a>
<p><strong>一、标题</strong></p>
<h2 id="这是-一级标题"><a href="#这是-一级标题" class="headerlink" title="这是 一级标题"></a>这是 一级标题</h2><h3 id="这是-二级标题"><a href="#这是-二级标题" class="headerlink" title="这是 二级标题"></a>这是 二级标题</h3><h4 id="这是-三级标题"><a href="#这是-三级标题" class="headerlink" title="这是 三级标题"></a>这是 三级标题</h4><h5 id="这是-四级标题"><a href="#这是-四级标题" class="headerlink" title="这是 四级标题"></a>这是 四级标题</h5><h6 id="这是-五级标题"><a href="#这是-五级标题" class="headerlink" title="这是 五级标题"></a>这是 五级标题</h6><p>####### 这是六级标题</p>
<p><strong>二、字体</strong></p>
<p><strong>加粗</strong></p>
<p>_斜体_</p>
<p><strong>_ 斜体加粗 _</strong></p>
<p><del>删除线</del></p>
<p><strong>三、引用</strong></p>
<blockquote>
<p>引用文字</p>
</blockquote>
<p><strong>四、分割线</strong></p>
<hr>
<hr>
<p><strong>五、图片</strong><br><img src="https://www.baidu.com/img/baidu_jgylogo3.gif" alt="图片alt" title="图片title"><br>图片 alt 就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片 title 是图片的标题，当鼠标移到图片上时显示的内容。title 可加可不加</p>
<p><strong>六、超链接</strong><br><a href="http://www.baidu.com" title="baidu" target="_blank" rel="noopener">百度</a><br>如果要在新页面打开<br><a href="超链接地址" target="_blank">超链接名</a></p>
<p><strong>七、列表</strong></p>
<p>无序列表</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<p>有序列表</p>
<ol>
<li><p>列表内容 1</p>
</li>
<li><p>列表内容 2</p>
</li>
<li><p>列表内容</p>
</li>
</ol>
<p>顺序号与列表内容之间要有空格</p>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<ul>
<li><p>一级无序列表内容</p>
<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>一级无序列表内容</li>
</ul>
</li>
<li><p>二级有序列表内容</p>
<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>一级有序列表内容</li>
</ol>
</li>
</ul>
<p><strong>八、表格</strong></p>
<table>
<thead>
<tr>
<th>表头</th>
<th style="text-align:center">表头</th>
<th style="text-align:right">表头</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容</td>
<td style="text-align:center">内容</td>
<td style="text-align:right">内容</td>
</tr>
<tr>
<td>内容</td>
<td style="text-align:center">内容</td>
<td style="text-align:right">内容</td>
</tr>
</tbody>
</table>
<p>第二行分割表头和内容。</p>
<ul>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li>
</ul>
<table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">技能</th>
<th style="text-align:right">排行</th>
</tr>
</thead>
<tbody>
<tr>
<td>刘备</td>
<td style="text-align:center">哭</td>
<td style="text-align:right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td style="text-align:center">打</td>
<td style="text-align:right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td style="text-align:center">骂</td>
<td style="text-align:right">三弟</td>
</tr>
</tbody>
</table>
<p><strong>八、设置某一句的颜色或大小</strong></p>
<font color="#FF0000"> 我可以设置这一句的颜色哈哈 </font>

<p><strong>居中</strong></p>
<center>这一行需要居中</center>

<p><strong>代码</strong><br><code>sdd</code></p>
<p><strong>多行代码</strong></p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/11/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g 部署</span><br><span class="line">去掉xml报错替换正则：[\x00-\x1F\x7F]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
  </entry>
</search>
