<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fdd’Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dorisfeng.github.io/"/>
  <updated>2020-11-27T02:39:22.976Z</updated>
  <id>https://dorisfeng.github.io/</id>
  
  <author>
    <name>封多多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-源码</title>
    <link href="https://dorisfeng.github.io/2020/11/24/React-%E6%BA%90%E7%A0%81/"/>
    <id>https://dorisfeng.github.io/2020/11/24/React-源码/</id>
    <published>2020-11-24T01:18:27.000Z</published>
    <updated>2020-11-27T02:39:22.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg7.jpg" alt="React"><br>React-源码</p><a id="more"></a><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p><strong>快速响应</strong><br>制约因素</p><ol><li>CPU 瓶颈 计算能力</li><li>IO 瓶颈 渲染能力</li></ol><p>传统解决方案：</p><ul><li>节流： 一段时间内将多次操作放到一次执行，滚动</li><li>防抖： 在调用停止一段时间之前忽略时间处理程序的调用</li></ul><h2 id="架构演进史"><a href="#架构演进史" class="headerlink" title="架构演进史"></a>架构演进史</h2><p>老的 React 架构(React 15)<br><img src="/2020/11/24/React-源码/img1.png" alt="React 15"><br>Reconciler：决定本次更新需要渲染什么组件<br>reconcile: 协调，Diff 算法，将上次更新的组件与本次更新的组件进行对比，将需要更新的组件渲染到视图中。<br>Renderer：决定组件渲染到视图中</p><p>新的 React 架构(React 16)<br><img src="/2020/11/24/React-源码/img2.png" alt="React 16"><br>Scheduler：根据优先级调度更新，优先级高的先进入协调器处理，在协调器中进行 diff 算法时，可以被更高优先级的更新中断，等待重新调度。<br>Scheduler 和 Reconciler 在内存中运行，视图不会发生变化，中断也不会显示错误的页面渲染。</p><p>同步更新-异步可中断的更新</p><h2 id="Fiber-纤程"><a href="#Fiber-纤程" class="headerlink" title="Fiber 纤程"></a>Fiber 纤程</h2><p>代数效应<br>函数式编程的概念，用于将副作用从函数调用中分离</p><ul><li>架构-Fiber 协调器</li><li>静态的数据结构<br>一个 Fiber 节点对应一个组件，保存了该组件的类型、对应 DOM 等信息，<br>就是虚拟 DOM ，JSX</li><li>动态的工作单元<br>保存组件需要更新的状态和需要更新的副作用。</li></ul><p>工作机制：双缓存</p><ol><li>创建应用根节点 FiberRootNode</li><li>调用 render 函数，创建当前应用的根节点 RootFiber,FiberRootNode 的 current 属性指向 RootFiber。首屏渲染前，页面空白，所以 RootFiber 没有子节点。</li><li>首屏渲染<ul><li>创建新的 RootFiber 树，新旧 RootFiber 通过 current 属性连接</li></ul></li><li>更新</li></ol><p><a href="https://react.iamkasong.com/process/doubleBuffer.html" target="_blank" rel="noopener">双缓存工作原理</a></p><p>首屏渲染和更新的区别，创建 workInProgressFiber 树的时候有没有 current 节点(不包括 rootFiber)</p><h2 id="JSX-与-Fiber-的关系"><a href="#JSX-与-Fiber-的关系" class="headerlink" title="JSX 与 Fiber 的关系"></a>JSX 与 Fiber 的关系</h2><p><code>JSX</code>是<code>React.createElement</code>的语法糖<br>参数<br>type：元素类型，原生 DOM 节点，如<code>div p</code>，在 React 中的 tag 类型是 HostComponent。<br>props：元素属性<code>&lt;div title=&#39;a&#39;&gt;&lt;/div&gt;</code><br>children：元素的子元素<br>首屏：根据组件返回的 JSX 对象创建 WorkInProgress Fiber 树<br>更新：根据组件返回的 JSX 对象与组件的 Current Fiber 树对比，生成 WorkInProgress Fiber 树</p><h2 id="React-Component-与-React-Element-的关系"><a href="#React-Component-与-React-Element-的关系" class="headerlink" title="React Component 与 React Element 的关系"></a>React Component 与 React Element 的关系</h2><p>React Element：是<code>React.createElement</code>的调用结果<br>React Component：类组件或者函数组件<br>React Component 的名字会作为<code>React.createElement</code>调用的第一个参数 type</p><h2 id="render-协调器"><a href="#render-协调器" class="headerlink" title="render-协调器"></a>render-协调器</h2><h3 id="创建根-Fiber-节点"><a href="#创建根-Fiber-节点" class="headerlink" title="创建根 Fiber 节点"></a>创建根 Fiber 节点</h3><h3 id="beginWork-current-workInProgress"><a href="#beginWork-current-workInProgress" class="headerlink" title="beginWork(current, workInProgress)"></a>beginWork(current, workInProgress)</h3><p>创建当前 fiber 节点的第一个子 fiber 节点</p><ul><li>根据<code>workInProgress.tag</code>执行不同的 update 函数</li><li>在 update 函数中，判断当前<code>workInProgress fiber</code>是否包含<code>current fiber</code>，决定是否标记<code>Effect Tags</code>， 执行不同的<code>reconcileChildren</code>(current 不存在不标记副作用)，mount 时，只有当前的 rootFiber 节点标记了副作用。</li><li>在<code>reconcileChildren</code>中，根据子节点的类型执行不同的新建<code>FiberNode</code> 操作，即使存在多个子节点还是只新建第一个子节点</li></ul><h3 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h3><ul><li>创建当前节点的 DOM 节点，</li><li>赋值给当前 Fiber 节点的<code>stateNode</code>，将当前 DOM 节点的子节点生成的 DOM 树，插入到当前 DOM</li><li>为 DOM 节点设置 props 属性，初始化 DOM 事件</li><li>创建</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg7.jpg&quot; alt=&quot;React&quot;&gt;&lt;br&gt;React-源码&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-正则表达式</title>
    <link href="https://dorisfeng.github.io/2020/11/20/JS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://dorisfeng.github.io/2020/11/20/JS-正则表达式/</id>
    <published>2020-11-20T13:48:15.000Z</published>
    <updated>2020-11-22T05:00:38.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg6.jpg" alt="正则表达式"></p><a id="more"></a><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>字面量<br><code>let re=/ab+c/</code><br>构造函数<br><code>let re=new RegExp(&quot;ab+c&quot;)</code></p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>\</code></td><td>在非字符串之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。<br> ‘b’ =&gt; 小写字母<br>‘\b’ =&gt; 字符边界<br>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应按照字母理解</td></tr><tr><td><code>^</code></td><td>1.匹配输入字符串的开始位置，2.如果出现在一个字符集合模式(方括号)里，表示不接受该方括号表达式中的字符集合。要匹配 <code>^</code> 字符本身，请使用 <code>\^</code>。</td></tr><tr><td><code>$</code></td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline (多行标志)属性，则 \$ 也匹配 <code>&#39;\n&#39;</code> 或 <code>&#39;\r&#39;</code>。要匹配 <code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr><td><code>.</code></td><td>默认匹配除换行符<code>\n</code>之外的任何单个字符，如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符。</td></tr><tr><td><code>(x)</code></td><td>标记一个子表达式 的开 x 始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td><code>[xyz]</code></td><td>一个字符集。匹配 x,y,z 三个字符中的任意一个</td></tr><tr><td><code>[^xyz]</code></td><td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br> <code>[^abc]</code>等于<code>[^a-c]</code>，匹配‘brisket’，第一个匹配结果是’r’。</td></tr><tr><td>`</td><td>`</td><td>或者</td></tr></tbody></table><h2 id="数量限定符"><a href="#数量限定符" class="headerlink" title="数量限定符"></a>数量限定符</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配前面的子表达式零次或多次。等价于 <code>{0,}</code>。要匹配 <code>\*</code> 字符，请使用 <code>\*</code>。</td></tr><tr><td><code>+</code></td><td>匹配前面一个表达式 1 次或者多次。等价于 <code>{1,}</code>。要匹配 <code>\+</code> 字符，请使用 <code>\+</code>。</td></tr><tr><td><code>.</code></td><td>(小数点）默认匹配除换行符之外的任何单个字符。</td></tr><tr><td><code>?</code></td><td>如果紧跟在任何量词 <code>*</code>、 <code>+</code>、<code>?</code> 或 <code>{}</code> 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。要匹配<code>?</code>字符，请使用 <code>\?</code>。</td></tr><tr><td><code>{n}</code></td><td>n 是一个正整数，匹配前一个字符串刚好连续出现 n 次。</td></tr><tr><td><code>{n,}</code></td><td>n 是一个正整数，匹配前一个字符至少出现了 n 次。</td></tr><tr><td><code>{n,m}</code></td><td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0， 这个值被忽略。</td></tr></tbody></table><h2 id="预定义符"><a href="#预定义符" class="headerlink" title="预定义符"></a>预定义符</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配一个数字字符，等价于[0-9]</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符，等价于[^0-9]</td></tr><tr><td><code>\w</code></td><td>匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。</td></tr><tr><td><code>\W</code></td><td>匹配一个非单字字符。等价于 [^a-za-z0-9_]。</td></tr><tr><td><code>\s</code></td><td>匹配一个空白字符，包括空格、制表符、换页符、换行符。等价于 [ \f\n\r\t\v]。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于 [^\f\n\r\t\v]。</td></tr></tbody></table><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>\f</code></td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符。等价于 \xOd 和\cM</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符，等价于\x09 和\cL</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符，等价于\x0b 和\cK</td></tr><tr><td><code>[\b]</code></td><td>匹配一个退格</td></tr><tr><td><code>\b</code></td><td>匹配一个词的边界，不包括边界。<br>/\bm/匹配’moon’中的 m<br>/oo\b/匹配不到’moon’中的’oo’</td></tr><tr><td><code>\B</code></td><td>匹配一个非单词边界<br> /y\B../匹配”possibly yesterday”中的’yes‘。</td></tr></tbody></table><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>var re=/pattern/flags</code><br><code>var re=new RegExp(&#39;pattern&#39;,&#39;flags&#39;)</code></p><table><thead><tr><th>修饰符</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td><code>i</code></td><td>ignore - 不区分大小写</td><td>将匹配设置为不区分大小写</td></tr><tr><td><code>g</code></td><td>global - 全局匹配</td><td>查找所有的匹配项</td></tr><tr><td><code>m</code></td><td>multi line - 多行匹配</td><td>使边界字符 ^ 和 \$ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td><code>s</code></td><td>特殊字符圆点<code>.</code> 中包含换行符<code>\n</code></td><td>默认情况下的圆点<code>.</code>是匹配除换行符<code>\n</code>之外的任何字符，加上<code>s</code>修饰符之后, <code>.</code>中包含换行符 <code>\n</code>。</td></tr><tr><td><code>u</code></td><td>使用 unicode 码的模式进行匹配</td></tr><tr><td><code>y</code></td><td>执行粘性搜索，匹配从目标字符串的当前位置开始</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>exec</code><br>reg.exec(‘string’)<br>用于检索字符串中的正则表达式的匹配。返回一个匹配到的字符数组，否则返回 null</li><li><code>test</code><br>reg.test(‘string’)<br>用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，</li><li><p><code>match</code><br>‘string’.match(reg)<br>一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。</p><p>返回值</p><ul><li>如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</li><li>如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。</li></ul></li><li><p><code>matchAll</code><br><code>str.matchAll(regexp)</code><br>一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器</p></li><li><p><code>search</code><br><code>string.search(reg)</code><br>一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</p></li><li><p><code>replace</code><br><code>str.replace(regexp|substr, newSubStr|function)</code><br>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg6.jpg&quot; alt=&quot;正则表达式&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组-排序</title>
    <link href="https://dorisfeng.github.io/2020/11/19/%E6%95%B0%E7%BB%84-%E6%8E%92%E5%BA%8F/"/>
    <id>https://dorisfeng.github.io/2020/11/19/数组-排序/</id>
    <published>2020-11-19T08:33:30.000Z</published>
    <updated>2020-11-20T09:28:58.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg5.jpg" alt="高阶函数"><br>数组排序算法整理<br><a href="https://blog.csdn.net/weixin_42989966/article/details/103564643" target="_blank" rel="noopener">参考</a></p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>思想：</p><ol><li>两层循环</li><li>外层循环控制循环控制开始比较的下标 i</li><li>内循环将 i 之后元素两两比较，交换位置，将最大值或最小值移动到位置 i。</li></ol><p><img src="/2020/11/19/数组-排序/img1.gif" alt="冒泡"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(fun) &#123;</span><br><span class="line">    return function inner(arr) &#123;</span><br><span class="line">        if (arr.length &lt;=1) &#123;</span><br><span class="line">            return arr</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                let res = fun(arr[i], arr[j]);</span><br><span class="line">                console.log(res)</span><br><span class="line">                if (res &gt; 0) &#123;</span><br><span class="line">                    let temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let fun = (a, b) =&gt; a.charCodeAt() - b.charCodeAt();</span><br><span class="line">let sort = bubbleSort(fun)</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>思想：</p><ol><li>新建两个数组 left,right</li><li>选择一个数作为基准数，可以是数组中的任意一个元素，一般取数组的中间元素</li><li>将数组中的元素与基准数比较，小于基准数放 left 数组(升序)，大于基准值的放进右边 right 数组。</li><li>将左右数组作为参数递归调用排序函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(fun) &#123;</span><br><span class="line">    return function inner(arr) &#123;</span><br><span class="line">        if (arr.length &lt;= 1) &#123;</span><br><span class="line">            return arr</span><br><span class="line">        &#125;</span><br><span class="line">        let left = [],</span><br><span class="line">            right = [],</span><br><span class="line">            standard = arr[Math.floor(arr.length / 2)];</span><br><span class="line">        arr.splice(arr.indexOf(standard), 1)//如果不做处理，存在相同值会无无限递归到栈溢出</span><br><span class="line">        for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (fun(standard, arr[i]) &gt; 0) &#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inner(left).concat(standard, inner(right))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思想：</p><ol><li>从第一个元素开始，默认该元素为已被排序元素（最大或最小）</li><li>取出当前元素的后一个元素，与已经排序的元素序列（此元素的前面元素）从后向前循环比较</li><li>如果该元素小于（递增排序）循环拿到的元素，就与下一位循环元素比较，</li><li>重复步骤 3，直到找到已排序元素中小于或等于新元素的位置，将该元素插入循环元素的后面</li><li>如果没有找到，就插入到数组最后面</li><li>重复步骤 2-5<br><img src="/2020/11/19/数组-排序/img2.gif" alt="插入排序"></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    if (arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr</span><br><span class="line">    &#125;</span><br><span class="line">    let result = [arr[0]];</span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        let standard = arr[i];</span><br><span class="line">        for (let j = result.length - 1; j &gt;= 0;j--) &#123;</span><br><span class="line">            if (standard &gt; result[j]) &#123;</span><br><span class="line">                result.splice(j + 1, 0, standard);</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if (j === 0) &#123;</span><br><span class="line">                result.push(standard)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思想：</p><ol><li>设置索引值为 0 的元素为最小值</li><li>遍历索引为 0 以后的数组，如果后面的元素小于索引为 0 的元素就交换</li><li>遍历完成后，将索引为加一，以此元素为最小值，重复 2</li></ol><p><img src="/2020/11/19/数组-排序/img3.gif" alt="选择排序"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(fun) &#123;</span><br><span class="line">        return function inner(arr) &#123;</span><br><span class="line">            if (arr.length &lt;= 1) &#123;</span><br><span class="line">                return arr</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                for (let j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                    if (fun(arr[i], arr[j])) &#123;</span><br><span class="line">                        let tmp = arr[i];</span><br><span class="line">                        arr[i] = arr[j];</span><br><span class="line">                        arr[j] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arr</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let fun = (a, b) =&gt; &#123;</span><br><span class="line">        return a.charCodeAt() - b.charCodeAt() &lt; 0</span><br><span class="line">    &#125;;</span><br><span class="line">    let sort = selectionSort(fun)</span><br><span class="line"></span><br><span class="line">    sort(array)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg5.jpg&quot; alt=&quot;高阶函数&quot;&gt;&lt;br&gt;数组排序算法整理&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42989966/article/details/103564643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Array" scheme="https://dorisfeng.github.io/categories/Array/"/>
    
    
  </entry>
  
  <entry>
    <title>React-虚拟DOM</title>
    <link href="https://dorisfeng.github.io/2020/11/10/React-%E8%99%9A%E6%8B%9FDOM/"/>
    <id>https://dorisfeng.github.io/2020/11/10/React-虚拟DOM/</id>
    <published>2020-11-10T01:28:19.000Z</published>
    <updated>2020-11-24T01:21:59.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg4.jpg" alt="React"></p><a id="more"></a><h2 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h2><p>本质上是<code>JS</code>和<code>DOM</code>之间的映射缓存，在形态上表现为一个能够描述<code>DOM</code>结构及其属性信息的<code>JS对象</code>。<br><code>React</code>虚拟<code>DOM</code>的工作流程，</p><ul><li><code>挂载阶段</code>，React 将结合 JSX 的描述，构建出虚拟<code>DOM</code>树，然后通过<code>ReactDOM.render</code>实现虚拟<code>DOM</code>到真实<code>DOM</code>的映射。</li><li><code>更新阶段</code>，页面的变化先作用于虚拟<code>DOM</code>，虚拟<code>DOM</code>在<code>JS</code>层借助算法先比较出哪些真实<code>DOM</code>发生改变，再将改变作用于真实<code>DOM</code>。</li></ul><h2 id="DOM-操作解决方案"><a href="#DOM-操作解决方案" class="headerlink" title="DOM 操作解决方案"></a>DOM 操作解决方案</h2><ul><li><code>JS</code> 操作 <code>DOM</code> 时期</li><li><code>jQuery</code>时期<br>将 DOM 操作变得简单、快速、并且始终保证其稳定和可用。</li><li>模板引擎方案<br>将 JS 与 HTML 结合，将数据塞入预置好的 HTML 模板中，然后件模板字符串挂载到 DOM 中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line"> &#123;% staff.forEach(function(person)&#123; %&#125;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;&#123;% student.name %&#125;&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;&#123;% student.age %&#125;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &#123;% &#125;); %&#125;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">// 数据和模板融合出 HTML 代码</span><br><span class="line">var targetDOM = template(&#123;data: students&#125;)</span><br><span class="line">// 添加到页面中去</span><br><span class="line">document.body.appendChild(targetDOM)</span><br></pre></td></tr></table></figure><p>模板引擎主要做了下面几件事：</p><ol><li>读取 HTML 模板并解析，分离其中的 JS 信息。</li><li>将解析出的内容拼接成字符串，生成 JS 代码</li><li>运行动态生成的 JS 代码，吐出目标 HTML</li><li>将目标 HTMl 赋值给 innerHTML，触发渲染流水线，完成真是 DOM 渲染。</li></ol><ul><li>虚拟 DOM<br>当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”。这个过程对应的虚拟 DOM 工作流如下图所示：<br><img src="/2020/11/10/React-虚拟DOM/img1.png" alt="更新"></li></ul><h2 id="为什么要使用虚拟-DOM"><a href="#为什么要使用虚拟-DOM" class="headerlink" title="为什么要使用虚拟 DOM"></a>为什么要使用虚拟 DOM</h2><p>首先使用虚拟 DOM 不一定会提升性能，性能是一个复杂度比较高的问题，当我们量化性能的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论。</p><p>虚拟 DOM 解决的关键问题有以下两个</p><ul><li>提高研发体验/研发效率</li><li>跨平台的问题<br>虚拟 DOM 是对真实渲染内容的一层抽象，如果没有这层抽象，视图层将和渲染平台紧密耦合在一起。有个这层抽象可以实现<code>一次编码，多端运行</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg4.jpg&quot; alt=&quot;React&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://dorisfeng.github.io/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>React-性能优化2</title>
    <link href="https://dorisfeng.github.io/2020/11/07/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%962/"/>
    <id>https://dorisfeng.github.io/2020/11/07/React-性能优化2/</id>
    <published>2020-11-07T07:44:08.000Z</published>
    <updated>2020-11-10T02:47:55.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg3.jpg" alt="React"><br>React-hook 性能优化方案</p><a id="more"></a><h2 id="使用-children-避免没必要的渲染"><a href="#使用-children-避免没必要的渲染" class="headerlink" title="使用 children 避免没必要的渲染"></a>使用 children 避免没必要的渲染</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useContext &#125; from &quot;React&quot;;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext();</span><br><span class="line"></span><br><span class="line">function ChildNonTheme() &#123;</span><br><span class="line">  console.log(&quot;不关心皮肤的子组件渲染了&quot;);</span><br><span class="line">  return &lt;div&gt;不关心皮肤，皮肤改变的时候别让我重新渲染&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ChildWithTheme() &#123;</span><br><span class="line">  const theme = useContext(ThemeContext);</span><br><span class="line">  console.log(&quot;有皮肤的子组件&quot;);</span><br><span class="line">  return &lt;div&gt;我是有皮肤的，&#123;theme&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line">// function ThemeApp(&#123; children &#125;) &#123;</span><br><span class="line">//   const [theme, setTheme] = useState(&quot;light&quot;);</span><br><span class="line">//   const onChangeTheme = () =&gt; setTheme(theme === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;);</span><br><span class="line">//   return (</span><br><span class="line">//     &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">//       &lt;button onClick=&#123;onChangeTheme&#125;&gt;改变皮肤&lt;/button&gt;</span><br><span class="line">//       &#123;children&#125;</span><br><span class="line">//     &lt;/ThemeContext.Provider&gt;</span><br><span class="line">//   );</span><br><span class="line">// &#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  const [theme, setTheme] = useState(&quot;light&quot;);</span><br><span class="line">  const onChangeTheme = () =&gt; setTheme(theme === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;onChangeTheme&#125;&gt;改变皮肤&lt;/button&gt;</span><br><span class="line">      &lt;ChildWithTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击改变皮肤<br><img src="/2020/11/07/React-性能优化2/img1.png" alt="img1"><br>没有使用皮肤的子组件也进行了无效的重新渲染。<br>本质上由于<code>React</code>自上向下递归更新，<code>&lt;ChildNoTheme/&gt;</code>会被翻译为<code>React.createElement(ChildNonTheme)</code>，<code>React</code>的<code>props</code>属性是<code>immutable</code>的，每次调用函数式组件的时候，会生成一份新的<code>props</code>引用。<br><code>createElement</code>的返回结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const childNonThemeElement=&#123;</span><br><span class="line">    type:&apos;ChildNonTheme&apos;,</span><br><span class="line">    props:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>props</code>引用更新，导致<code>ChildNonTheme</code>组件重新渲染。<br>解决办法：利用<code>children</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useContext &#125; from &quot;React&quot;;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext();</span><br><span class="line"></span><br><span class="line">function ChildNonTheme() &#123;</span><br><span class="line">  console.log(&quot;不关心皮肤的子组件渲染了&quot;);</span><br><span class="line">  return &lt;div&gt;不关心皮肤，皮肤改变的时候别让我重新渲染&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ChildWithTheme() &#123;</span><br><span class="line">  const theme = useContext(ThemeContext);</span><br><span class="line">  return &lt;div&gt;我是有皮肤的，&#123;theme&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function ThemeApp(&#123; children &#125;) &#123;</span><br><span class="line">  const [theme, setTheme] = useState(&quot;light&quot;);</span><br><span class="line">  const onChangeTheme = () =&gt; setTheme(theme === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;onChangeTheme&#125;&gt;改变皮肤&lt;/button&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeApp&gt;</span><br><span class="line">      &lt;ChildWithTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">      &lt;ChildNonTheme /&gt;</span><br><span class="line">    &lt;/ThemeApp&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，把渲染比较费时，但是不需要关心子组件提升到有状态组件的外部，作为<code>children</code>或者<code>props</code>传递进去直接使用，防止不必要的渲染。<br>这个优化也一样可以用 React.memo 包裹子组件来做，不过相对的增加维护成本，根据场景权衡选择。</p><h2 id="Context-读写分离"><a href="#Context-读写分离" class="headerlink" title="Context 读写分离"></a>Context 读写分离</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useContext &#125; from &quot;React&quot;;</span><br><span class="line"></span><br><span class="line">const LogContext = React.createContext();</span><br><span class="line"></span><br><span class="line">function LogProvider(&#123; children &#125;) &#123;</span><br><span class="line">  const [logs, setLogs] = useState([]);</span><br><span class="line">  const addLog = (log) =&gt; setLogs((prevLogs) =&gt; [...prevLogs, log]);</span><br><span class="line"></span><br><span class="line">  return &lt;LogContext.Provider value=&#123;&#123; logs, addLog &#125;&#125;&gt;&#123;children&#125;&lt;/LogContext.Provider&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Logger1() &#123;</span><br><span class="line">  const &#123; addLog &#125; = useContext(LogContext);</span><br><span class="line">  console.log(&quot;Logger1 render&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;一个能发日志的组件1&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; addLog(&quot;logger1&quot;)&#125;&gt;发日志&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function Logger2() &#123;</span><br><span class="line">  const &#123; addLog &#125; = useContext(LogContext);</span><br><span class="line">  console.log(&quot;Logger2 render&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;一个能发日志的组件2&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; addLog(&quot;logger2&quot;)&#125;&gt;发日志&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function LogsPanel() &#123;</span><br><span class="line">  console.log(&quot;panel&quot;);</span><br><span class="line">  const &#123; logs &#125; = useContext(LogContext);</span><br><span class="line">  return logs.map((log, index) =&gt; &lt;p key=&#123;index&#125;&gt;&#123;log&#125;&lt;/p&gt;);</span><br><span class="line">&#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;LogProvider&gt;</span><br><span class="line">      &lt;Logger1 /&gt;</span><br><span class="line">      &lt;Logger2 /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;LogsPanel /&gt;</span><br><span class="line">    &lt;/LogProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/11/07/React-性能优化2/img2.png" alt="context"><br>点击任意一个发日志的按钮，所有的<code>Logger</code>和<code>LogsPanel</code>都会重新渲染。<br>在现实场景中，如果存在多个写日志的组件，每次都导致全局的组件都重新渲染。<br>原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当Provider的value的值发生变化，内部所有的消费组件都会重新渲染。Provider及其内部consumer组件都不受制于shouldComponentUpdate函数，因此当consumer组件在其祖先组件退出更新的情况下也能更新。</span><br></pre></td></tr></table></figure><p>当<code>LogProvider</code>中的<code>addLog</code>被子组件调用，导致<code>LogProvider</code>重新渲染之后，必然会导致传递给<code>Provider</code>的<code>value</code>发生变化，由于<code>value</code>包含了<code>logs</code>和<code>setLogs</code>属性，所以两者中任意一个发生变化，都会导致所有的订阅了<code>LogProvider</code>的子组件重新渲染。</p><p>解决办法：读写分离，把<code>logs</code>和<code>setLogs</code>分别通过不同的<code>Provider</code>传递，这样负责写入的组件改了<code>logs</code>，其他的写组件并不会重新渲染，只有真正关心<code>logs</code> 的读组件会重新渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useContext, useCallback &#125; from &quot;React&quot;;</span><br><span class="line"></span><br><span class="line">const LogDispatchContext = React.createContext();</span><br><span class="line">const LogStateContext = React.createContext();</span><br><span class="line">function LogProvider(&#123; children &#125;) &#123;</span><br><span class="line">  const [logs, setLogs] = useState([]);</span><br><span class="line">  const addLog = useCallback((log) =&gt; setLogs((prevLogs) =&gt; [...prevLogs, log]), []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;LogDispatchContext.Provider value=&#123;addLog&#125;&gt;</span><br><span class="line">      &lt;LogStateContext.Provider value=&#123;logs&#125;&gt; &#123;children&#125;&lt;/LogStateContext.Provider&gt;</span><br><span class="line">    &lt;/LogDispatchContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Logger1() &#123;</span><br><span class="line">  const addLog = useContext(LogDispatchContext);</span><br><span class="line">  console.log(&quot;Logger1 render&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;一个能发日志的组件1&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; addLog(&quot;logger1&quot;)&#125;&gt;发日志&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function Logger2() &#123;</span><br><span class="line">  const addLog = useContext(LogDispatchContext);</span><br><span class="line">  console.log(&quot;Logger2 render&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;一个能发日志的组件2&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; addLog(&quot;logger2&quot;)&#125;&gt;发日志&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function LogsPanel() &#123;</span><br><span class="line">  const logs = useContext(LogStateContext);</span><br><span class="line">  console.log(&quot;panel&quot;);</span><br><span class="line">  return logs.map((log, index) =&gt; &lt;p key=&#123;index&#125;&gt;&#123;log&#125;&lt;/p&gt;);</span><br><span class="line">&#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;LogProvider&gt;</span><br><span class="line">      &lt;Logger1 /&gt;</span><br><span class="line">      &lt;Logger2 /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;LogsPanel /&gt;</span><br><span class="line">    &lt;/LogProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证<code>addLog</code>方法不会重新生成，需要使用<code>useCallback</code>把<code>addLog</code>方法包裹起来，才能保证<code>LogProvider</code>重渲染的时候，传递给的<code>LogDispatcherContext</code>的<code>value</code>不发生变化。<br><img src="/2020/11/07/React-性能优化2/img3.png" alt="React"></p><h2 id="Context-代码组织"><a href="#Context-代码组织" class="headerlink" title="Context 代码组织"></a>Context 代码组织</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const LogStateContext = React.createContext();</span><br><span class="line">const LogDispatcherContext = React.createContext();</span><br><span class="line"></span><br><span class="line">export function useLogState() &#123;</span><br><span class="line">  const context = React.useContext(LogStateContext);</span><br><span class="line">  if (context === undefined) &#123;</span><br><span class="line">    throw new Error(&quot;useLogState must be used within a LogSTateProvider&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useLogDispatcher() &#123;</span><br><span class="line">  const context = React.useContext(LogDispatcherContext);</span><br><span class="line">  if (context === undefined) &#123;</span><br><span class="line">    throw new Error(&quot;useLogDispatcher must be used within a logDispatcherContext&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时调用两个<code>context</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export function useLogs() &#123;</span><br><span class="line">  return [useLogState(), useLogDispatcher()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">export function App()&#123;</span><br><span class="line">    const [logs,addLogs]=useLogs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合-Providers"><a href="#组合-Providers" class="headerlink" title="组合 Providers"></a>组合 Providers</h2><p>多个嵌套的<code>Provider</code>嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const StateProviders=(&#123;children&#125;)=&gt;(</span><br><span class="line"> &lt;LogProvider&gt;</span><br><span class="line">    &lt;UserProvider&gt;</span><br><span class="line">        &lt;MenuProvider&gt;</span><br><span class="line">            &lt;AppProvider&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">            &lt;/AppProvider&gt;</span><br><span class="line">        &lt;/MenuProvider&gt;</span><br><span class="line">    &lt;/UserProvider&gt;</span><br><span class="line"> &lt;/LogProvider&gt;</span><br><span class="line">)</span><br><span class="line">function App()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;StateProvider&gt;</span><br><span class="line">            &lt;Main/&gt;</span><br><span class="line">        &lt;/StateProvider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装<code>redux</code>中的<code>compose</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function composeProvider(...providers)&#123;</span><br><span class="line">    return (&#123;children&#125;)=&gt;&#123;</span><br><span class="line">        providers.reduce((prev,Provider)=&gt;&lt;Provider&gt;&#123;prev&#125;&lt;/Provider&gt;, children</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以简化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const StateProviders = composeProviders(</span><br><span class="line">  LogProvider,</span><br><span class="line">  UserProvider,</span><br><span class="line">  MenuProvider,</span><br><span class="line">  AppProvider,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;StateProvider&gt;</span><br><span class="line">      &lt;Main /&gt;</span><br><span class="line">    &lt;/StateProvider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg3.jpg&quot; alt=&quot;React&quot;&gt;&lt;br&gt;React-hook 性能优化方案&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-高阶函数</title>
    <link href="https://dorisfeng.github.io/2020/11/06/JS-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://dorisfeng.github.io/2020/11/06/JS-高阶函数/</id>
    <published>2020-11-06T06:20:38.000Z</published>
    <updated>2020-11-07T08:24:37.251Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg2.jpg" alt="高阶函数"><br>高阶函数以及多个高阶函数嵌套</p><a id="more"></a><p>高阶函数：以另一个函数作为参数的函数</p><p>例子：封装一个 map 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">arr.map((v,k)=&gt;&#123;</span><br><span class="line">    console.log(this.sss);//1</span><br><span class="line">    return v*2</span><br><span class="line">&#125;,&#123;sss:1&#125;)</span><br></pre></td></tr></table></figure><p>注意，<code>map</code>方法的第二个参数作为第一个函数的<code>this</code>对象，如果未传入，函数的 this 指向按照函数的类型，是否严格模式等情况讨论，<br>参见:JS-this 指向<br>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._map=function(fun,context)&#123;</span><br><span class="line">    if(typeof fun !==&apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(fn+&quot;is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let len=this.length;</span><br><span class="line">    let temp=[]</span><br><span class="line">    for(let k=0;k&lt;len;k++)&#123;</span><br><span class="line">        temp.push(fun.call(context,this[k],k,this))</span><br><span class="line">    &#125;</span><br><span class="line">    return temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码组合</strong><br>高阶函数 widthLogin，判断用户状态<br>登录判断模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const getLogin=function()&#123;</span><br><span class="line"> const getLogin=function()&#123;</span><br><span class="line">     var a=parseInt(Math.random()*10).toFixed(0);</span><br><span class="line">     if(a%2==0)&#123;</span><br><span class="line">         return &#123;login:false&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return&#123;</span><br><span class="line">         login:true</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const withLogin=function(basicFn)&#123;</span><br><span class="line">     const loginInfo=getLogin();</span><br><span class="line">     return basicFn.bind(null,loginInfo)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const withLogin=window.withLogin;</span><br><span class="line">const renderIndex=function(loginInfo)&#123;</span><br><span class="line">    //判断是否登录</span><br><span class="line">    if(loginInfo.login)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.renderIndex=withLogin(renderIndex)</span><br></pre></td></tr></table></figure><p>其他模块，处理方法相同，都是在外面包一层 withLogin<br>如果还需要一个高阶函数判断当前系统的运行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    const env=&#123;</span><br><span class="line">        isMobile:false,</span><br><span class="line">        isAndroid:false,</span><br><span class="line">        isIOS:false,</span><br><span class="line">    &#125;</span><br><span class="line">    const ua=navigator.userAgent;</span><br><span class="line">    env.isMobile=&apos;ontouchstart&apos; in document;</span><br><span class="line">    env.isAndroid=!!ua.match(/android/);</span><br><span class="line">    env.isIOS=!!us.match(/iphone/);</span><br><span class="line"></span><br><span class="line">    const withEnvironment=function(basicFn)&#123;</span><br><span class="line">        return basicFn.bind(null,env);</span><br><span class="line">    &#125;</span><br><span class="line">    window.withEnvironment=withEnvironment;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>此时主页函数调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = withLogin(withEnvironment(renderIndex));</span><br></pre></td></tr></table></figure><p><code>compose</code>方法从右至左，将第一个参数<code>renderIndex</code>作为第二个参数<code>withEnvironment</code>的参数，并将运行结果作为第一个参数的参数，并且最后返回一个新的函数，这个函数拥有两个高阶函数的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br></pre></td></tr></table></figure><p>实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">     let last = args.length - 1;</span><br><span class="line">     tag = false;</span><br><span class="line">     if (typeof args[last] === &apos;function&apos;) &#123;</span><br><span class="line">         tag = true</span><br><span class="line">     &#125;</span><br><span class="line">     if (last &gt; 1) &#123;</span><br><span class="line">         let param = args.pop(args[last]);</span><br><span class="line">         last--;</span><br><span class="line">         let newParam = args[last].call(args[last], param)</span><br><span class="line">         args.pop(args[last])</span><br><span class="line"></span><br><span class="line">         args.push(newParam);</span><br><span class="line">         console.log(newParam);</span><br><span class="line">         return compose(...args);</span><br><span class="line">     &#125; else if (last === 1) &#123;</span><br><span class="line">         if (!tag) &#123;</span><br><span class="line">             return args[0].bind(null, args[1])</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             return args[0].call(null, args[1])</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn1 = function (a) &#123;</span><br><span class="line">        return a + 100</span><br><span class="line">    &#125;</span><br><span class="line">    var fn2 = function (a) &#123;</span><br><span class="line">        return a + 10</span><br><span class="line">    &#125;</span><br><span class="line">    var fn3 = function (a) &#123;</span><br><span class="line">        return a + 20</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var bar = compose(fn1, fn2, fn3, 10);</span><br><span class="line">    console.log(bar());</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    // 30</span><br><span class="line">    // 40</span><br><span class="line">    // 140</span><br></pre></td></tr></table></figure><p>上一个函数的运算结果作为下一个函数的参数，这种逻辑与<code>reduce</code>相似。<br>利用<code>reduce</code>实现<code>compose</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">  return args.reduceRight((pre, cur, i) =&gt; &#123;</span><br><span class="line">    console.log(pre, cur, i)</span><br><span class="line">    return cur(pre)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助科里化封装得更加灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">window.renderIndex = compose(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure><p>利用<code>lodash.js</code>中是的<code>flowRight</code>来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES6 模块化语法，引入flowRight函数</span><br><span class="line">import flowRight from &apos;lodash/flowRight&apos;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// ES6模块化语法 对外暴露接口</span><br><span class="line">export default flowRight(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure><p>参考<br><a href="https://www.yuque.com/coreadvance/kagkke/bnk7g4" target="_blank" rel="noopener">高阶函数</a><br><a href="https://www.yuque.com/coreadvance/kagkke/zn7kz1" target="_blank" rel="noopener">代码组合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg2.jpg&quot; alt=&quot;高阶函数&quot;&gt;&lt;br&gt;高阶函数以及多个高阶函数嵌套&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-科里化</title>
    <link href="https://dorisfeng.github.io/2020/11/06/JS-%E7%A7%91%E9%87%8C%E5%8C%96/"/>
    <id>https://dorisfeng.github.io/2020/11/06/JS-科里化/</id>
    <published>2020-11-06T01:47:26.000Z</published>
    <updated>2020-11-07T08:24:32.710Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/bg1.jpg" alt="科里化"><br>科里化的简单应用</p><a id="more"></a><p>科里化是将一个函数所需要的多个参数分开传入函数中，每次调用会返回一个新函数，用于处理剩余参数。<br>所以将一个函数科里化的过程就是收集函数参数的过程，递归搜集参数，收集完成后，在最深层计算结果并返回。</p><h2 id="科里化通用式"><a href="#科里化通用式" class="headerlink" title="科里化通用式"></a>科里化通用式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createCurry(fn,restLen,args)&#123;</span><br><span class="line">    restLen=restLen||fn.length;</span><br><span class="line">    args=args||[];</span><br><span class="line">    const wrapper=function()&#123;</span><br><span class="line">        let _args=[].slice.call(arguments);</span><br><span class="line">        [].push.call(args,_args);</span><br><span class="line">        if(restLen&gt;_args.length)&#123;</span><br><span class="line">            restLen-=_args.length;</span><br><span class="line">            return wrapper(fn,restLen,args)</span><br><span class="line">        &#125;</span><br><span class="line">        return fn.apply(fn,args)</span><br><span class="line">    &#125;</span><br><span class="line">    return wrapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>验证手机号码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkPhone(phoneNumber)&#123;</span><br><span class="line">    return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用科里化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function check(reg,targetString)&#123;</span><br><span class="line">    return reg.test(targetString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _check = createCurry(check);</span><br><span class="line"></span><br><span class="line">var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);</span><br><span class="line">var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(&apos;183888888&apos;);</span><br><span class="line">checkEmail(&apos;xxxxx@test.com&apos;);</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>函数不定参数，解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let args=[1,2,3,4]</span><br><span class="line">add.apply(null,args)</span><br><span class="line">add(...args)</span><br></pre></td></tr></table></figure></li><li><p>函数隐式转换<br>当函数参与运算时，会默认调用 toString 方法，获取返回值，参与运算。<br>默认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a+1 //&quot;function a()&#123;&#125;1&quot;</span><br></pre></td></tr></table></figure><p>重写 toString 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a.toString=function()&#123;return 10&#125;</span><br><span class="line">a+1 //11</span><br><span class="line">a+&apos;1&apos; //&apos;11&apos;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>add</code>函数<br>实现一个 add 方法，使计算结果能够满足如下预期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">    let _args=[].slice.call(arguments);</span><br><span class="line">    const adder=function()&#123;</span><br><span class="line">        const _adder=function()&#123;</span><br><span class="line">            _args.push(...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">     _adder.toString=function()&#123;</span><br><span class="line">         return _args.reduce((a,b)=&gt;&#123;</span><br><span class="line">             return a+b</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     return _adder</span><br><span class="line">    &#125;</span><br><span class="line">    return adder(..._args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考：<br><a href="https://www.yuque.com/coreadvance/kagkke/iz3cdu" target="_blank" rel="noopener">科里化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/bg1.jpg&quot; alt=&quot;科里化&quot;&gt;&lt;br&gt;科里化的简单应用&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://dorisfeng.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云部署</title>
    <link href="https://dorisfeng.github.io/2020/10/28/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
    <id>https://dorisfeng.github.io/2020/10/28/阿里云部署/</id>
    <published>2020-10-28T06:49:50.000Z</published>
    <updated>2020-10-28T07:44:47.096Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下阿里云服务器部署 web 项目遇到的问题<br>因为只是要求 web 项目可以运行起来，总体很简单，卡在 FTP 上传文件上，先入为主，之前一直使用 FileZilla 部署，连接失败一直以为是这次的服务器配置有问题，没想到软件运行环境的问题。利用 win10 虚拟机安装了 FileZilla，测试正常。</p><a id="more"></a><h2 id="云服务器-ECS"><a href="#云服务器-ECS" class="headerlink" title="云服务器 ECS"></a>云服务器 ECS</h2><ul><li><p><strong>如何选择服务器配置</strong><br>本次为了熟悉部署步骤，使用的是 ECS 的体验版一个月（1vCPU 2GB）。<br><a href="https://help.aliyun.com/document_detail/58291.html?spm=a2c4g.11186623.2.20.240a5b73L2bPBY" target="_blank" rel="noopener">ECS 选型最佳实践</a><br>简单的企业官网选择 2 核 4G 或 2 核 8G 就可以，不确定选什么样的，可以先配最低的，后面再升级。</p></li><li><p><strong>创建实例</strong><br>购买之后，会默认生成一个实例，我是根据默认实例操作的，如果购买的配置较高，可以新建多个实例</p></li><li><p><strong>操作系统选择</strong><br>根据要配置的运行环境选择不同操作系统，后面可以修改。</p></li><li><p><strong>连接 ECS 实例</strong><br>Workbench 远程连接<br>使用 Linux 用户名密码连接，用户名默认 root，密码忘记了可以重置，如果要重新选择系统也要重置密码。<br><img src="/2020/10/28/阿里云部署/1.png" alt="重置密码"></p></li><li><p><strong>运行环境配置</strong><br><a href="https://help.aliyun.com/document_detail/57160.html?spm=a2c4g.11186623.6.1178.240a5b73L2bPBY" target="_blank" rel="noopener">自助建站方式汇总</a><br>比较熟悉的是 Node 环境，所有我配的是<a href="https://help.aliyun.com/document_detail/50775.html?spm=a2c4g.11186623.2.23.1d8679249RKC9e#concept-50775-zh" target="_blank" rel="noopener">部署 Node.js 环境（CentOS 7）</a><br>第一种方法 NVM 安装有问题，我采用第二种方法。</p><ol><li><p>下载安装包<br>提供的链接比较老，可以去 node 官网找最新的响应版本。<br>node 中文网-》下载-》阿里云镜像-》最新 linux64-》复制链接-》替换<br><code>wget https://npm.taobao.org/mirrors/node/v14.14.0/node-v14.14.0-linux-x64.tar.gz</code></p></li><li><p>解压<br><code>tar xvf node-v14.14.0-linux-x64.tar.gz</code></p></li><li><p>创建软链接，您就可以在任意目录下直接使用 node 和 npm 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><p>其中<code>/root</code>是文件下载或解压的所在路径，默认在<code>/root</code>下</p></li><li><p>查看版本</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><ol start="5"><li>如果需要将该软件安装到其他目录（例如：/opt/node/）下，请进行如下操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/node/</span><br><span class="line">mv /root/node-v14.14.0-linux-x64/* /opt/node/</span><br><span class="line">rm -f /usr/local/bin/node</span><br><span class="line">rm -f /usr/local/bin/npm</span><br><span class="line">ln -s /opt/node/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /opt/node/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><ol start="6"><li>安装 pm2<br>为了自动重启 Node 项目。<br><code>npm install pm2 -g</code><br>还可使用<br><code>wget -qO- https://getpm2.com/install.sh | bash</code><br>启动项目<br><code>pm2 start /var/ftp/test/index</code><br>启动 n 个进程，名字命名为 name。<br><code>pm2 start app.js -i [n] --name [name]</code><br>自启动（watch 的文件发生变化就会自启动）<br><code>pm2 start app.js --watch</code></li></ol></li><li><p><strong>上传项目到 ECS</strong><br>这个问题纠结了好几天，怎么配置我的 FileZilla 都不行，chrome 也没有上传按钮。最后在 win10 虚拟机上安装了一个 FileZilla，拖拽上传打包后的项目+nodeserver 就行了</p></li><li><p><strong>启动项目</strong><br><code>pm2 start /var/ftp/test/index</code><br>根据服务器启动的端口，配置安全组，我的服务是 8080 端口<br><img src="/2020/10/28/阿里云部署/2.png" alt="安全组"></p></li></ul><p>———撒花！撒花！完成了不知道能不能部署一个真的项目——–</p><h2 id="域名申请和绑定"><a href="#域名申请和绑定" class="headerlink" title="域名申请和绑定"></a>域名申请和绑定</h2><h2 id="公司邮箱"><a href="#公司邮箱" class="headerlink" title="公司邮箱"></a>公司邮箱</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下阿里云服务器部署 web 项目遇到的问题&lt;br&gt;因为只是要求 web 项目可以运行起来，总体很简单，卡在 FTP 上传文件上，先入为主，之前一直使用 FileZilla 部署，连接失败一直以为是这次的服务器配置有问题，没想到软件运行环境的问题。利用 win10 虚拟机安装了 FileZilla，测试正常。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GET和POST区别</title>
    <link href="https://dorisfeng.github.io/2020/08/20/GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/"/>
    <id>https://dorisfeng.github.io/2020/08/20/GET和POST区别/</id>
    <published>2020-08-20T02:30:27.000Z</published>
    <updated>2020-11-13T15:44:06.415Z</updated>
    
    <content type="html"><![CDATA[<p>GET 和 POST 核心机制与区别</p><a id="more"></a><h2 id="场景一：浏览器的-GET-和-POST"><a href="#场景一：浏览器的-GET-和-POST" class="headerlink" title="场景一：浏览器的 GET 和 POST"></a>场景一：浏览器的 GET 和 POST</h2><p>这里特指浏览器中非<code>Ajax</code>的<code>Http</code>请求，即<code>HTTP</code>协议中的<code>GET/POST</code>，浏览器用<code>GET</code>请求来获取一个<code>html</code>页面、图片、<code>css</code>、<code>js</code> 等资源，用<code>POST</code>请求提交一个<code>&lt;form&gt;</code>表单，并得到一个结果。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取资源，反复读取不会对访问的数据有副作用，没有副作用被称为‘幂等’。<br>因为 GET 是读取数据，就可以对 GET 请求的数据做缓存，缓存可以做到浏览器本身（彻底避免浏览器发请求），也可以做到代理上，或者 server 端。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>在页面里<code>&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; &gt;</code>标签会定义一个表单，点击其中的<code>submit</code>元素会发出一个<code>POST</code>请求让服务器做一件事。这件事往往是有副作用的，不幂等的。<br>不幂等就意味着不能随意多次执行，因此也不能缓存。</p><p><code>GET</code>和<code>POST</code>携带的数据格式也是有区别的，浏览器发出<code>GET</code>请求时分为两种情况，第一种用户自己在浏览器的地址栏输入，第二种点击<code>html</code>的<code>a</code>标签触发了<code>href</code>中的<code>url</code>。其实并不是<code>GET</code>只能用<code>url</code>,而是浏览器直接发出的<code>GET</code>只能由一个<code>url</code>触发。所以如果<code>GET</code>上要在<code>url</code>之外带一些参数就要依靠<code>querystring</code>。<br>浏览器的<code>POST</code>请求都来自表单提交，表单的数据被浏览器编码到 HTTP 请求的 body 里。两种编码方式：<code>application/x-www-form-urlencoded</code>用来传输简单数据，例如：”key1=value1&amp;key2=value2”,<code>multipart/form-data</code>用来传输文件。<br>浏览器在<code>POST</code>表单数据时，也可以带上参数，直接写在<code>action</code>的<code>url</code>里。<br>一般说“<code>GET</code>请求没有<code>body</code>，只有<code>url</code>，请求数据放在<code>url</code>的<code>querystring</code>中；<code>POST</code>请求的数据在<code>body</code>中“。但这种情况仅限于浏览器发请求的场景。</p><h2 id="接口中的-GET-和-POST"><a href="#接口中的-GET-和-POST" class="headerlink" title="接口中的 GET 和 POST"></a>接口中的 GET 和 POST</h2><p>这里指通过浏览器的<code>Ajax api</code>，或者<code>iOS/Android</code>的<code>App</code>的<code>http client</code>，<code>java</code> 的<code>commons-httpclient/okhttp</code>或者是<code>curl</code>，<code>postman</code>之类的工具发出来的<code>GET</code>和<code>POST</code>请求。此时 GET/POST 不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种 RPC 协议使用）。<br>REST 接口规范、风格，约定了<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>，这 4 个接口获取、创建、替换、删除，<code>REST</code>最佳实践还推荐在请求体使用<code>JSON</code>格式。<br><code>JSON</code>相对于<code>x-www-form-urlencoded</code>的优势在于: 1. 嵌套结构 2. 可以支持更丰富的数据类型。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>因为 POST 用 body 传输数据，而 GET 用 url 传输，更容易看到，所以 GET 更不安全。但是从攻击角度，无论是 GET 还是 POST 都不够安全，因为 HTTP 本身时明文协议，每个 HTTP 请求和返回的每个 byte 都会在网络上明文传输，不论是 url,header 或 body。<br>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是 https</p><h2 id="通常区别"><a href="#通常区别" class="headerlink" title="通常区别"></a>通常区别</h2><p><a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">参考</a></p><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被存为标签，而 POST 不可以。</li><li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li></ul><h2 id="实际区别"><a href="#实际区别" class="headerlink" title="实际区别"></a>实际区别</h2><p>没有区别，底层都是<code>TCP/IP</code>,并无差别。但是由于<code>HTTP</code> 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br><code>Get</code> 请求也可以传输 <code>body</code>，只不过有些服务器直接忽略，浏览器限制 <code>URL</code> 大小 2k，服务器 64k。</p><p>区别：<code>GET</code> 产生一个 <code>TCP</code> 数据包；<code>POST</code> 产生两个 <code>TCP</code> 数据包。</p><p>对于 GET 方式的请求，浏览器会把 <code>http header</code> 和 <code>data</code> 一并发送出去，服务器响应 200（返回数据）；</p><p>而对于 <code>POST</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送 <code>data</code>，服务器响应 200 ok（返回数据）。</p><h2 id="为什么不能使用-GET-代替-POST"><a href="#为什么不能使用-GET-代替-POST" class="headerlink" title="为什么不能使用 GET 代替 POST"></a>为什么不能使用 GET 代替 POST</h2><ol><li>GET 与 POST 都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。</li></ol><h2 id="为什么不能使用-POST-代替-GET"><a href="#为什么不能使用-POST-代替-GET" class="headerlink" title="为什么不能使用 POST 代替 GET"></a>为什么不能使用 POST 代替 GET</h2><ul><li>POST 发送两次包</li><li>POST 不能自动被浏览器缓存</li><li>POST 不能存为书签</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GET 和 POST 核心机制与区别&lt;/p&gt;
    
    </summary>
    
      <category term="网络请求" scheme="https://dorisfeng.github.io/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>ES10</title>
    <link href="https://dorisfeng.github.io/2020/08/19/ES10/"/>
    <id>https://dorisfeng.github.io/2020/08/19/ES10/</id>
    <published>2020-08-19T02:58:37.000Z</published>
    <updated>2020-08-19T06:41:16.872Z</updated>
    
    <content type="html"><![CDATA[<p>ES2019</p><a id="more"></a><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat()/flatMap()"></a><code>Array.prototype.flat()/flatMap()</code></h2><p><code>flat()</code>根据传入参数，深度递归遍历数组，并将所有元素与遍历的子数组中的元素合并为一个新数组返回。<br><code>flatMap()</code>与<code>map()</code>方法的深度为 1 的<code>flat()</code>几乎相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4]</span><br><span class="line">let arr2 = arr1.map(x =&gt; [x * 2]) // [[2], [4], [6], [8]]</span><br><span class="line">let arr3 = arr2.flatMap(x =&gt; x) // [2, 4, 6, 8]</span><br><span class="line">let arr4 = arr2.flatMap(x =&gt; [x]) // [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure><h2 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()"></a><code>String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()</code></h2><p>在 ES5 中，可以通过 trim()来去掉字符首尾的空格。<br>ES10 之后可以使用<code>trimStart()/trimLeft()</code>去掉开头的空格。<br><code>trimEnd()/trimRight()</code>去掉结尾的空格。<br>不过这里有一点要注意的是，<code>trimStart()</code>跟 <code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟 <code>trimRight()</code>只是别名。</p><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a><code>Object.fromEntries()</code></h2><p>把键值对列表转换为一个对象，是<code>Object.entries()</code>的反函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const entries = new Map([</span><br><span class="line">    [&apos;foo&apos;, &apos;bar&apos;],</span><br><span class="line">    [&apos;baz&apos;, 42]</span><br><span class="line">])</span><br><span class="line">const obj = Object.fromEntries(entries)</span><br><span class="line">console.log(obj) //&#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a><code>Symbol.prototype.description</code></h2><p>只读属性，返回<code>Symbol</code>对象的可选描述的字符串。与<code>Symbol.prototype.toString()</code>不同的是，它不会包含<code>Symbol</code>的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol(&apos;desc&apos;).toString()); // &quot;Symbol(desc)&quot;</span><br><span class="line">console.log(Symbol(&apos;desc&apos;).description); // &quot;desc&quot;</span><br><span class="line">console.log(Symbol(&apos;&apos;).description); // &quot;&quot;</span><br><span class="line">console.log(Symbol().description); // undefined</span><br><span class="line">console.log(Symbol.iterator.toString()); // &quot;Symbol(Symbol.iterator)&quot;</span><br><span class="line">console.log(Symbol.iterator.description); // &quot;Symbol.iterator&quot;</span><br></pre></td></tr></table></figure><h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a><code>String.prototype.matchAll</code></h2><p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regexp = /t(e)(st(\d?))/g</span><br><span class="line">var str = &apos;test1test2&apos;;</span><br><span class="line">console.log(str.match(regexp)); // [&apos;test1&apos;, &apos;test2&apos;]</span><br><span class="line">console.log(str.matchAll(regexp)); // RegExpStringIterator &#123;&#125;</span><br><span class="line">console.log([...str.matchAll(regexp)])</span><br><span class="line">// [[&apos;test1&apos;, &apos;e&apos;, &apos;st1&apos;, &apos;1&apos;, index: 0, input: &apos;test1test2&apos;, length: 4], [&apos;test2&apos;, &apos;e&apos;, &apos;st2&apos;, &apos;2&apos;, index: 5, input: &apos;test1test2&apos;, length: 4]]</span><br></pre></td></tr></table></figure><h2 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString()返回注释与空格"></a><code>Function.prototype.toString()</code>返回注释与空格</h2><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从 ES10 开始会保留这些空格，如果是原生函数则返回你控制台看到的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum.toString())</span><br><span class="line">// &quot;function sum(a, b) &#123;</span><br><span class="line">//         return a + b;</span><br><span class="line">//  &#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><code>try-catch</code></h2><p>以往版本中，<code>try-catch</code>里的<code>catch</code>后面必须带异常参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES10之前</span><br><span class="line">try &#123;</span><br><span class="line">// tryCode</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">// catchCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 ES10 之后，这个参数却不是必须的，如果用不到，我们可以不用传。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(&apos;Foobar&apos;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    console.error(&apos;Bar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><p>内置对象，提供一种方法表示大于 2^53-1 的整数。<code>BigInt</code>可以表示任意大的整数。<br>定义<code>BigInt</code>：<code>10n</code>或<code>BigInt()</code><br>以下操作符可以和<code>BigInt</code>一起使用：<code>+</code>,<code>-</code>,<code>*</code>,<code>**</code>,<code>%</code>。除<code>&gt;&gt;&gt;</code>(无符号右移)之外的位操作符也可以支持。因为<code>BigInt</code>都是有符号的，<code>&gt;&gt;&gt;</code>（无符号右移）不能用于<code>BigInt</code>。<code>BigInt</code>不支持单目 (+) 运算符。<br><code>/</code>操作符对于整数的运算也没问题。可是因为这些变量是<code>BigInt</code>而不是<code>BigDecimal</code>，该操作符结果会向零取整，也就是说不会返回小数部分。<br><code>BigInt</code>和<code>Number</code>不是严格相等的，但是宽松相等的。</p><p>所以在<code>BigInt</code>出来以后，JS 的原始类型便增加到了 7 个，如下：</p><ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol (ES6)</code></li><li><code>BigInt (ES10)</code></li></ul><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a><code>globalThis</code></h2><p>包含类似于全局对象<code>this</code>值，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis === this // true</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import()"></a><code>import()</code></h2><p>静态的<code>import</code>语句用于导入由另一个模块导出的绑定。无论是否声明了严格模式，导入的模块都运行在严格模式下。<br>在浏览器中，<code>import</code>语句只能在声明了<code>type=&#39;module&#39;</code>的<code>script</code>的标签中使用。<br>但是在 ES10 之后，我们有动态<code>import()</code>，它不需要依赖<code>type=&quot;module&quot;</code>的<code>script</code>标签。</p><h2 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Counter extends HTMLElement &#123;</span><br><span class="line">    #xValue = 0</span><br><span class="line"></span><br><span class="line">    get #x() &#123;</span><br><span class="line">        return #xValue</span><br><span class="line">    &#125;</span><br><span class="line">    set #x(value) &#123;</span><br><span class="line">        this.#xValue = value</span><br><span class="line">        window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #clicked() &#123;</span><br><span class="line">        this.#x++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.onclick = this.#clicked.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">            this.#render()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #render() &#123;</span><br><span class="line">        this.textContent = this.#x.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.customElements.define(&apos;num-counter&apos;, Counter)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2019&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>ES8</title>
    <link href="https://dorisfeng.github.io/2020/08/18/ES8/"/>
    <id>https://dorisfeng.github.io/2020/08/18/ES8/</id>
    <published>2020-08-18T02:12:10.000Z</published>
    <updated>2020-08-19T06:37:09.059Z</updated>
    
    <content type="html"><![CDATA[<p>ES2017</p><a id="more"></a><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h2><p><a href="https://dorisfeng.github.io/2020/06/22/JS-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a></p><h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a><code>Object.values()</code></h2><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a><code>Object.entries()</code></h2><h2 id="padStart-len-s"><a href="#padStart-len-s" class="headerlink" title="padStart(len,s)"></a><code>padStart(len,s)</code></h2><p>用另一个字符串从开始位置填充当前字符串，使产生的字符串达到给定长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let last4 = ID.slice(-4)</span><br><span class="line">let new_ID = last4.padStart(ID.length, &apos;*&apos;);</span><br><span class="line">console.log(new_ID);//**************3529</span><br></pre></td></tr></table></figure><h2 id="padEnd-len-s"><a href="#padEnd-len-s" class="headerlink" title="padEnd(len,s)"></a><code>padEnd(len,s)</code></h2><p>在末尾填充，规则跟<code>padStart</code>的一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let first3 = ID.slice(0, 3)</span><br><span class="line">let new_ID = first3.padEnd(ID.length, &apos;*&apos;);</span><br></pre></td></tr></table></figure><h2 id="函数参数逗号结尾"><a href="#函数参数逗号结尾" class="headerlink" title="函数参数逗号结尾"></a>函数参数逗号结尾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 参数定义</span><br><span class="line">function f(p) &#123;&#125;</span><br><span class="line">function f(p,) &#123;&#125;</span><br><span class="line"></span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果没有参数就只有逗号会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 带有尾后逗号的数组解构</span><br><span class="line">[a, b,] = [1, 2]</span><br><span class="line"></span><br><span class="line">// 带有尾后逗号的对象解构</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 42,</span><br><span class="line">  q: true,</span><br><span class="line">&#125;</span><br><span class="line">var &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure><p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...b,] = [1, 2, 3] // SyntaxError: rest element may not have a trailing comma</span><br></pre></td></tr></table></figure><h2 id="ShareArrayBuffer"><a href="#ShareArrayBuffer" class="headerlink" title="ShareArrayBuffer"></a><code>ShareArrayBuffer</code></h2><p>因安全性问题，暂时在 Chrome 和 FireFox 中被禁用。<br>用来表示一个通用的、固定长度的原始二进制缓冲区，类似 ArrayBuffer 对象。它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，ShareArrayBuffer 不能被分离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sab=new SharedArrayBuffer(1024);</span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure><h2 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a><code>Atomics</code>对象</h2><p>对<code>ShareArrayBuffer</code>对象进行原子操作。</p><ul><li><code>Atomics.add()</code>，将指定位置上的数组元素与给定的值相加并返回该元素更新前的值。</li><li><code>Atomics.compareExchange()</code>，如果数组中指定的元素与给定的值相等，将其更新为新的值，并返回该元素更新前的值。</li><li><code>Atomics.exchange()</code>，将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</li><li><code>Atomics.load()</code>，返回数组中指定元素的值</li><li><code>Atomics.or()</code>，将指定位置上的数组元素与给定的值相或，并返回该元素更新前的值。</li><li><code>Atomics.store()</code>，将数组中指定的元素设置为给定的值，返回该值。</li><li><code>Atomics.sub()</code>，将指定位置上的数组元素与给定的值相减，并返回该元素更新前的值。</li><li><code>Atomics.xor()</code>，将指定位置上的数组元素与给定的值相异或，并返回该元素更新前的值。</li><li><code>Atomics.wait()</code>，检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</li><li><code>Atomics.wake()</code>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</li><li><code>Atomics.isLockFree(size)</code>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</li></ul><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>获取一个对象的所有自身属性的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">    property1: 42</span><br><span class="line">&#125;</span><br><span class="line">const descriptors1 = Object.getOwnPropertyDescriptors(object1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2017&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>ES7</title>
    <link href="https://dorisfeng.github.io/2020/08/18/ES7/"/>
    <id>https://dorisfeng.github.io/2020/08/18/ES7/</id>
    <published>2020-08-18T01:55:25.000Z</published>
    <updated>2020-08-19T06:37:04.525Z</updated>
    
    <content type="html"><![CDATA[<p>ES2016</p><a id="more"></a><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a><code>Array.prototype.includes()</code></h2><p>用来判断一个数组是否包含指定值，如果包含返回 true，否则返回 false。</p><h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a><code>幂运算符**</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2**10; //1024</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><code>模板字符串</code></h2><ul><li><code>Unicode</code>字符以<code>\u</code>开头，例如<code>\u00A9</code>,”©”</li><li><code>Unicode</code>码位用<code>\u{}</code>表示，例如<code>\u{2F804}</code>,’你’</li><li>十六进制以<code>\x</code>开头，例如<code>\xA9</code>,”©”</li><li>八进制以<code>\</code>和数字开头，例如<code>\251</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2016&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>IE兼容性问题</title>
    <link href="https://dorisfeng.github.io/2020/08/13/IE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://dorisfeng.github.io/2020/08/13/IE兼容性问题/</id>
    <published>2020-08-13T05:30:40.000Z</published>
    <updated>2020-08-13T05:30:40.231Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html5-canvas动画</title>
    <link href="https://dorisfeng.github.io/2020/07/29/html5-canvas%E5%8A%A8%E7%94%BB/"/>
    <id>https://dorisfeng.github.io/2020/07/29/html5-canvas动画/</id>
    <published>2020-07-29T15:02:19.000Z</published>
    <updated>2020-07-31T08:06:46.042Z</updated>
    
    <content type="html"><![CDATA[<p>canvas 动画</p><a id="more"></a><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><ol><li><strong>清空 canvas</strong><br>除非接下来要画的内容会完全充满<code>canvas</code>(例如背景图)，否则你需要清空所有。最简单使用<code>clearRect</code>方法。</li><li><strong>保存 canvas 状态</strong><br>如果你改变一些会改变 canvas 状态的设置，又要在每画一帧之时都是原始状态的话，需要先保存一下。</li><li><strong>绘制动画图形 animated shapes</strong><br>重绘动画帧</li><li><strong>恢复 canvas 状态</strong><br>如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</li></ol><h2 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h2><ul><li><code>setInterval(fun,delay)</code><br>延迟 delay 毫秒后执行函数</li><li><code>setTimeout(func,delay)</code><br>间隔 delay 毫秒执行函数</li><li><code>requestAnimationFrame(callback)</code><br>告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">  function init() &#123;</span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let ctx = document.getElementById(&apos;my_canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">    ctx.save()</span><br><span class="line">    ctx.clearRect(0, 0, 400, 400);</span><br><span class="line"></span><br><span class="line">    //每个间隔弧度</span><br><span class="line">    let angle = 2 * Math.PI / 60;</span><br><span class="line"></span><br><span class="line">    function drawBorder() &#123;</span><br><span class="line">        ctx.save(); //1</span><br><span class="line">        ctx.strokeStyle = &apos;#3D5F9D&apos;;</span><br><span class="line">        ctx.lineWidth = 6;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(200, 200, 150, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSplit() &#123;</span><br><span class="line">        ctx.save()</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        //分隔</span><br><span class="line">        for (let i = 1; i &lt;= 60; i++) &#123;</span><br><span class="line">            ctx.rotate(angle);</span><br><span class="line">            ctx.lineCap = &apos;round&apos;;</span><br><span class="line">            ctx.strokeStyle = &apos;#000&apos;;</span><br><span class="line">            ctx.lineWidth = 4;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            if (i % 5) &#123;</span><br><span class="line">                ctx.moveTo(0, -127);</span><br><span class="line">                ctx.lineTo(0, -130);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.moveTo(0, -120);</span><br><span class="line">                ctx.lineTo(0, -132);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.stroke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawHour(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //时针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 7;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -90)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawMinute(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //分针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 4;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -125)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSecond(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //秒针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 3;</span><br><span class="line">        ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -112);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, -120, 7, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    //中心</span><br><span class="line">    function drawCenter() &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.fillStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, 0, 5, 0, 2 * Math.PI);</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算角度</span><br><span class="line">    let date = new Date();</span><br><span class="line">    let hour = date.getHours() % 12;</span><br><span class="line">    let minutes = date.getMinutes();</span><br><span class="line">    let seconds = date.getSeconds();</span><br><span class="line">    let second_ag = seconds * angle;</span><br><span class="line">    let minute_ag = (minutes * angle + second_ag / 60) * 5;</span><br><span class="line">    let hour_ag = (hour * angle + minute_ag / 60) * 5;</span><br><span class="line">    drawBorder()</span><br><span class="line">    drawSplit()</span><br><span class="line">    drawHour(hour_ag)</span><br><span class="line">    drawMinute(minute_ag)</span><br><span class="line">    drawSecond(second_ag)</span><br><span class="line">    drawCenter()</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p><img src="/2020/07/29/html5-canvas动画/_posts/html5-canvas动画/img1.png" alt="时钟"></p><h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><p>有兴趣的时候来补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas 动画&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-canvas基础</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-canvas%E5%9F%BA%E7%A1%80/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-canvas基础/</id>
    <published>2020-07-23T08:57:20.000Z</published>
    <updated>2020-07-29T15:01:18.155Z</updated>
    
    <content type="html"><![CDATA[<p>canvas 用法</p><a id="more"></a><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;my_canvas&quot; width=&quot;500px&quot; height=&quot;500px&quot; &gt;</span><br><span class="line">    您的浏览器不支持canvas，请升级您的浏览器！</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><ol><li><code>canvas</code>为替换内容，如果浏览器不支持<code>canvas</code>，就会显示元素内部的内容</li><li><code>width</code>、<code>height</code>都是可选属性，用于定义<code>canvas</code>的宽高。默认宽高为<code>300px*150px</code>。</li><li><code>id</code>属性用于绘制时，找到该画布。</li></ol><h3 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h3><p><code>canvas</code>元素的<code>getContext()</code>方法可以获取渲染上下文和绘功能，参数’2d’表示开启 2D 绘图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let my_canvas=document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">let ctx=canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure><p>检查 JS 的支持性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(my_canvas.getContext)&#123;</span><br><span class="line">    let ctx=my_canvas.getContext(&apos;2d&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //不支持canvas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p><strong>矩形</strong></p><ul><li><code>fillRect(x,y,width,height)</code> 绘制填充矩形</li><li><code>strokeRect(x,y,width,height)</code> 绘制描边矩形</li><li><code>clearRect(x,y,width,height)</code> 清除指定矩形区域，让清除部分完全透明<br><code>x,y</code>指画布上所绘制矩形的左上角（相对于画布的左上角（0，0））<br><code>width,height</code>设置矩形的尺寸</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(10, 10, 100, 100);</span><br><span class="line">    ctx.clearRect(20, 20, 80, 80);</span><br><span class="line">    ctx.strokeRect(40, 40, 40, 40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img1.png" alt="矩形"></p><p><strong>路径/直线</strong></p><ul><li><code>beginPath()</code> 开始一条新路径</li><li><code>closePath()</code> 闭合路径，会自动将起点和终点连接起来，如果不需要连接，可以不使用。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</li><li><code>stroke()</code> 绘制图形轮廓</li><li><code>fill()</code> 填充路径内容区域的生成的实心图形</li><li><code>moveTo()</code> 将笔触移动到指定的坐标<code>(x,y)</code>上</li><li><code>lineTo()</code> 绘制一条从当前位置到坐标<code>(x,y)</code>上的直线</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(20, 20);</span><br><span class="line">    ctx.lineTo(100, 20);</span><br><span class="line">    ctx.lineTo(100, 100);</span><br><span class="line">    ctx.closePath()</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(150, 20);</span><br><span class="line">    ctx.lineTo(230, 20)</span><br><span class="line">    ctx.lineTo(230, 100)</span><br><span class="line">    ctx.fill()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img2.png" alt="三角形"></p><p><strong>圆弧</strong></p><ul><li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code><br>画一个以<code>(x,y)</code>为圆心，以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认顺时针）来生成。</p><ul><li><code>startAngle</code>以及<code>endAngle</code>参数用弧度定义了开始以及结束的弧度，都是以<code>x</code>轴为基准。<br>单位是弧度不是角度，<code>弧度=(Math.PI/180)*角度</code></li><li><code>anticlockwise</code>为<code>true</code>是逆时针，否则为顺时针</li></ul></li><li><p><code>arcTo(x1,y1,x2,y2,radius)</code><br>从坐标<code>(x1,y1)</code>到坐标<code>(x2,y2)</code>以半径 radius 画一段圆弧，再以直线连接两个控制点。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    let endAngle = (Math.PI / 180) * 360;</span><br><span class="line">    ctx.arc(30, 30, 20, 0, endAngle);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.closePath();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(60, 20); // 创建开始点</span><br><span class="line">    ctx.lineTo(100, 20); // 创建水平线</span><br><span class="line">    ctx.arcTo(150, 20, 150, 70, 50); // 创建弧</span><br><span class="line">    ctx.lineTo(150, 100); // 创建垂直线</span><br><span class="line">    ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img3.png" alt="圆弧"></p><p><strong>贝塞尔曲线</strong></p><ul><li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code><br>二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点</li><li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code><br>三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点一，<code>x,y</code>为结束点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 25);</span><br><span class="line">    ctx.quadraticCurveTo(25, 25, 25, 62.5);</span><br><span class="line">    ctx.quadraticCurveTo(20, 130, 75, 130);</span><br><span class="line">    ctx.quadraticCurveTo(75, 160, 65, 160)</span><br><span class="line">    ctx.quadraticCurveTo(80, 160, 100, 130)</span><br><span class="line">    ctx.quadraticCurveTo(160, 130, 150, 62.5)</span><br><span class="line">    ctx.quadraticCurveTo(150, 20, 75, 25)</span><br><span class="line">    ctx.stroke()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img4.png" alt="二次贝塞尔"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 40);</span><br><span class="line">    ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);</span><br><span class="line">    ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5)</span><br><span class="line">    ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);</span><br><span class="line">    ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);</span><br><span class="line">    ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);</span><br><span class="line">    ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img5.png" alt="三次贝塞尔"></p><h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3><p>返回一个初始化的 Path2D 对象，参数可以是一个路径或 SVG path 数据的字符串，就是创建参数的副本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Path2D();</span><br><span class="line">new Path2D(path); //克隆Path对象</span><br><span class="line">new Path2D(svg);  //从svg建立Path对象</span><br></pre></td></tr></table></figure><p><code>path2D.addPath(path[,transform])</code>也可以给对象添加新路径或变化矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let rectangle = new Path2D()</span><br><span class="line">    rectangle.rect(10, 10, 50, 50)</span><br><span class="line"></span><br><span class="line">    let circle = new Path2D()</span><br><span class="line">    circle.moveTo(125, 35);</span><br><span class="line">    circle.arc(100, 35, 25, 0, 2 * Math.PI)</span><br><span class="line">    ctx.stroke(rectangle);</span><br><span class="line">    ctx.fill(circle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img6.png" alt="Path2D"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</span><br><span class="line">    ctx.stroke(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img7.png" alt="Path2D1"></p><h3 id="样式和颜色"><a href="#样式和颜色" class="headerlink" title="样式和颜色"></a>样式和颜色</h3><ul><li><p>填充颜色<br><code>fillStyle=color</code>，设置图形的填充颜色</p></li><li><p>轮廓颜色<br><code>strokeStyle=color</code>，设置图形轮廓的颜色<br>默认填充颜色和轮廓颜色都是黑色（<code>&#39;#000&#39;</code>/<code>&#39;black&#39;</code>/<code>rgba(0,0,0,1)</code>）的。<code>color</code>可以是颜色值，渐变对象或图案对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;,0)`;</span><br><span class="line">            ctx.fillRect(j * 25, i * 25, 25, 25)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img8.png" alt="fillStyle"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.strokeStyle = `rgb(0,$&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;)`;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.arc(12.5 + j * 25, 12.5 + i * 25, 10, 0, 2 * Math.PI, true);</span><br><span class="line">            ctx.stroke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img9.png" alt="strokeStyle"></p><ul><li>透明度<br><code>globalAlpha=transparent</code><br>设置整个<code>canvas</code>里所有图形的透明度，范围是 0.0(完全透明)到 1.0(完全不透明)。<br>同样可以设置<code>strokeStyle</code>或<code>fillStyle</code>的值为透明度（<code>rgba</code>）的颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">  // 画背景</span><br><span class="line">  ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">  ctx.fillRect(0,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#6C0&apos;;</span><br><span class="line">  ctx.fillRect(75,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#09F&apos;;</span><br><span class="line">  ctx.fillRect(0,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#F30&apos;;</span><br><span class="line">  ctx.fillRect(75,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#FFF&apos;;</span><br><span class="line"></span><br><span class="line">  // 设置透明度值</span><br><span class="line">  ctx.globalAlpha = 0.2;</span><br><span class="line"></span><br><span class="line">  // 画半透明圆</span><br><span class="line">  for (var i=0;i&lt;7;i++)&#123;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(75,75,10+10*i,0,Math.PI*2,true);</span><br><span class="line">      ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img11.png" alt="globalAlpha"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    //背景</span><br><span class="line">    ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">    ctx.fillRect(0, 0, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#6C0&quot;;</span><br><span class="line">    ctx.fillRect(0, 50, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;;</span><br><span class="line">    ctx.fillRect(0, 100, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#F30&quot;;</span><br><span class="line">    ctx.fillRect(0, 150, 220, 50);</span><br><span class="line">    ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line"></span><br><span class="line">    //画透明度圆</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgba(255,255,255,$&#123;i*0.1&#125;)`;</span><br><span class="line">            ctx.fillRect(10 + i * 20, j * 50, 20, 50)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img10.png" alt="rgba"></p><ul><li><p>线型 line styles</p><ul><li><p><code>lineWidth=value</code>，设置线条宽度，默认为 1.0，必须为正数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(5 + i * 15, 5);</span><br><span class="line">        ctx.lineWidth = i + 1;</span><br><span class="line">        ctx.lineTo(5 + i * 15, 100);</span><br><span class="line">        ctx.stroke()</span><br><span class="line">        ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img12.png" alt="线宽"></p></li><li><p><code>lineCap=type</code>，设置线条末端样式</p><ul><li><code>butt</code>：默认，方头与辅助线齐平</li><li><code>round</code>：圆头，半径为宽度的一半</li><li><code>square</code>：方头，端点处加上了等宽且高度为一半线宽的方块。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      let lineCap = [&apos;butt&apos;, &apos;round&apos;, &apos;square&apos;];</span><br><span class="line">      //辅助线</span><br><span class="line">      ctx.strokeStyle = &apos;#09f&apos;;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.moveTo(10, 10);</span><br><span class="line">      ctx.lineTo(140, 10);</span><br><span class="line">      ctx.moveTo(10, 140);</span><br><span class="line">      ctx.lineTo(140, 140);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      //线条</span><br><span class="line">      ctx.strokeStyle = &apos;black&apos;;</span><br><span class="line">      for (let i = 0; i &lt; lineCap.length; i++) &#123;</span><br><span class="line">          ctx.lineWidth = 15;</span><br><span class="line">          ctx.lineCap = lineCap[i];</span><br><span class="line">          ctx.beginPath();</span><br><span class="line">          ctx.moveTo(30 + 40 * i, 10);</span><br><span class="line">          ctx.lineTo(30 + 40 * i, 140);</span><br><span class="line">          ctx.stroke();</span><br><span class="line">          ctx.closePath()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img13.png" alt="线头"></p><ul><li><code>lineJoin=type</code>，设定线条与线条间结合处的样式<ul><li><code>round</code>，</li><li><code>bevel</code>，</li><li><code>miter</code>，默认</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let lineJoin = [&apos;round&apos;, &apos;bevel&apos;, &apos;miter&apos;];</span><br><span class="line">    for (let i = 0; i &lt; lineJoin.length; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.lineWidth = 15;</span><br><span class="line">        ctx.lineJoin = lineJoin[i];</span><br><span class="line">        ctx.moveTo(20, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(70, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(120, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(170, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(220, 20 + i * 50);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.closePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img14.png" alt="交接处"></p><ul><li><code>miterLimit=value</code>，限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li><li><code>getLineDash()</code>，返回一个包含当前虚线的样式，长度为非负偶数的数组。</li><li><code>setLineDash(segments)</code>，设置当前虚线样式。</li><li><code>lineDashOffset=value</code>，设置虚线样式的起始偏移量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var offset = 0;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let my_canvas = document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">    if (my_canvas.getContext) &#123;</span><br><span class="line">        let ctx = my_canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        ctx.clearRect(0, 0, my_canvas.width, my_canvas.height);</span><br><span class="line">        ctx.setLineDash([4, 2]); //实线长度，空线长度</span><br><span class="line">        ctx.lineDashOffset = -offset;</span><br><span class="line">        ctx.strokeRect(10, 10, 100, 100);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //不支持canvas</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function march() &#123;</span><br><span class="line">    offset++;</span><br><span class="line">    if (offset &gt; 16) &#123;</span><br><span class="line">        offset = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">    setTimeout(march, 50);</span><br><span class="line">&#125;</span><br><span class="line">march();</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img15.png" alt="蚂蚁线"></p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ul><li><code>createLinearGradient(x1, y1, x2, y2)</code><br>渐变起点（x1,y1）终点（x2,y2);</li><li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code><br>定义两个圆：一个是小圆，是外面大圆的反光，以（x1,y1）为圆点，r1 为圆心，另一个以（x2,y2）为圆心，r2 为半径。</li><li><code>gradient.addColorStop(position, color)</code><br>给创建的渐变对象<code>gradient</code>上色，<br><code>position</code>：渐变颜色的所在位置，[0.0, 1.0]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let linegrad = ctx.createLinearGradient(0, 0, 0, 150);</span><br><span class="line">    linegrad.addColorStop(0, &apos;#00ABEB&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#fff&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#26C000&apos;);</span><br><span class="line">    linegrad.addColorStop(1, &apos;#fff&apos;);</span><br><span class="line">    let linegrad1 = ctx.createLinearGradient(0, 50, 0, 95);</span><br><span class="line">    linegrad1.addColorStop(0.5, &apos;#000&apos;);</span><br><span class="line">    linegrad1.addColorStop(1, &quot;rgba(0,0,0,0)&quot;)</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = linegrad;</span><br><span class="line">    ctx.strokeStyle = linegrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.strokeRect(50, 50, 50, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一是背景渐变，<br>第二种渐变不是从 0.0 开始的，所以 0-0.5 都是黑色的。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img16.png" alt="线性渐变色"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let radgrad = ctx.createRadialGradient(45, 55, 10, 52, 50, 30);</span><br><span class="line">    radgrad.addColorStop(0, &apos;#47d30C&apos;);</span><br><span class="line">    radgrad.addColorStop(0.9, &apos;#019F62&apos;);</span><br><span class="line">    radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);</span><br><span class="line"></span><br><span class="line">    let radgrad1 = ctx.createRadialGradient(95, 15, 15, 102, 20, 40);</span><br><span class="line">    radgrad1.addColorStop(0, &apos;#00C9FF&apos;)</span><br><span class="line">    radgrad1.addColorStop(0.8, &apos;#00B5E2&apos;)</span><br><span class="line">    radgrad1.addColorStop(1, &apos;rgba(0,201,255,0)&apos;);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img17.png" alt="镜像渐变色"></p><h3 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h3><ul><li><code>createPattern(image,type)</code><ul><li><code>image</code>：是一个<code>image</code>对象的引用，或另一个<code>canvas</code>对象。</li><li><code>type</code>：<code>repeat</code>，<code>repeat-x</code>,<code>repeat-y</code>,<code>no-repeat</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        //创建图案</span><br><span class="line">        let ptrn = ctx.createPattern(img, &apos;repeat&apos;);</span><br><span class="line">        ctx.fillStyle = ptrn;</span><br><span class="line">        ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img18.png" alt="图片"></p><h3 id="阴影-shadows"><a href="#阴影-shadows" class="headerlink" title="阴影 shadows"></a>阴影 shadows</h3><ul><li><code>shadowOffsetX=float</code></li><li><code>shadowOffsetY=float</code><br><code>shadowOffsetX</code> 和 <code>shadowOffsetY</code> 用来设定阴影在<code>X</code>和 <code>Y</code>轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li><li><code>shadowBlur=float</code><br>用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li><li><p><code>shadowColor=color</code><br>阴影颜色，默认是全透明的黑色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.shadowOffsetX = 2;</span><br><span class="line">    ctx.shadowOffsetY = 2;</span><br><span class="line">    ctx.shadowBlur = 2;</span><br><span class="line">    ctx.shadowColor = &quot;rgba(255,0,0,0.5)&quot;;</span><br><span class="line"></span><br><span class="line">    ctx.font = &apos;20px times New Roman&apos;;</span><br><span class="line">    ctx.fillStyle = &quot;black&quot;;</span><br><span class="line">    ctx.fillText(&apos;Sample String&apos;, 5, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/img19.png" alt="文字阴影"></p><h3 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h3><p>用<code>fill</code>,<code>clip</code>,<code>isPointinPath</code>填充，可以使用以下填充规则：</p><ul><li><code>nonzero</code>：non-zero winding rule,默认值</li><li><code>evenodd</code>：even-odd winding rule，颜色间隔出现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(50, 50, 50, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 30, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 10, 0, Math.PI * 2);</span><br><span class="line">    ctx.fill(&apos;evenodd&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img20.png" alt="填充规则"></p><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul><li><code>fillText(text,x,y[,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选。</li><li><p><code>strokeText(text, x, y [,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.font = &apos;48px serif&apos;</span><br><span class="line">    ctx.fillText(&apos;fillText&apos;, 10, 50);</span><br><span class="line">    ctx.strokeText(&apos;strokeText&apos;, 10, 90)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img21.png" alt="文本"></p><p><strong>文本样式</strong></p><ul><li><code>font=value</code><br>与 css 属性相同，默认<code>10px sans-serif</code></li><li><p><code>textAlign=value</code> , 文本对齐方式</p><ul><li><code>start</code>默认</li><li><code>end</code></li><li><code>left</code></li><li><code>right</code></li><li><code>center</code></li></ul></li><li><p><code>textBaseline=value</code>，基线对齐选项</p><ul><li><code>top</code></li><li><code>hanging</code></li><li><code>middle</code></li><li><code>alphabetic</code>默认</li><li><code>ideographic</code></li><li><code>bottom</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">      ctx.font = &apos;28px serif&apos;</span><br><span class="line">      ctx.moveTo(0, 40);</span><br><span class="line">      ctx.lineTo(650, 40);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      ctx.textBaseline = &apos;top&apos;</span><br><span class="line">      ctx.fillText(&apos;top&apos;, 10, 40);</span><br><span class="line">      ctx.textBaseline = &apos;middle&apos;</span><br><span class="line">      ctx.fillText(&apos;middle&apos;, 60, 40)</span><br><span class="line">      ctx.textBaseline = &apos;hanging&apos;</span><br><span class="line">      ctx.fillText(&apos;hanging&apos;, 160, 40)</span><br><span class="line">      ctx.textBaseline = &apos;alphabetic&apos;</span><br><span class="line">      ctx.fillText(&apos;alphabetic&apos;, 270, 40)</span><br><span class="line">      ctx.textBaseline = &apos;ideographic&apos;</span><br><span class="line">      ctx.fillText(&apos;ideographic&apos;, 410, 40)</span><br><span class="line">      ctx.textBaseline = &apos;bottom&apos;</span><br><span class="line">      ctx.fillText(&apos;bottom&apos;, 560, 40)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img22.png" alt="基线"></p><ul><li><p><code>direction=value</code>,文本方向</p><ul><li><code>ltr</code></li><li><code>rtl</code></li><li><code>inherit</code> 默认</li></ul></li><li><p>预测量文本宽度</p></li></ul><p><code>measureText()</code><br>返回有个<code>TextMwtrics</code>对象的宽度、所在像素</p><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><h4 id="获取图像源"><a href="#获取图像源" class="headerlink" title="获取图像源"></a>获取图像源</h4><ul><li><p>获得需要绘制的图片</p><ul><li><code>HTMLImageElement</code><br>由<code>Image()</code>函数构造出来的元素，或者<code>&lt;img&gt;</code>元素</li><li><code>HTMLVideoElement</code><br><code>&lt;video&gt;&lt;/video&gt;</code>元素，从视频中抓取当前帧作为一个图像</li><li><code>HTMLCanvasElement</code><br>使用另外一个<code>&lt;canvas&gt;&lt;/canvas&gt;</code>元素作为图片源</li><li><code>ImageBitmap</code><br>高性能位图，可以低延迟的绘制。，它可以从上述的所有源以及其它几种源中生成。</li></ul></li><li><p>使用相同页面内的图片</p><p>获取当前页面的图片引用：</p><ul><li><code>document.images</code>集合</li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementById()</code></li></ul></li><li><p>使用其他域名下的图片</p><p>如果图片允许跨域访问，可以正常渲染<code>canvas</code>，如果图片不允许跨域访问，会污染当前<code>canvas</code>.</p></li><li><p>使用其他 canvas 元素</p><p>获取 canvas 元素</p><ul><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementById()</code></li></ul></li><li><p>由零开始创建图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.onload=function()&#123;</span><br><span class="line">    //执行drawImage语句</span><br><span class="line">&#125;</span><br><span class="line">img.src=&apos;img.png&apos;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>data.url</code>方式嵌入图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.src = &apos;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用视频帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getMyVideo() &#123;</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">    return document.getElementById(&apos;myvideo&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><ul><li><p><code>drawImage(image,x,y)</code></p><ul><li><code>image</code>就是用上面的方法获取的图片源，SVG 图像必须在 <code>&lt;svg&gt;</code> 根指定元素的宽度和高度。</li><li><code>x</code>,<code>y</code>，绘制图片左上角在画布中的起始坐标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(30, 96);</span><br><span class="line">        ctx.lineTo(70, 66);</span><br><span class="line">        ctx.lineTo(102, 76);</span><br><span class="line">        ctx.lineTo(170, 15);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>drawImage(image,x,y,width,height)</code>;<br><code>width</code>和<code>height</code>用来控制当前<code>canvas</code>画入时应该缩放的大小</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                ctx.drawImage(img, j * 100, i * 80, 100, 80);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)</code><br>第一个参数同上还是图片源，<br>后面 8 个参数，前四个参数定义图像源的切片位置和大小，后四个定义切片的目标显示的位置和大小。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img23.jpg" alt="切片"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 300, 100, 1000, 1100, 10, 10, 200, 200)</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染 frame</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Draw frame</span><br><span class="line">  ctx.drawImage(document.getElementById(&apos;frame&apos;),0,0);</span><br></pre></td></tr></table></figure><ul><li>控制图像的缩放行为<br><code>mozImageSmoothingEnabled</code>,默认为<code>true</code>，为<code>false</code>时图像不会平滑的缩放。<br><code>ctx.mozImageSmoothingEnabled = false;</code></li></ul><h3 id="变形-Transformation"><a href="#变形-Transformation" class="headerlink" title="变形 Transformation"></a>变形 Transformation</h3><h4 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h4><ul><li><strong><code>save()</code></strong> 保存画布的现在的状态</li><li><strong><code>restore()</code></strong><br>恢复<code>canvas</code>状态。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 500, 500);</span><br><span class="line">    ctx.save(); //存储黑色矩形</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;</span><br><span class="line">    ctx.fillRect(50, 50, 400, 400)</span><br><span class="line"></span><br><span class="line">    ctx.save(); //存储蓝色矩形</span><br><span class="line">    ctx.fillStyle = &apos;white&apos;;</span><br><span class="line">    ctx.globalAlpha = 0.5;</span><br><span class="line">    ctx.fillRect(100, 100, 300, 300)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复蓝色矩形</span><br><span class="line">    ctx.fillRect(150, 150, 200, 200)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复黑色矩形</span><br><span class="line">    ctx.fillRect(200, 200, 100, 100)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img24.png" alt="保存状态"></p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul><li><strong><code>translate(x, y)</code></strong><br><code>x</code>为左右偏移量，<code>y</code>为上下偏移量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;51*i&#125;,$&#123;255-51*i&#125;,255)`;</span><br><span class="line">            ctx.translate(10 + j * 50, 10 + i * 50);</span><br><span class="line">            ctx.fillRect(0, 0, 25, 25);</span><br><span class="line">            ctx.restore()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img25.png" alt="移动"></p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul><li><strong><code>rotate(angle)</code></strong><br>角度<code>（angle）</code>是顺时针方向，以弧度为单位。<br>旋转的中心始终是<code>canvas</code>的原点<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img26.png" alt="旋转"></li></ul><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><strong><code>scale(x,y)</code></strong><br><code>x</code>为水平缩放，<code>y</code>为垂直缩放<br><code>x,y</code>都是实数，比 1 小会缩小图形，比 1 大会放大图片，默认为 1。<br>画布初始情况下， 是以左上角坐标为原点的第一象限。如果为负实数， <code>scale(-1,1)</code>以<code>y</code>轴作为对称轴镜像反转,<code>scale(1,-1)</code>以<code>x</code>轴作为对称轴镜像反转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    // //放大</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.scale(10, 3);</span><br><span class="line">    ctx.fillRect(1, 10, 10, 10);</span><br><span class="line">    ctx.restore();</span><br><span class="line"></span><br><span class="line">    // //镜像</span><br><span class="line">    ctx.scale(-1, 1);</span><br><span class="line">    ctx.font = &apos;48px serif&apos;;</span><br><span class="line">    ctx.fillText(&apos;MDN&apos;, -135, 120)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img27.png" alt="缩放"></p><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><ul><li><p><strong><code>transform(a,b,c,d,e,f)</code></strong><br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：$\left[ \begin{array}{ccc} a &amp; c &amp; e \ b &amp; d &amp; f \ 0 &amp; 0 &amp; 1 \end{array} \right]$</p><ul><li><code>a(m11)</code>: 水平方向的缩放</li><li><code>b(m12)</code>: 水平方向的倾斜偏移</li><li><code>c(m21)</code>: 竖直方向的倾斜偏移</li><li><code>d(m22)</code>: 竖直方向的缩放</li><li><code>e(m31)</code>: 水平方向的移动</li><li><code>f(m32)</code>: 竖直方向的移动</li></ul></li><li><p><strong><code>setTransform(a,b,c,d,e,f)</code></strong><br>将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。该方法是取消了当前变形,然后设置为指定的变形,一步完成。</p></li><li><strong><code>resetTransform()</code></strong><br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<code>ctx.setTransform(1, 0, 0, 1, 0, 0)</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let sin = Math.sin(Math.PI / 6);</span><br><span class="line">    let cos = Math.cos(Math.PI / 6);</span><br><span class="line">    ctx.translate(100, 100);</span><br><span class="line">    let c = 0;</span><br><span class="line">    for (let i = 0; i &lt;= 12; i++) &#123;</span><br><span class="line">        c = Math.floor(255 / 12 * i);</span><br><span class="line">        ctx.fillStyle = `rgb($&#123;c&#125;,$&#123;c&#125;,$&#123;c&#125;)`;</span><br><span class="line">        ctx.fillRect(0, 0, 100, 10);</span><br><span class="line">        ctx.transform(cos, sin, -sin, cos, 0, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.setTransform(-1, 0, 0, 1, 100, 100);</span><br><span class="line">    ctx.fillStyle = &apos;rgba(255,128,255,.5)&apos;;</span><br><span class="line">    ctx.fillRect(0, 50, 100, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img28.png" alt="转换"></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>globalCompositeOperation=type</code><br>设定新绘制图形与原图形的遮盖方式。<br>目标画布-已有，新图像</p><ul><li><code>source-over</code>：默认，在现有画布上下文之上绘制新图形。</li><li><code>source-in</code>：新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。</li><li><code>source-out</code>： 在不与现有画布内容重叠的地方绘制新图形，重叠部分是透明的。</li><li><code>source-atop</code>： 新图形只在与现有画布内容重叠的地方绘制，原有画布非重叠部分不变。</li><li><code>destination-over</code>： 在现有的画布内容后面绘制新的图形。</li><li><code>destination-in</code>： 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。</li><li><code>destination-out</code>：现有内容保持在新图形不重叠的地方，其他地方透明。</li><li><code>destination-atop</code>：现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。</li><li><code>lighter</code>：两个重叠图形的颜色是通过颜色值相加来确定的。</li><li><code>copy</code>：只显示新图形。</li><li><code>xor</code>：图像中，那些重叠和正常绘制之外的其他地方是透明的。</li><li><code>multiply</code>：将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。</li><li><code>screen</code>：像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。</li><li><code>overlay</code>：<code>multiply</code>和<code>screen</code>的结合，原本暗的地方更暗，原本亮的地方更亮。</li><li><code>darken</code>：保留两个图层中最暗的像素。</li><li><code>lighten</code>：保留两个图层中最亮的像素。</li><li><code>color-dodge</code>：将底层除以顶层的反置。</li><li><code>color-burn</code>：将反置的底层除以顶层，然后将结果反过来。</li><li><code>hard-light</code>：屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。</li><li><code>soft-light</code>：用顶层减去底层或者相反来得到一个正值。</li><li><code>difference</code>：一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。</li><li><code>exclusion</code>：和 difference 相似，但对比度较低。<br>…</li></ul><h3 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h3><p><code>clip()</code>将当前正在构建的路径转换为当前的裁剪路径。<br>默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.translate(75, 75);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(0, 0, 60, 0, Math.PI * 2, true);</span><br><span class="line">    ctx.clip();</span><br><span class="line">    //画圆形背景</span><br><span class="line">    let lingrad = ctx.createLinearGradient(0, -75, 0, 75);</span><br><span class="line">    lingrad.addColorStop(0, &quot;#232256&quot;);</span><br><span class="line">    lingrad.addColorStop(1, &quot;#143778&quot;);</span><br><span class="line">    ctx.fillStyle = lingrad;</span><br><span class="line">    ctx.fillRect(-75, -75, 150, 150);</span><br><span class="line">    //画星星</span><br><span class="line">    for (let j = 1; j &lt; 50; j++) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line">        ctx.translate(75 - Math.floor(Math.random() * 150), 75 - Math.floor(Math.random() * 150));</span><br><span class="line">        drawStar(ctx, Math.floor(Math.random() * 4) + 2);</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawStar(ctx, r) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(r, 0);</span><br><span class="line">        for (let i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            ctx.rotate(Math.PI / 5);</span><br><span class="line">            if (i % 2 === 0) &#123;</span><br><span class="line">                ctx.lineTo((r / 0.525731) * 0.200811, 0)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.lineTo(r, 0)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.closePath();</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img29.png" alt="星星"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas 用法&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-音视频处理</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-音视频处理/</id>
    <published>2020-07-23T07:06:29.000Z</published>
    <updated>2020-07-23T07:13:10.692Z</updated>
    
    <content type="html"><![CDATA[<p>html5 音视频标签使用</p><a id="more"></a><h3 id="音视频处理"><a href="#音视频处理" class="headerlink" title="音视频处理"></a>音视频处理</h3><ul><li><p>video</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">  &lt;source src=&apos;foo.ogg&apos; type=&apos;video/ogg&apos; /&gt;</span><br><span class="line">  &lt;source src=&apos;foo.mp4&apos; type=&apos;video/mp4&apos; /&gt;</span><br><span class="line">  浏览器不支持视频播放</span><br><span class="line">&lt;/video&gt;</span><br><span class="line">&lt;audio controls&gt;</span><br><span class="line">  &lt;source src=&quot;3.mp3&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.wav&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.ogg&quot;&gt;</span><br><span class="line">  浏览器不支持音频播放</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>width:宽度</li><li>height:高度</li><li>controls：播放控件</li><li>autoplay：视频加载完成后马上播放</li><li>loop：循环播放</li><li>muted：表示视频静音输出</li><li>poster：视频海报，用于在用户播放或跳帧之前展示，如果属性未指定，第一帧可用之前什么都不展示，之后第一帧就作为海报。</li><li>preload：预加载，<ul><li>none 不加载</li><li>auto (默认)自动（尽快加载完毕）</li><li>metadata 只加载除视频之外的信息（宽高）</li></ul></li></ul></li><li><p>audio<br>操作 DOM 方法</p><ul><li>play 开始播放</li><li>pause 暂停播放</li><li>error 媒体播放出错错误时触发</li><li>canPlayType(type)：查看浏览器是否支持这种文件格式的媒体文件。</li></ul></li></ul><p>操作 DOM 属性</p><ul><li>paused 是否处于暂停或者未播放状态</li><li>ended 是否已经结束播放</li><li>duration 返回媒体时长，秒为单位</li><li>currentTime 获取或设置媒体播放位置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;html5 音视频标签使用&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-语义化标签</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-语义化标签/</id>
    <published>2020-07-23T07:03:40.000Z</published>
    <updated>2020-11-16T14:21:32.595Z</updated>
    
    <content type="html"><![CDATA[<p>html 语义化标签</p><a id="more"></a><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>元素分类：</p><ul><li><p>块级元素</p><ul><li>独占一行</li><li>可以设置宽高</li><li>不设置宽度时，继承父元素宽度</li><li><p>不设置高度时，就是本身内容的高度</p><p>常用：<code>div</code>,<code>p</code>,<code>h1...h6</code>,<code>ul</code>,<code>ol</code>,<code>dl</code>,<code>form</code>,<code>section</code>,<code>nav</code>,<code>aside</code><br>转换成块级元素：<code>display:block</code></p></li></ul></li><li><p>行内块元素</p><ul><li>和其他行内元素和行内块元素在一行</li><li><p>元素的 width，height，padding，margin 可以设置</p><p>常用：<code>img</code>,<code>input</code>,<br>转换成行内块元素：<code>display:inline-block</code>，<code>float:left/right</code>，<code>position:absolute/fixed</code></p></li></ul></li><li><p>行内元素</p><ul><li>和其他行内元素和行内块元素在一行</li><li>元素的宽度就是他包含的文字和图片的宽度，不可改变。</li><li>元素高度 height 设置无效，可以设置 line-height</li><li>margin,padding 的上下对布局无效，左右可以。</li><li>内联元素只能包含文本、内联元素、行内块元素<br>常用：<code>span</code>,<code>a</code>,<code>br</code>,<code>em</code>,<code>strong</code><br>转换成行内元素：<code>display:inline</code></li></ul></li></ul><h3 id="语义化标签使得页面的内容结构化，见名知义"><a href="#语义化标签使得页面的内容结构化，见名知义" class="headerlink" title="语义化标签使得页面的内容结构化，见名知义"></a>语义化标签使得页面的内容结构化，见名知义</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>header</td><td>定义文档的头部</td></tr><tr><td>footer</td><td>定义文档的尾部</td></tr><tr><td>nav</td><td>定义文档的导航</td></tr><tr><td>section</td><td>定义文档中的节</td></tr><tr><td>article</td><td>定义页面独立的内容区域</td></tr><tr><td>aside</td><td>定义页面的侧边栏内容</td></tr><tr><td>keygen</td><td>用于表单的密钥对生成器</td></tr><tr><td>output</td><td>输出</td></tr></tbody></table><h3 id="重学前端——语义化标签"><a href="#重学前端——语义化标签" class="headerlink" title="重学前端——语义化标签"></a>重学前端——语义化标签</h3><ul><li><p>缩写 abbr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;</span><br></pre></td></tr></table></figure></li><li><p>分隔线<br>hr - 表示故事走向的转变或话题的转变<br>border - 纯粹的视觉效果</p></li><li><p>注释<br>p 标签+class=’note’</p></li><li><p>加粗<br>strong 表示文本十分重要<br>em 表示强调，可以嵌套，越多层级 表示更大程度的强调</p></li><li><p>引用</p></li><li>blockquote 表示段落级引述内容，</li><li>q 表示行内的引述内容</li><li>cite 表示引述的作品名</li><li><p>时间 time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;time datetime=&apos;2019-01-25&apos;&gt;25 Jan 2019&lt;/time&gt;</span><br></pre></td></tr></table></figure></li><li><p>文章中的图像<br>figure 用于表示与主文章相关的图像、照片等流内容<br>figcaption 照片图片的描述文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">    &lt;img src=&apos;http://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E6%96%B0%E9%B2%9C%E4%BA%8B&amp;tn=SE_PclogoS_8whnvm25&amp;sa=ire_dl_gh_logo&amp;rsv_dl=igh_logo_pcs&apos;&gt;</span><br><span class="line">    &lt;figcaption&gt;百度logo&lt;/figcaption&gt;</span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义 ghh<br>dfn 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The &lt;dfn&gt;Internet&lt;/dfn&gt; is balalalal</span><br></pre></td></tr></table></figure></li><li><p>固定格式</p><p>samp 计算机输出<br>pre 格式不根据浏览变化<br>code 代码段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">    &lt;code&gt;&gt;</span><br><span class="line">        &amp;lt;html&amp;gt;</span><br><span class="line">            &amp;lt;head&amp;gt;</span><br><span class="line">            &amp;lt;/head&amp;gt;</span><br><span class="line">            &amp;lt;body&amp;gt;</span><br><span class="line">            &amp;lt;/body&amp;gt;</span><br><span class="line">        &amp;lt;/html&amp;gt;</span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;html 语义化标签&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-表单元素</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-表单元素/</id>
    <published>2020-07-23T07:03:30.000Z</published>
    <updated>2020-07-23T08:45:31.614Z</updated>
    
    <content type="html"><![CDATA[<p>新增表单元素<br>兼容性存在问题，并且不同浏览器样式不同</p><a id="more"></a><h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><h3 id="新增输入类型"><a href="#新增输入类型" class="headerlink" title="新增输入类型"></a>新增输入类型</h3><p><strong><code>Input</code> 类型</strong></p><ul><li>email：电子邮件</li><li><p>tel：电话号码</p></li><li><p>url：网页的 url(需要 <code>http(s)://</code>)</p></li><li>search：搜索</li><li>range：数值控件。特定范围内的数值选择器</li><li>number：数字</li><li>date：日期，选取年、月、日</li><li>month：选取月、年</li><li>week：选取周和年</li><li>time：选取时间（小时和分钟）</li><li>datetime：选取时间、日、月、年（UTC 时间）</li><li>datetime-local：选取时间、日、月、年（本地时间）</li></ul><p>其中 range 和 number 还可以配合下面属性使用</p><ul><li>min：允许最小值</li><li>max：允许最大值</li><li>step：步数</li><li>value：默认值</li></ul><h3 id="新增表单元素"><a href="#新增表单元素" class="headerlink" title="新增表单元素"></a>新增表单元素</h3><ul><li><p>datalist<br>选择列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;url_list&quot;&gt;</span><br><span class="line">    &lt;option label=&quot;W3School&quot; value=&quot;http://www.W3School.com.cn&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure></li><li><p>keygen<br>提供一种验证用户的可靠方法。<br>密钥对生成器，提价表单时，生成一个私钥和一个公钥。<br>私钥（private key）存储于客户端，公钥（public key）被发送到服务器，公钥用于之后验证用户的客户端证书。<br>目前浏览器不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">  Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt;</span><br><span class="line">  Encryption: &lt;keygen name=&quot;security&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>output<br>用于不同类型的输出</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;output id=&apos;result&apos; onforminput=&apos;resCalc()&apos;&gt;&lt;/output&gt;</span><br></pre></td></tr></table></figure><h3 id="表单验证属性"><a href="#表单验证属性" class="headerlink" title="表单验证属性"></a>表单验证属性</h3><ol><li><p>pattern<br>属性确保值与正则表达式匹配<br>用于验证文本、链接、电话，邮件，密码等形式的输入元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">   &lt;label for=&quot;name&quot;&gt; Name: &lt;input type=&quot;text&quot; id=&quot;name&quot;</span><br><span class="line">     name=&quot;name&quot; pattern=&quot;^.* .*$&quot; /&gt;</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>确保用户输入两个名称，用空格分隔</p></li><li><p>min,max<br>适用范围、数字、日期、月、周、时间、本地时间等类型的输入元素</p></li></ol><ul><li>用于验范围或数字是否大于等于或小于等于设定值</li><li>用于验时间是否早于或晚于设定值</li></ul><ol start="3"><li>required<br>是否必填</li><li>formnovalidate<br>禁用原生验证</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;email&quot;&gt; Email: &lt;input type=&quot;email&quot;</span><br><span class="line">        placeholder=&quot;user@mydomain.com&quot; required pattern=&quot;.*@mydomain.com$&quot;</span><br><span class="line">        id=&quot;email&quot; name=&quot;email&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;input type=&quot;submit&quot;</span><br><span class="line">      value=&quot;Save&quot; formnovalidate /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新增表单元素&lt;br&gt;兼容性存在问题，并且不同浏览器样式不同&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>LESS</title>
    <link href="https://dorisfeng.github.io/2020/07/21/LESS/"/>
    <id>https://dorisfeng.github.io/2020/07/21/LESS/</id>
    <published>2020-07-21T01:58:09.000Z</published>
    <updated>2020-07-21T14:05:17.381Z</updated>
    
    <content type="html"><![CDATA[<p>一些 less 的用法</p><a id="more"></a><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@link-color:#428bca;</span><br><span class="line">@link-color-hover:darken(@link-color, 10%);</span><br><span class="line">a&#123;</span><br><span class="line">    color:@link-color</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        color:@link-color-hover</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅可以使用变量存储属性值，还可以使用变量存储公用的 URL、选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.@(selector)&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    @&#123;property&#125;:#000;</span><br><span class="line">    background:url(&quot;@&#123;bgImg/test.png&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@selector:box;</span><br><span class="line">@bigImg:&quot;../img&quot;;</span><br><span class="line">@property:color</span><br></pre></td></tr></table></figure><h2 id="混合（Mixins）"><a href="#混合（Mixins）" class="headerlink" title="混合（Mixins）"></a>混合（<code>Mixins</code>）</h2><p><strong>1. 基本使用</strong><br>混合可以将一个定义好的<code>class A</code>轻松的引入到另一个<code>class B</code>中，从而简单实现<code>class B</code>继承 <code>class A</code>中的所有属性。我们还可以带参数地调用，就像使用函数一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是将<code>public</code>设定的样式属性复制一份到实际样式中。如果想要在编译完成后不输出<code>public</code>样式的结果，写法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//less</span><br><span class="line">.public()&#123;//-&gt;在选择器后面加上()就可以不编译这个样式了</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public; //如果public有子孙元素的样式，同样也会被复制过来</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. extend</strong><br>上面的方法是把<code>public</code>样式复制一遍，编译后的<code>CSS</code>还是会很大，可以使用<code>extend</code>避免这一点<br><strong>和原来的选择器共用一套样式，但要保证原来的选择器不加括号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    &amp;:extend(.public);</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public, nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><p>LESS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">    .navigation&#123;</span><br><span class="line">        font-size:12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .logo&#123;</span><br><span class="line">        width:300px;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            text-decoration:none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">&#125;</span><br><span class="line">#header .navigation&#123;</span><br><span class="line">    font-size:12px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo&#123;</span><br><span class="line">    width:300px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo:hover&#123;</span><br><span class="line">    text-decoration:none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和运算"><a href="#函数和运算" class="headerlink" title="函数和运算"></a>函数和运算</h2><p>运算提供了加、减、乘、除操作。可以对属性值和颜色做运算，实现属性值之间的复杂关系。<br>任何数字、颜色或者变量都可以参与运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@base: 5%;</span><br><span class="line">@filter: @base * 2; //10%</span><br><span class="line">@other: @base + @filter; //15%</span><br><span class="line">color: #888/4; //#222</span><br><span class="line">@base-color:#111;</span><br><span class="line">background-color: @base-color+#111;//#222</span><br><span class="line">height: 100%/2 + @filter;//60%</span><br></pre></td></tr></table></figure><p>颜色运算函数，颜色会被转化为<code>HSL</code>色彩空间，然后在通道级别操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lighten(@color, 10%); //变亮10%</span><br><span class="line">darken(@color, 10%); //变暗10%</span><br></pre></td></tr></table></figure><p>数学函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round(1.67); //2</span><br><span class="line">ceil(2.3);//3</span><br><span class="line">floor(2.6); //2</span><br></pre></td></tr></table></figure><h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><p>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var:red;</span><br><span class="line">#page&#123;</span><br><span class="line">    @var:white;</span><br><span class="line">    #header&#123;</span><br><span class="line">        color:@var; //white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#footer&#123;</span><br><span class="line">    color:@var; //red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些 less 的用法&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://dorisfeng.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>响应式布局</title>
    <link href="https://dorisfeng.github.io/2020/07/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://dorisfeng.github.io/2020/07/20/响应式布局/</id>
    <published>2020-07-20T08:25:08.000Z</published>
    <updated>2020-07-21T01:44:52.139Z</updated>
    
    <content type="html"><![CDATA[<p>一个页面适配多种设备和多个屏幕</p><a id="more"></a><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p><code>viewport</code>，浏览器中用于呈现网页的区域，视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下。<br>手机端与<code>PC</code>端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。<code>iOS</code>, <code>Android</code> 基本都将这个视口分辨率设置为 980px。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&apos;viewport&apos; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><code>width=device-width</code>：视口为设备宽度，手机厂商设置或默认 980px</li><li><code>initial-scale=1.0</code>：初始化的视口大小为 1.0 倍</li><li><code>maxmum-scale=1.0</code>：最大的倍数是 1.0 倍</li><li><code>user-scalable=no</code>：不允许缩放视口</li></ul><h2 id="手机浏览器内核"><a href="#手机浏览器内核" class="headerlink" title="手机浏览器内核"></a>手机浏览器内核</h2><ul><li>微软 <code>Trident</code></li><li>火狐 <code>Gecko</code></li><li>开源内核 <code>Webkit</code></li><li>Opera <code>Presto</code><br>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浏览器兼容前缀</span><br><span class="line">-ms-</span><br><span class="line">-moz-</span><br><span class="line">-o-</span><br><span class="line">-webkit-</span><br></pre></td></tr></table></figure><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>针对特定的设备或条件为网页应用特定的 css 样式。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>媒体查询外面写的第一条规则是基本的样式，适用于任何设备，然后为不同的视口，不同能力的设备，添加不同效果。<br>需要配合视口使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: grey;</span><br><span class="line"> &#125;</span><br><span class="line">@media screen and (min-width:1200px)&#123; //宽度大于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: pink;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> @media screen and (min-width:700px) and (max-width:1200px)&#123; //宽度大于700像素小于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:700px)&#123;//宽度小于700像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>screen</code>表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号匹配可能性。</p><h2 id="rem-响应式布局"><a href="#rem-响应式布局" class="headerlink" title="rem 响应式布局"></a>rem 响应式布局</h2><p>rem:当前页面中元素的<code>REM</code>单位的样式值都是针对于<code>HTML</code>元素的<code>font-size</code>的值进行动态计算的。<br>em:表示当前父元素的字号的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div style=&apos;font-size:10px&apos;&gt;</span><br><span class="line">    &lt;span&gt;box1&lt;/span&gt;</span><br><span class="line">    &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">        &lt;span&gt;box2&lt;/span&gt;</span><br><span class="line">        &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">            &lt;span&gt;box3&lt;/span&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">                    &lt;span&gt;box4&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/20/响应式布局/img1.png" alt="em"></p><p><code>rem</code> 可以和媒体查询配合实现响应式布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width: 320px) &#123;</span><br><span class="line">    html &#123;font-size: 14px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 360px) &#123;</span><br><span class="line">    html &#123;font-size: 16px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 400px) &#123;</span><br><span class="line">    html &#123;font-size: 18px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>分比布局也叫作流式布局、弹性盒布局。<br>使用百分比设置<code>width</code>，<code>height</code>，<code>padding</code>，<code>margin</code></p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>如果移动端和 PC 端公用一套代码，建议使用流式布局。<br><strong>如何做一个 REM 响应式布局</strong></p><ol><li>从 <code>UI</code> 设计师拿到<code>PSD</code>设计稿,然后在样式中给 HTML 设定一个<code>font-size</code>的值，我们一般都设置一个方便后面计算的值，例如：<code>100px</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px; //1rem=100px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>首先按照设计稿的尺寸来写样式，把得到的像素值除以<code>100</code>计算出对应的<code>REM</code>值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margin:0 0.2rem;</span><br><span class="line">height:3rem;</span><br></pre></td></tr></table></figure></li><li><p>根据当前屏幕宽度和设计稿的宽度来计算出<code>font-size</code>的值。<br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个<code>font-size</code>的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其<code>font-size</code>应该设置为多少。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">375/640*100-&gt;font-size=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure><p>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的<code>font-size</code>值应该是多少，如果<code>font-size</code>的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小。可以通过以下这段代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//html部分</span><br><span class="line">&lt;section id=&quot;main&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">//js部分</span><br><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    var oMain=document.getElementById(main&quot;)；</span><br><span class="line">    if(winW&gt;desW)&#123;</span><br><span class="line">        oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">        oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个页面适配多种设备和多个屏幕&lt;/p&gt;
    
    </summary>
    
      <category term="布局" scheme="https://dorisfeng.github.io/categories/%E5%B8%83%E5%B1%80/"/>
    
    
  </entry>
  
</feed>
