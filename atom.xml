<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fdd’Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dorisfeng.github.io/"/>
  <updated>2020-11-07T07:46:26.264Z</updated>
  <id>https://dorisfeng.github.io/</id>
  
  <author>
    <name>封多多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react-性能优化2</title>
    <link href="https://dorisfeng.github.io/2020/11/07/react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%962/"/>
    <id>https://dorisfeng.github.io/2020/11/07/react-性能优化2/</id>
    <published>2020-11-07T07:44:08.000Z</published>
    <updated>2020-11-07T07:46:26.264Z</updated>
    
    <content type="html"><![CDATA[<p>react-hook 性能优化方案</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;react-hook 性能优化方案&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-高阶函数</title>
    <link href="https://dorisfeng.github.io/2020/11/06/JS-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://dorisfeng.github.io/2020/11/06/JS-高阶函数/</id>
    <published>2020-11-06T06:20:38.000Z</published>
    <updated>2020-11-07T08:08:51.577Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/11/06/JS-高阶函数/bg2.jpg" alt="高阶函数"><br>高阶函数以及多个高阶函数嵌套</p><a id="more"></a><p>高阶函数：以另一个函数作为参数的函数</p><p>例子：封装一个 map 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">arr.map((v,k)=&gt;&#123;</span><br><span class="line">    console.log(this.sss);//1</span><br><span class="line">    return v*2</span><br><span class="line">&#125;,&#123;sss:1&#125;)</span><br></pre></td></tr></table></figure><p>注意，<code>map</code>方法的第二个参数作为第一个函数的<code>this</code>对象，如果未传入，函数的 this 指向按照函数的类型，是否严格模式等情况讨论，<br>参见:JS-this 指向<br>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._map=function(fun,context)&#123;</span><br><span class="line">    if(typeof fun !==&apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(fn+&quot;is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let len=this.length;</span><br><span class="line">    let temp=[]</span><br><span class="line">    for(let k=0;k&lt;len;k++)&#123;</span><br><span class="line">        temp.push(fun.call(context,this[k],k,this))</span><br><span class="line">    &#125;</span><br><span class="line">    return temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码组合</strong><br>高阶函数 widthLogin，判断用户状态<br>登录判断模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const getLogin=function()&#123;</span><br><span class="line"> const getLogin=function()&#123;</span><br><span class="line">     var a=parseInt(Math.random()*10).toFixed(0);</span><br><span class="line">     if(a%2==0)&#123;</span><br><span class="line">         return &#123;login:false&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return&#123;</span><br><span class="line">         login:true</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const withLogin=function(basicFn)&#123;</span><br><span class="line">     const loginInfo=getLogin();</span><br><span class="line">     return basicFn.bind(null,loginInfo)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const withLogin=window.withLogin;</span><br><span class="line">const renderIndex=function(loginInfo)&#123;</span><br><span class="line">    //判断是否登录</span><br><span class="line">    if(loginInfo.login)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.renderIndex=withLogin(renderIndex)</span><br></pre></td></tr></table></figure><p>其他模块，处理方法相同，都是在外面包一层 withLogin<br>如果还需要一个高阶函数判断当前系统的运行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    const env=&#123;</span><br><span class="line">        isMobile:false,</span><br><span class="line">        isAndroid:false,</span><br><span class="line">        isIOS:false,</span><br><span class="line">    &#125;</span><br><span class="line">    const ua=navigator.userAgent;</span><br><span class="line">    env.isMobile=&apos;ontouchstart&apos; in document;</span><br><span class="line">    env.isAndroid=!!ua.match(/android/);</span><br><span class="line">    env.isIOS=!!us.match(/iphone/);</span><br><span class="line"></span><br><span class="line">    const withEnvironment=function(basicFn)&#123;</span><br><span class="line">        return basicFn.bind(null,env);</span><br><span class="line">    &#125;</span><br><span class="line">    window.withEnvironment=withEnvironment;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>此时主页函数调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = withLogin(withEnvironment(renderIndex));</span><br></pre></td></tr></table></figure><p><code>compose</code>方法从右至左，将第一个参数<code>renderIndex</code>作为第二个参数<code>withEnvironment</code>的参数，并将运行结果作为第一个参数的参数，并且最后返回一个新的函数，这个函数拥有两个高阶函数的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br></pre></td></tr></table></figure><p>实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">     let last = args.length - 1;</span><br><span class="line">     tag = false;</span><br><span class="line">     if (typeof args[last] === &apos;function&apos;) &#123;</span><br><span class="line">         tag = true</span><br><span class="line">     &#125;</span><br><span class="line">     if (last &gt; 1) &#123;</span><br><span class="line">         let param = args.pop(args[last]);</span><br><span class="line">         last--;</span><br><span class="line">         let newParam = args[last].call(args[last], param)</span><br><span class="line">         args.pop(args[last])</span><br><span class="line"></span><br><span class="line">         args.push(newParam);</span><br><span class="line">         console.log(newParam);</span><br><span class="line">         return compose(...args);</span><br><span class="line">     &#125; else if (last === 1) &#123;</span><br><span class="line">         if (!tag) &#123;</span><br><span class="line">             return args[0].bind(null, args[1])</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             return args[0].call(null, args[1])</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn1 = function (a) &#123;</span><br><span class="line">        return a + 100</span><br><span class="line">    &#125;</span><br><span class="line">    var fn2 = function (a) &#123;</span><br><span class="line">        return a + 10</span><br><span class="line">    &#125;</span><br><span class="line">    var fn3 = function (a) &#123;</span><br><span class="line">        return a + 20</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var bar = compose(fn1, fn2, fn3, 10);</span><br><span class="line">    console.log(bar());</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    // 30</span><br><span class="line">    // 40</span><br><span class="line">    // 140</span><br></pre></td></tr></table></figure><p>上一个函数的运算结果作为下一个函数的参数，这种逻辑与<code>reduce</code>相似。<br>利用<code>reduce</code>实现<code>compose</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function compose(...args) &#123;</span><br><span class="line">  return args.reduceRight((pre, cur, i) =&gt; &#123;</span><br><span class="line">    console.log(pre, cur, i)</span><br><span class="line">    return cur(pre)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助科里化封装得更加灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.renderIndex = compose(withLogin, withEnvironment, renderIndex);</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">window.renderIndex = compose(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure><p>利用<code>lodash.js</code>中是的<code>flowRight</code>来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES6 模块化语法，引入flowRight函数</span><br><span class="line">import flowRight from &apos;lodash/flowRight&apos;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// ES6模块化语法 对外暴露接口</span><br><span class="line">export default flowRight(withLogin, withEnvironment)(renderIndex);</span><br></pre></td></tr></table></figure><p>参考<br><a href="https://www.yuque.com/coreadvance/kagkke/bnk7g4" target="_blank" rel="noopener">高阶函数</a><br><a href="https://www.yuque.com/coreadvance/kagkke/zn7kz1" target="_blank" rel="noopener">代码组合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/11/06/JS-高阶函数/bg2.jpg&quot; alt=&quot;高阶函数&quot;&gt;&lt;br&gt;高阶函数以及多个高阶函数嵌套&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-科里化</title>
    <link href="https://dorisfeng.github.io/2020/11/06/JS-%E7%A7%91%E9%87%8C%E5%8C%96/"/>
    <id>https://dorisfeng.github.io/2020/11/06/JS-科里化/</id>
    <published>2020-11-06T01:47:26.000Z</published>
    <updated>2020-11-07T08:10:44.638Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/11/06/JS-科里化/bg1.jpg" alt="科里化"><br>科里化的简单应用</p><a id="more"></a><p>科里化是将一个函数所需要的多个参数分开传入函数中，每次调用会返回一个新函数，用于处理剩余参数。<br>所以将一个函数科里化的过程就是收集函数参数的过程，递归搜集参数，收集完成后，在最深层计算结果并返回。</p><h2 id="科里化通用式"><a href="#科里化通用式" class="headerlink" title="科里化通用式"></a>科里化通用式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createCurry(fn,restLen,args)&#123;</span><br><span class="line">    restLen=restLen||fn.length;</span><br><span class="line">    args=args||[];</span><br><span class="line">    const wrapper=function()&#123;</span><br><span class="line">        let _args=[].slice.call(arguments);</span><br><span class="line">        [].push.call(args,_args);</span><br><span class="line">        if(restLen&gt;_args.length)&#123;</span><br><span class="line">            restLen-=_args.length;</span><br><span class="line">            return wrapper(fn,restLen,args)</span><br><span class="line">        &#125;</span><br><span class="line">        return fn.apply(fn,args)</span><br><span class="line">    &#125;</span><br><span class="line">    return wrapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>验证手机号码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkPhone(phoneNumber)&#123;</span><br><span class="line">    return /^1[34578]\d&#123;9&#125;$/.test(phoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用科里化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function check(reg,targetString)&#123;</span><br><span class="line">    return reg.test(targetString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _check = createCurry(check);</span><br><span class="line"></span><br><span class="line">var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/);</span><br><span class="line">var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(&apos;183888888&apos;);</span><br><span class="line">checkEmail(&apos;xxxxx@test.com&apos;);</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>函数不定参数，解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let args=[1,2,3,4]</span><br><span class="line">add.apply(null,args)</span><br><span class="line">add(...args)</span><br></pre></td></tr></table></figure></li><li><p>函数隐式转换<br>当函数参与运算时，会默认调用 toString 方法，获取返回值，参与运算。<br>默认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a+1 //&quot;function a()&#123;&#125;1&quot;</span><br></pre></td></tr></table></figure><p>重写 toString 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">a.toString=function()&#123;return 10&#125;</span><br><span class="line">a+1 //11</span><br><span class="line">a+&apos;1&apos; //&apos;11&apos;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>add</code>函数<br>实现一个 add 方法，使计算结果能够满足如下预期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(1)(2)(3) = 6;</span><br><span class="line">add(1, 2, 3)(4) = 10;</span><br><span class="line">add(1)(2)(3)(4)(5) = 15;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">    let _args=[].slice.call(arguments);</span><br><span class="line">    const adder=function()&#123;</span><br><span class="line">        const _adder=function()&#123;</span><br><span class="line">            _args.push(...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">     _adder.toString=function()&#123;</span><br><span class="line">         return _args.reduce((a,b)=&gt;&#123;</span><br><span class="line">             return a+b</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     return _adder</span><br><span class="line">    &#125;</span><br><span class="line">    return adder(..._args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考：<br><a href="https://www.yuque.com/coreadvance/kagkke/iz3cdu" target="_blank" rel="noopener">科里化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/11/06/JS-科里化/bg1.jpg&quot; alt=&quot;科里化&quot;&gt;&lt;br&gt;科里化的简单应用&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://dorisfeng.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里云部署</title>
    <link href="https://dorisfeng.github.io/2020/10/28/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
    <id>https://dorisfeng.github.io/2020/10/28/阿里云部署/</id>
    <published>2020-10-28T06:49:50.000Z</published>
    <updated>2020-10-28T07:44:47.096Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下阿里云服务器部署 web 项目遇到的问题<br>因为只是要求 web 项目可以运行起来，总体很简单，卡在 FTP 上传文件上，先入为主，之前一直使用 FileZilla 部署，连接失败一直以为是这次的服务器配置有问题，没想到软件运行环境的问题。利用 win10 虚拟机安装了 FileZilla，测试正常。</p><a id="more"></a><h2 id="云服务器-ECS"><a href="#云服务器-ECS" class="headerlink" title="云服务器 ECS"></a>云服务器 ECS</h2><ul><li><p><strong>如何选择服务器配置</strong><br>本次为了熟悉部署步骤，使用的是 ECS 的体验版一个月（1vCPU 2GB）。<br><a href="https://help.aliyun.com/document_detail/58291.html?spm=a2c4g.11186623.2.20.240a5b73L2bPBY" target="_blank" rel="noopener">ECS 选型最佳实践</a><br>简单的企业官网选择 2 核 4G 或 2 核 8G 就可以，不确定选什么样的，可以先配最低的，后面再升级。</p></li><li><p><strong>创建实例</strong><br>购买之后，会默认生成一个实例，我是根据默认实例操作的，如果购买的配置较高，可以新建多个实例</p></li><li><p><strong>操作系统选择</strong><br>根据要配置的运行环境选择不同操作系统，后面可以修改。</p></li><li><p><strong>连接 ECS 实例</strong><br>Workbench 远程连接<br>使用 Linux 用户名密码连接，用户名默认 root，密码忘记了可以重置，如果要重新选择系统也要重置密码。<br><img src="/2020/10/28/阿里云部署/1.png" alt="重置密码"></p></li><li><p><strong>运行环境配置</strong><br><a href="https://help.aliyun.com/document_detail/57160.html?spm=a2c4g.11186623.6.1178.240a5b73L2bPBY" target="_blank" rel="noopener">自助建站方式汇总</a><br>比较熟悉的是 Node 环境，所有我配的是<a href="https://help.aliyun.com/document_detail/50775.html?spm=a2c4g.11186623.2.23.1d8679249RKC9e#concept-50775-zh" target="_blank" rel="noopener">部署 Node.js 环境（CentOS 7）</a><br>第一种方法 NVM 安装有问题，我采用第二种方法。</p><ol><li><p>下载安装包<br>提供的链接比较老，可以去 node 官网找最新的响应版本。<br>node 中文网-》下载-》阿里云镜像-》最新 linux64-》复制链接-》替换<br><code>wget https://npm.taobao.org/mirrors/node/v14.14.0/node-v14.14.0-linux-x64.tar.gz</code></p></li><li><p>解压<br><code>tar xvf node-v14.14.0-linux-x64.tar.gz</code></p></li><li><p>创建软链接，您就可以在任意目录下直接使用 node 和 npm 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /root/node-v14.14.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><p>其中<code>/root</code>是文件下载或解压的所在路径，默认在<code>/root</code>下</p></li><li><p>查看版本</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><ol start="5"><li>如果需要将该软件安装到其他目录（例如：/opt/node/）下，请进行如下操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/node/</span><br><span class="line">mv /root/node-v14.14.0-linux-x64/* /opt/node/</span><br><span class="line">rm -f /usr/local/bin/node</span><br><span class="line">rm -f /usr/local/bin/npm</span><br><span class="line">ln -s /opt/node/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /opt/node/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure><ol start="6"><li>安装 pm2<br>为了自动重启 Node 项目。<br><code>npm install pm2 -g</code><br>还可使用<br><code>wget -qO- https://getpm2.com/install.sh | bash</code><br>启动项目<br><code>pm2 start /var/ftp/test/index</code><br>启动 n 个进程，名字命名为 name。<br><code>pm2 start app.js -i [n] --name [name]</code><br>自启动（watch 的文件发生变化就会自启动）<br><code>pm2 start app.js --watch</code></li></ol></li><li><p><strong>上传项目到 ECS</strong><br>这个问题纠结了好几天，怎么配置我的 FileZilla 都不行，chrome 也没有上传按钮。最后在 win10 虚拟机上安装了一个 FileZilla，拖拽上传打包后的项目+nodeserver 就行了</p></li><li><p><strong>启动项目</strong><br><code>pm2 start /var/ftp/test/index</code><br>根据服务器启动的端口，配置安全组，我的服务是 8080 端口<br><img src="/2020/10/28/阿里云部署/2.png" alt="安全组"></p></li></ul><p>———撒花！撒花！完成了不知道能不能部署一个真的项目——–</p><h2 id="域名申请和绑定"><a href="#域名申请和绑定" class="headerlink" title="域名申请和绑定"></a>域名申请和绑定</h2><h2 id="公司邮箱"><a href="#公司邮箱" class="headerlink" title="公司邮箱"></a>公司邮箱</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下阿里云服务器部署 web 项目遇到的问题&lt;br&gt;因为只是要求 web 项目可以运行起来，总体很简单，卡在 FTP 上传文件上，先入为主，之前一直使用 FileZilla 部署，连接失败一直以为是这次的服务器配置有问题，没想到软件运行环境的问题。利用 win10 虚拟机安装了 FileZilla，测试正常。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GET和POST区别</title>
    <link href="https://dorisfeng.github.io/2020/08/20/GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB/"/>
    <id>https://dorisfeng.github.io/2020/08/20/GET和POST区别/</id>
    <published>2020-08-20T02:30:27.000Z</published>
    <updated>2020-08-20T06:57:40.054Z</updated>
    
    <content type="html"><![CDATA[<p>GET 和 POST 核心机制与区别</p><a id="more"></a><h2 id="场景一：浏览器的-GET-和-POST"><a href="#场景一：浏览器的-GET-和-POST" class="headerlink" title="场景一：浏览器的 GET 和 POST"></a>场景一：浏览器的 GET 和 POST</h2><p>这里特指浏览器中非<code>Ajax</code>的<code>Http</code>请求，即<code>HTTP</code>协议中的<code>GET/POST</code>，浏览器用<code>GET</code>请求来获取一个<code>html</code>页面、图片、<code>css</code>、<code>js</code> 等资源，用<code>POST</code>请求提交一个<code>&lt;form&gt;</code>表单，并得到一个结果。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取资源，反复读取不会对访问的数据有副作用，没有副作用被称为‘幂等’。<br>因为 GET 是读取数据，就可以对 GET 请求的数据做缓存，缓存可以做到浏览器本身（彻底避免浏览器发请求），也可以做到代理上，或者 server 端。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>在页面里<code>&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; &gt;</code>标签会定义一个表单，点击其中的<code>submit</code>元素会发出一个<code>POST</code>请求让服务器做一件事。这件事往往是有副作用的，不幂等的。<br>不幂等就意味着不能随意多次执行，因此也不能缓存。</p><p><code>GET</code>和<code>POST</code>携带的数据格式也是有区别的，浏览器发出<code>GET</code>请求时分为两种情况，第一种用户自己在浏览器的地址栏输入，第二种点击<code>html</code>的<code>a</code>标签触发了<code>href</code>中的<code>url</code>。其实并不是<code>GET</code>只能用<code>url</code>,而是浏览器直接发出的<code>GET</code>只能由一个<code>url</code>触发。所以如果<code>GET</code>上要在<code>url</code>之外带一些参数就要依靠<code>querystring</code>。<br>浏览器的<code>POST</code>请求都来自表单提交，表单的数据被浏览器编码到 HTTP 请求的 body 里。两种编码方式：<code>application/x-www-form-urlencoded</code>用来传输简单数据，例如：”key1=value1&amp;key2=value2”,<code>multipart/form-data</code>用来传输文件。<br>浏览器在<code>POST</code>表单数据时，也可以带上参数，直接写在<code>action</code>的<code>url</code>里。<br>一般说“<code>GET</code>请求没有<code>body</code>，只有<code>url</code>，请求数据放在<code>url</code>的<code>querystring</code>中；<code>POST</code>请求的数据在<code>body</code>中“。但这种情况仅限于浏览器发请求的场景。</p><h2 id="接口中的-GET-和-POST"><a href="#接口中的-GET-和-POST" class="headerlink" title="接口中的 GET 和 POST"></a>接口中的 GET 和 POST</h2><p>这里指通过浏览器的<code>Ajax api</code>，或者<code>iOS/Android</code>的<code>App</code>的<code>http client</code>，<code>java</code> 的<code>commons-httpclient/okhttp</code>或者是<code>curl</code>，<code>postman</code>之类的工具发出来的<code>GET</code>和<code>POST</code>请求。此时 GET/POST 不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种 RPC 协议使用）。<br>REST 接口规范、风格，约定了<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>，这 4 个接口获取、创建、替换、删除，<code>REST</code>最佳实践还推荐在请求体使用<code>JSON</code>格式。<br><code>JSON</code>相对于<code>x-www-form-urlencoded</code>的优势在于: 1. 嵌套结构 2. 可以支持更丰富的数据类型。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>因为 POST 用 body 传输数据，而 GET 用 url 传输，更容易看到，所以 GET 更不安全。但是从攻击角度，无论是 GET 还是 POST 都不够安全，因为 HTTP 本身时明文协议，每个 HTTP 请求和返回的每个 byte 都会在网络上明文传输，不论是 url,header 或 body。<br>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是 https</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>URL 编码<br>utf-8 编码<br>body 编码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GET 和 POST 核心机制与区别&lt;/p&gt;
    
    </summary>
    
      <category term="网络请求" scheme="https://dorisfeng.github.io/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>ES10</title>
    <link href="https://dorisfeng.github.io/2020/08/19/ES10/"/>
    <id>https://dorisfeng.github.io/2020/08/19/ES10/</id>
    <published>2020-08-19T02:58:37.000Z</published>
    <updated>2020-08-19T06:41:16.872Z</updated>
    
    <content type="html"><![CDATA[<p>ES2019</p><a id="more"></a><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat()/flatMap()"></a><code>Array.prototype.flat()/flatMap()</code></h2><p><code>flat()</code>根据传入参数，深度递归遍历数组，并将所有元素与遍历的子数组中的元素合并为一个新数组返回。<br><code>flatMap()</code>与<code>map()</code>方法的深度为 1 的<code>flat()</code>几乎相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4]</span><br><span class="line">let arr2 = arr1.map(x =&gt; [x * 2]) // [[2], [4], [6], [8]]</span><br><span class="line">let arr3 = arr2.flatMap(x =&gt; x) // [2, 4, 6, 8]</span><br><span class="line">let arr4 = arr2.flatMap(x =&gt; [x]) // [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure><h2 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()"></a><code>String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()</code></h2><p>在 ES5 中，可以通过 trim()来去掉字符首尾的空格。<br>ES10 之后可以使用<code>trimStart()/trimLeft()</code>去掉开头的空格。<br><code>trimEnd()/trimRight()</code>去掉结尾的空格。<br>不过这里有一点要注意的是，<code>trimStart()</code>跟 <code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟 <code>trimRight()</code>只是别名。</p><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a><code>Object.fromEntries()</code></h2><p>把键值对列表转换为一个对象，是<code>Object.entries()</code>的反函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const entries = new Map([</span><br><span class="line">    [&apos;foo&apos;, &apos;bar&apos;],</span><br><span class="line">    [&apos;baz&apos;, 42]</span><br><span class="line">])</span><br><span class="line">const obj = Object.fromEntries(entries)</span><br><span class="line">console.log(obj) //&#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a><code>Symbol.prototype.description</code></h2><p>只读属性，返回<code>Symbol</code>对象的可选描述的字符串。与<code>Symbol.prototype.toString()</code>不同的是，它不会包含<code>Symbol</code>的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol(&apos;desc&apos;).toString()); // &quot;Symbol(desc)&quot;</span><br><span class="line">console.log(Symbol(&apos;desc&apos;).description); // &quot;desc&quot;</span><br><span class="line">console.log(Symbol(&apos;&apos;).description); // &quot;&quot;</span><br><span class="line">console.log(Symbol().description); // undefined</span><br><span class="line">console.log(Symbol.iterator.toString()); // &quot;Symbol(Symbol.iterator)&quot;</span><br><span class="line">console.log(Symbol.iterator.description); // &quot;Symbol.iterator&quot;</span><br></pre></td></tr></table></figure><h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a><code>String.prototype.matchAll</code></h2><p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regexp = /t(e)(st(\d?))/g</span><br><span class="line">var str = &apos;test1test2&apos;;</span><br><span class="line">console.log(str.match(regexp)); // [&apos;test1&apos;, &apos;test2&apos;]</span><br><span class="line">console.log(str.matchAll(regexp)); // RegExpStringIterator &#123;&#125;</span><br><span class="line">console.log([...str.matchAll(regexp)])</span><br><span class="line">// [[&apos;test1&apos;, &apos;e&apos;, &apos;st1&apos;, &apos;1&apos;, index: 0, input: &apos;test1test2&apos;, length: 4], [&apos;test2&apos;, &apos;e&apos;, &apos;st2&apos;, &apos;2&apos;, index: 5, input: &apos;test1test2&apos;, length: 4]]</span><br></pre></td></tr></table></figure><h2 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString()返回注释与空格"></a><code>Function.prototype.toString()</code>返回注释与空格</h2><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从 ES10 开始会保留这些空格，如果是原生函数则返回你控制台看到的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum.toString())</span><br><span class="line">// &quot;function sum(a, b) &#123;</span><br><span class="line">//         return a + b;</span><br><span class="line">//  &#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><code>try-catch</code></h2><p>以往版本中，<code>try-catch</code>里的<code>catch</code>后面必须带异常参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES10之前</span><br><span class="line">try &#123;</span><br><span class="line">// tryCode</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">// catchCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 ES10 之后，这个参数却不是必须的，如果用不到，我们可以不用传。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(&apos;Foobar&apos;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    console.error(&apos;Bar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><p>内置对象，提供一种方法表示大于 2^53-1 的整数。<code>BigInt</code>可以表示任意大的整数。<br>定义<code>BigInt</code>：<code>10n</code>或<code>BigInt()</code><br>以下操作符可以和<code>BigInt</code>一起使用：<code>+</code>,<code>-</code>,<code>*</code>,<code>**</code>,<code>%</code>。除<code>&gt;&gt;&gt;</code>(无符号右移)之外的位操作符也可以支持。因为<code>BigInt</code>都是有符号的，<code>&gt;&gt;&gt;</code>（无符号右移）不能用于<code>BigInt</code>。<code>BigInt</code>不支持单目 (+) 运算符。<br><code>/</code>操作符对于整数的运算也没问题。可是因为这些变量是<code>BigInt</code>而不是<code>BigDecimal</code>，该操作符结果会向零取整，也就是说不会返回小数部分。<br><code>BigInt</code>和<code>Number</code>不是严格相等的，但是宽松相等的。</p><p>所以在<code>BigInt</code>出来以后，JS 的原始类型便增加到了 7 个，如下：</p><ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol (ES6)</code></li><li><code>BigInt (ES10)</code></li></ul><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a><code>globalThis</code></h2><p>包含类似于全局对象<code>this</code>值，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis === this // true</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import()"></a><code>import()</code></h2><p>静态的<code>import</code>语句用于导入由另一个模块导出的绑定。无论是否声明了严格模式，导入的模块都运行在严格模式下。<br>在浏览器中，<code>import</code>语句只能在声明了<code>type=&#39;module&#39;</code>的<code>script</code>的标签中使用。<br>但是在 ES10 之后，我们有动态<code>import()</code>，它不需要依赖<code>type=&quot;module&quot;</code>的<code>script</code>标签。</p><h2 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Counter extends HTMLElement &#123;</span><br><span class="line">    #xValue = 0</span><br><span class="line"></span><br><span class="line">    get #x() &#123;</span><br><span class="line">        return #xValue</span><br><span class="line">    &#125;</span><br><span class="line">    set #x(value) &#123;</span><br><span class="line">        this.#xValue = value</span><br><span class="line">        window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #clicked() &#123;</span><br><span class="line">        this.#x++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.onclick = this.#clicked.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">            this.#render()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #render() &#123;</span><br><span class="line">        this.textContent = this.#x.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.customElements.define(&apos;num-counter&apos;, Counter)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2019&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>ES8</title>
    <link href="https://dorisfeng.github.io/2020/08/18/ES8/"/>
    <id>https://dorisfeng.github.io/2020/08/18/ES8/</id>
    <published>2020-08-18T02:12:10.000Z</published>
    <updated>2020-08-19T06:37:09.059Z</updated>
    
    <content type="html"><![CDATA[<p>ES2017</p><a id="more"></a><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h2><p><a href="https://dorisfeng.github.io/2020/06/22/JS-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a></p><h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a><code>Object.values()</code></h2><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a><code>Object.entries()</code></h2><h2 id="padStart-len-s"><a href="#padStart-len-s" class="headerlink" title="padStart(len,s)"></a><code>padStart(len,s)</code></h2><p>用另一个字符串从开始位置填充当前字符串，使产生的字符串达到给定长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let last4 = ID.slice(-4)</span><br><span class="line">let new_ID = last4.padStart(ID.length, &apos;*&apos;);</span><br><span class="line">console.log(new_ID);//**************3529</span><br></pre></td></tr></table></figure><h2 id="padEnd-len-s"><a href="#padEnd-len-s" class="headerlink" title="padEnd(len,s)"></a><code>padEnd(len,s)</code></h2><p>在末尾填充，规则跟<code>padStart</code>的一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ID = &apos;320322199902223529&apos;;</span><br><span class="line">let first3 = ID.slice(0, 3)</span><br><span class="line">let new_ID = first3.padEnd(ID.length, &apos;*&apos;);</span><br></pre></td></tr></table></figure><h2 id="函数参数逗号结尾"><a href="#函数参数逗号结尾" class="headerlink" title="函数参数逗号结尾"></a>函数参数逗号结尾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 参数定义</span><br><span class="line">function f(p) &#123;&#125;</span><br><span class="line">function f(p,) &#123;&#125;</span><br><span class="line"></span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果没有参数就只有逗号会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 带有尾后逗号的数组解构</span><br><span class="line">[a, b,] = [1, 2]</span><br><span class="line"></span><br><span class="line">// 带有尾后逗号的对象解构</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 42,</span><br><span class="line">  q: true,</span><br><span class="line">&#125;</span><br><span class="line">var &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure><p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...b,] = [1, 2, 3] // SyntaxError: rest element may not have a trailing comma</span><br></pre></td></tr></table></figure><h2 id="ShareArrayBuffer"><a href="#ShareArrayBuffer" class="headerlink" title="ShareArrayBuffer"></a><code>ShareArrayBuffer</code></h2><p>因安全性问题，暂时在 Chrome 和 FireFox 中被禁用。<br>用来表示一个通用的、固定长度的原始二进制缓冲区，类似 ArrayBuffer 对象。它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，ShareArrayBuffer 不能被分离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sab=new SharedArrayBuffer(1024);</span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure><h2 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a><code>Atomics</code>对象</h2><p>对<code>ShareArrayBuffer</code>对象进行原子操作。</p><ul><li><code>Atomics.add()</code>，将指定位置上的数组元素与给定的值相加并返回该元素更新前的值。</li><li><code>Atomics.compareExchange()</code>，如果数组中指定的元素与给定的值相等，将其更新为新的值，并返回该元素更新前的值。</li><li><code>Atomics.exchange()</code>，将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</li><li><code>Atomics.load()</code>，返回数组中指定元素的值</li><li><code>Atomics.or()</code>，将指定位置上的数组元素与给定的值相或，并返回该元素更新前的值。</li><li><code>Atomics.store()</code>，将数组中指定的元素设置为给定的值，返回该值。</li><li><code>Atomics.sub()</code>，将指定位置上的数组元素与给定的值相减，并返回该元素更新前的值。</li><li><code>Atomics.xor()</code>，将指定位置上的数组元素与给定的值相异或，并返回该元素更新前的值。</li><li><code>Atomics.wait()</code>，检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</li><li><code>Atomics.wake()</code>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</li><li><code>Atomics.isLockFree(size)</code>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</li></ul><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a><code>Object.getOwnPropertyDescriptors()</code></h2><p>获取一个对象的所有自身属性的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">    property1: 42</span><br><span class="line">&#125;</span><br><span class="line">const descriptors1 = Object.getOwnPropertyDescriptors(object1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2017&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>ES7</title>
    <link href="https://dorisfeng.github.io/2020/08/18/ES7/"/>
    <id>https://dorisfeng.github.io/2020/08/18/ES7/</id>
    <published>2020-08-18T01:55:25.000Z</published>
    <updated>2020-08-19T06:37:04.525Z</updated>
    
    <content type="html"><![CDATA[<p>ES2016</p><a id="more"></a><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a><code>Array.prototype.includes()</code></h2><p>用来判断一个数组是否包含指定值，如果包含返回 true，否则返回 false。</p><h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a><code>幂运算符**</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2**10; //1024</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><code>模板字符串</code></h2><ul><li><code>Unicode</code>字符以<code>\u</code>开头，例如<code>\u00A9</code>,”©”</li><li><code>Unicode</code>码位用<code>\u{}</code>表示，例如<code>\u{2F804}</code>,’你’</li><li>十六进制以<code>\x</code>开头，例如<code>\xA9</code>,”©”</li><li>八进制以<code>\</code>和数字开头，例如<code>\251</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2016&lt;/p&gt;
    
    </summary>
    
      <category term="ECMA" scheme="https://dorisfeng.github.io/categories/ECMA/"/>
    
    
  </entry>
  
  <entry>
    <title>IE兼容性问题</title>
    <link href="https://dorisfeng.github.io/2020/08/13/IE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://dorisfeng.github.io/2020/08/13/IE兼容性问题/</id>
    <published>2020-08-13T05:30:40.000Z</published>
    <updated>2020-08-13T05:30:40.231Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html5-canvas动画</title>
    <link href="https://dorisfeng.github.io/2020/07/29/html5-canvas%E5%8A%A8%E7%94%BB/"/>
    <id>https://dorisfeng.github.io/2020/07/29/html5-canvas动画/</id>
    <published>2020-07-29T15:02:19.000Z</published>
    <updated>2020-07-31T08:06:46.042Z</updated>
    
    <content type="html"><![CDATA[<p>canvas 动画</p><a id="more"></a><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><ol><li><strong>清空 canvas</strong><br>除非接下来要画的内容会完全充满<code>canvas</code>(例如背景图)，否则你需要清空所有。最简单使用<code>clearRect</code>方法。</li><li><strong>保存 canvas 状态</strong><br>如果你改变一些会改变 canvas 状态的设置，又要在每画一帧之时都是原始状态的话，需要先保存一下。</li><li><strong>绘制动画图形 animated shapes</strong><br>重绘动画帧</li><li><strong>恢复 canvas 状态</strong><br>如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</li></ol><h2 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h2><ul><li><code>setInterval(fun,delay)</code><br>延迟 delay 毫秒后执行函数</li><li><code>setTimeout(func,delay)</code><br>间隔 delay 毫秒执行函数</li><li><code>requestAnimationFrame(callback)</code><br>告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">  function init() &#123;</span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let ctx = document.getElementById(&apos;my_canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">    ctx.save()</span><br><span class="line">    ctx.clearRect(0, 0, 400, 400);</span><br><span class="line"></span><br><span class="line">    //每个间隔弧度</span><br><span class="line">    let angle = 2 * Math.PI / 60;</span><br><span class="line"></span><br><span class="line">    function drawBorder() &#123;</span><br><span class="line">        ctx.save(); //1</span><br><span class="line">        ctx.strokeStyle = &apos;#3D5F9D&apos;;</span><br><span class="line">        ctx.lineWidth = 6;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(200, 200, 150, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSplit() &#123;</span><br><span class="line">        ctx.save()</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        //分隔</span><br><span class="line">        for (let i = 1; i &lt;= 60; i++) &#123;</span><br><span class="line">            ctx.rotate(angle);</span><br><span class="line">            ctx.lineCap = &apos;round&apos;;</span><br><span class="line">            ctx.strokeStyle = &apos;#000&apos;;</span><br><span class="line">            ctx.lineWidth = 4;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            if (i % 5) &#123;</span><br><span class="line">                ctx.moveTo(0, -127);</span><br><span class="line">                ctx.lineTo(0, -130);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.moveTo(0, -120);</span><br><span class="line">                ctx.lineTo(0, -132);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.stroke();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawHour(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //时针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 7;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -90)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawMinute(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //分针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 4;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -125)</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawSecond(angle) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.rotate(angle)</span><br><span class="line">        //秒针</span><br><span class="line">        ctx.lineCap = &apos;round&apos;;</span><br><span class="line">        ctx.lineWidth = 3;</span><br><span class="line">        ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(0, 20);</span><br><span class="line">        ctx.lineTo(0, -112);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, -120, 7, 0, 2 * Math.PI);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    //中心</span><br><span class="line">    function drawCenter() &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate(200, 200);</span><br><span class="line">        ctx.fillStyle = &apos;red&apos;;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(0, 0, 5, 0, 2 * Math.PI);</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算角度</span><br><span class="line">    let date = new Date();</span><br><span class="line">    let hour = date.getHours() % 12;</span><br><span class="line">    let minutes = date.getMinutes();</span><br><span class="line">    let seconds = date.getSeconds();</span><br><span class="line">    let second_ag = seconds * angle;</span><br><span class="line">    let minute_ag = (minutes * angle + second_ag / 60) * 5;</span><br><span class="line">    let hour_ag = (hour * angle + minute_ag / 60) * 5;</span><br><span class="line">    drawBorder()</span><br><span class="line">    drawSplit()</span><br><span class="line">    drawHour(hour_ag)</span><br><span class="line">    drawMinute(minute_ag)</span><br><span class="line">    drawSecond(second_ag)</span><br><span class="line">    drawCenter()</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p><img src="/2020/07/29/html5-canvas动画/_posts/html5-canvas动画/img1.png" alt="时钟"></p><h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><p>有兴趣的时候来补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas 动画&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-canvas基础</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-canvas%E5%9F%BA%E7%A1%80/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-canvas基础/</id>
    <published>2020-07-23T08:57:20.000Z</published>
    <updated>2020-07-29T15:01:18.155Z</updated>
    
    <content type="html"><![CDATA[<p>canvas 用法</p><a id="more"></a><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;my_canvas&quot; width=&quot;500px&quot; height=&quot;500px&quot; &gt;</span><br><span class="line">    您的浏览器不支持canvas，请升级您的浏览器！</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><ol><li><code>canvas</code>为替换内容，如果浏览器不支持<code>canvas</code>，就会显示元素内部的内容</li><li><code>width</code>、<code>height</code>都是可选属性，用于定义<code>canvas</code>的宽高。默认宽高为<code>300px*150px</code>。</li><li><code>id</code>属性用于绘制时，找到该画布。</li></ol><h3 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h3><p><code>canvas</code>元素的<code>getContext()</code>方法可以获取渲染上下文和绘功能，参数’2d’表示开启 2D 绘图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let my_canvas=document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">let ctx=canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure><p>检查 JS 的支持性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(my_canvas.getContext)&#123;</span><br><span class="line">    let ctx=my_canvas.getContext(&apos;2d&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //不支持canvas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p><strong>矩形</strong></p><ul><li><code>fillRect(x,y,width,height)</code> 绘制填充矩形</li><li><code>strokeRect(x,y,width,height)</code> 绘制描边矩形</li><li><code>clearRect(x,y,width,height)</code> 清除指定矩形区域，让清除部分完全透明<br><code>x,y</code>指画布上所绘制矩形的左上角（相对于画布的左上角（0，0））<br><code>width,height</code>设置矩形的尺寸</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(10, 10, 100, 100);</span><br><span class="line">    ctx.clearRect(20, 20, 80, 80);</span><br><span class="line">    ctx.strokeRect(40, 40, 40, 40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img1.png" alt="矩形"></p><p><strong>路径/直线</strong></p><ul><li><code>beginPath()</code> 开始一条新路径</li><li><code>closePath()</code> 闭合路径，会自动将起点和终点连接起来，如果不需要连接，可以不使用。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</li><li><code>stroke()</code> 绘制图形轮廓</li><li><code>fill()</code> 填充路径内容区域的生成的实心图形</li><li><code>moveTo()</code> 将笔触移动到指定的坐标<code>(x,y)</code>上</li><li><code>lineTo()</code> 绘制一条从当前位置到坐标<code>(x,y)</code>上的直线</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(20, 20);</span><br><span class="line">    ctx.lineTo(100, 20);</span><br><span class="line">    ctx.lineTo(100, 100);</span><br><span class="line">    ctx.closePath()</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(150, 20);</span><br><span class="line">    ctx.lineTo(230, 20)</span><br><span class="line">    ctx.lineTo(230, 100)</span><br><span class="line">    ctx.fill()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img2.png" alt="三角形"></p><p><strong>圆弧</strong></p><ul><li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code><br>画一个以<code>(x,y)</code>为圆心，以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认顺时针）来生成。</p><ul><li><code>startAngle</code>以及<code>endAngle</code>参数用弧度定义了开始以及结束的弧度，都是以<code>x</code>轴为基准。<br>单位是弧度不是角度，<code>弧度=(Math.PI/180)*角度</code></li><li><code>anticlockwise</code>为<code>true</code>是逆时针，否则为顺时针</li></ul></li><li><p><code>arcTo(x1,y1,x2,y2,radius)</code><br>从坐标<code>(x1,y1)</code>到坐标<code>(x2,y2)</code>以半径 radius 画一段圆弧，再以直线连接两个控制点。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    let endAngle = (Math.PI / 180) * 360;</span><br><span class="line">    ctx.arc(30, 30, 20, 0, endAngle);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.closePath();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(60, 20); // 创建开始点</span><br><span class="line">    ctx.lineTo(100, 20); // 创建水平线</span><br><span class="line">    ctx.arcTo(150, 20, 150, 70, 50); // 创建弧</span><br><span class="line">    ctx.lineTo(150, 100); // 创建垂直线</span><br><span class="line">    ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img3.png" alt="圆弧"></p><p><strong>贝塞尔曲线</strong></p><ul><li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code><br>二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点</li><li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code><br>三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点一，<code>x,y</code>为结束点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 25);</span><br><span class="line">    ctx.quadraticCurveTo(25, 25, 25, 62.5);</span><br><span class="line">    ctx.quadraticCurveTo(20, 130, 75, 130);</span><br><span class="line">    ctx.quadraticCurveTo(75, 160, 65, 160)</span><br><span class="line">    ctx.quadraticCurveTo(80, 160, 100, 130)</span><br><span class="line">    ctx.quadraticCurveTo(160, 130, 150, 62.5)</span><br><span class="line">    ctx.quadraticCurveTo(150, 20, 75, 25)</span><br><span class="line">    ctx.stroke()</span><br><span class="line">    ctx.closePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img4.png" alt="二次贝塞尔"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 40);</span><br><span class="line">    ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);</span><br><span class="line">    ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5)</span><br><span class="line">    ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);</span><br><span class="line">    ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);</span><br><span class="line">    ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);</span><br><span class="line">    ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img5.png" alt="三次贝塞尔"></p><h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3><p>返回一个初始化的 Path2D 对象，参数可以是一个路径或 SVG path 数据的字符串，就是创建参数的副本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Path2D();</span><br><span class="line">new Path2D(path); //克隆Path对象</span><br><span class="line">new Path2D(svg);  //从svg建立Path对象</span><br></pre></td></tr></table></figure><p><code>path2D.addPath(path[,transform])</code>也可以给对象添加新路径或变化矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let rectangle = new Path2D()</span><br><span class="line">    rectangle.rect(10, 10, 50, 50)</span><br><span class="line"></span><br><span class="line">    let circle = new Path2D()</span><br><span class="line">    circle.moveTo(125, 35);</span><br><span class="line">    circle.arc(100, 35, 25, 0, 2 * Math.PI)</span><br><span class="line">    ctx.stroke(rectangle);</span><br><span class="line">    ctx.fill(circle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img6.png" alt="Path2D"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);</span><br><span class="line">    ctx.stroke(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img7.png" alt="Path2D1"></p><h3 id="样式和颜色"><a href="#样式和颜色" class="headerlink" title="样式和颜色"></a>样式和颜色</h3><ul><li><p>填充颜色<br><code>fillStyle=color</code>，设置图形的填充颜色</p></li><li><p>轮廓颜色<br><code>strokeStyle=color</code>，设置图形轮廓的颜色<br>默认填充颜色和轮廓颜色都是黑色（<code>&#39;#000&#39;</code>/<code>&#39;black&#39;</code>/<code>rgba(0,0,0,1)</code>）的。<code>color</code>可以是颜色值，渐变对象或图案对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;,0)`;</span><br><span class="line">            ctx.fillRect(j * 25, i * 25, 25, 25)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img8.png" alt="fillStyle"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 6; j++) &#123;</span><br><span class="line">            ctx.strokeStyle = `rgb(0,$&#123;Math.floor(255-42.5*i)&#125;,$&#123;Math.floor(255-42.5*j)&#125;)`;</span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.arc(12.5 + j * 25, 12.5 + i * 25, 10, 0, 2 * Math.PI, true);</span><br><span class="line">            ctx.stroke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img9.png" alt="strokeStyle"></p><ul><li>透明度<br><code>globalAlpha=transparent</code><br>设置整个<code>canvas</code>里所有图形的透明度，范围是 0.0(完全透明)到 1.0(完全不透明)。<br>同样可以设置<code>strokeStyle</code>或<code>fillStyle</code>的值为透明度（<code>rgba</code>）的颜色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line">  // 画背景</span><br><span class="line">  ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">  ctx.fillRect(0,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#6C0&apos;;</span><br><span class="line">  ctx.fillRect(75,0,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#09F&apos;;</span><br><span class="line">  ctx.fillRect(0,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#F30&apos;;</span><br><span class="line">  ctx.fillRect(75,75,75,75);</span><br><span class="line">  ctx.fillStyle = &apos;#FFF&apos;;</span><br><span class="line"></span><br><span class="line">  // 设置透明度值</span><br><span class="line">  ctx.globalAlpha = 0.2;</span><br><span class="line"></span><br><span class="line">  // 画半透明圆</span><br><span class="line">  for (var i=0;i&lt;7;i++)&#123;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(75,75,10+10*i,0,Math.PI*2,true);</span><br><span class="line">      ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img11.png" alt="globalAlpha"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    //背景</span><br><span class="line">    ctx.fillStyle = &apos;#FD0&apos;;</span><br><span class="line">    ctx.fillRect(0, 0, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#6C0&quot;;</span><br><span class="line">    ctx.fillRect(0, 50, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;;</span><br><span class="line">    ctx.fillRect(0, 100, 220, 50);</span><br><span class="line">    ctx.fillStyle = &quot;#F30&quot;;</span><br><span class="line">    ctx.fillRect(0, 150, 220, 50);</span><br><span class="line">    ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line"></span><br><span class="line">    //画透明度圆</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">            ctx.fillStyle = `rgba(255,255,255,$&#123;i*0.1&#125;)`;</span><br><span class="line">            ctx.fillRect(10 + i * 20, j * 50, 20, 50)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img10.png" alt="rgba"></p><ul><li><p>线型 line styles</p><ul><li><p><code>lineWidth=value</code>，设置线条宽度，默认为 1.0，必须为正数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(5 + i * 15, 5);</span><br><span class="line">        ctx.lineWidth = i + 1;</span><br><span class="line">        ctx.lineTo(5 + i * 15, 100);</span><br><span class="line">        ctx.stroke()</span><br><span class="line">        ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img12.png" alt="线宽"></p></li><li><p><code>lineCap=type</code>，设置线条末端样式</p><ul><li><code>butt</code>：默认，方头与辅助线齐平</li><li><code>round</code>：圆头，半径为宽度的一半</li><li><code>square</code>：方头，端点处加上了等宽且高度为一半线宽的方块。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      let lineCap = [&apos;butt&apos;, &apos;round&apos;, &apos;square&apos;];</span><br><span class="line">      //辅助线</span><br><span class="line">      ctx.strokeStyle = &apos;#09f&apos;;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.moveTo(10, 10);</span><br><span class="line">      ctx.lineTo(140, 10);</span><br><span class="line">      ctx.moveTo(10, 140);</span><br><span class="line">      ctx.lineTo(140, 140);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      //线条</span><br><span class="line">      ctx.strokeStyle = &apos;black&apos;;</span><br><span class="line">      for (let i = 0; i &lt; lineCap.length; i++) &#123;</span><br><span class="line">          ctx.lineWidth = 15;</span><br><span class="line">          ctx.lineCap = lineCap[i];</span><br><span class="line">          ctx.beginPath();</span><br><span class="line">          ctx.moveTo(30 + 40 * i, 10);</span><br><span class="line">          ctx.lineTo(30 + 40 * i, 140);</span><br><span class="line">          ctx.stroke();</span><br><span class="line">          ctx.closePath()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img13.png" alt="线头"></p><ul><li><code>lineJoin=type</code>，设定线条与线条间结合处的样式<ul><li><code>round</code>，</li><li><code>bevel</code>，</li><li><code>miter</code>，默认</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let lineJoin = [&apos;round&apos;, &apos;bevel&apos;, &apos;miter&apos;];</span><br><span class="line">    for (let i = 0; i &lt; lineJoin.length; i++) &#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.lineWidth = 15;</span><br><span class="line">        ctx.lineJoin = lineJoin[i];</span><br><span class="line">        ctx.moveTo(20, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(70, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(120, 20 + i * 50);</span><br><span class="line">        ctx.lineTo(170, 70 + i * 50);</span><br><span class="line">        ctx.lineTo(220, 20 + i * 50);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.closePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img14.png" alt="交接处"></p><ul><li><code>miterLimit=value</code>，限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li><li><code>getLineDash()</code>，返回一个包含当前虚线的样式，长度为非负偶数的数组。</li><li><code>setLineDash(segments)</code>，设置当前虚线样式。</li><li><code>lineDashOffset=value</code>，设置虚线样式的起始偏移量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var offset = 0;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line">    let my_canvas = document.getElementById(&apos;my_canvas&apos;);</span><br><span class="line">    if (my_canvas.getContext) &#123;</span><br><span class="line">        let ctx = my_canvas.getContext(&apos;2d&apos;);</span><br><span class="line">        ctx.clearRect(0, 0, my_canvas.width, my_canvas.height);</span><br><span class="line">        ctx.setLineDash([4, 2]); //实线长度，空线长度</span><br><span class="line">        ctx.lineDashOffset = -offset;</span><br><span class="line">        ctx.strokeRect(10, 10, 100, 100);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //不支持canvas</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function march() &#123;</span><br><span class="line">    offset++;</span><br><span class="line">    if (offset &gt; 16) &#123;</span><br><span class="line">        offset = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br><span class="line">    setTimeout(march, 50);</span><br><span class="line">&#125;</span><br><span class="line">march();</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img15.png" alt="蚂蚁线"></p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ul><li><code>createLinearGradient(x1, y1, x2, y2)</code><br>渐变起点（x1,y1）终点（x2,y2);</li><li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code><br>定义两个圆：一个是小圆，是外面大圆的反光，以（x1,y1）为圆点，r1 为圆心，另一个以（x2,y2）为圆心，r2 为半径。</li><li><code>gradient.addColorStop(position, color)</code><br>给创建的渐变对象<code>gradient</code>上色，<br><code>position</code>：渐变颜色的所在位置，[0.0, 1.0]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let linegrad = ctx.createLinearGradient(0, 0, 0, 150);</span><br><span class="line">    linegrad.addColorStop(0, &apos;#00ABEB&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#fff&apos;);</span><br><span class="line">    linegrad.addColorStop(0.5, &apos;#26C000&apos;);</span><br><span class="line">    linegrad.addColorStop(1, &apos;#fff&apos;);</span><br><span class="line">    let linegrad1 = ctx.createLinearGradient(0, 50, 0, 95);</span><br><span class="line">    linegrad1.addColorStop(0.5, &apos;#000&apos;);</span><br><span class="line">    linegrad1.addColorStop(1, &quot;rgba(0,0,0,0)&quot;)</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = linegrad;</span><br><span class="line">    ctx.strokeStyle = linegrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.strokeRect(50, 50, 50, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一是背景渐变，<br>第二种渐变不是从 0.0 开始的，所以 0-0.5 都是黑色的。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img16.png" alt="线性渐变色"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let radgrad = ctx.createRadialGradient(45, 55, 10, 52, 50, 30);</span><br><span class="line">    radgrad.addColorStop(0, &apos;#47d30C&apos;);</span><br><span class="line">    radgrad.addColorStop(0.9, &apos;#019F62&apos;);</span><br><span class="line">    radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);</span><br><span class="line"></span><br><span class="line">    let radgrad1 = ctx.createRadialGradient(95, 15, 15, 102, 20, 40);</span><br><span class="line">    radgrad1.addColorStop(0, &apos;#00C9FF&apos;)</span><br><span class="line">    radgrad1.addColorStop(0.8, &apos;#00B5E2&apos;)</span><br><span class="line">    radgrad1.addColorStop(1, &apos;rgba(0,201,255,0)&apos;);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad1;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = radgrad;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img17.png" alt="镜像渐变色"></p><h3 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h3><ul><li><code>createPattern(image,type)</code><ul><li><code>image</code>：是一个<code>image</code>对象的引用，或另一个<code>canvas</code>对象。</li><li><code>type</code>：<code>repeat</code>，<code>repeat-x</code>,<code>repeat-y</code>,<code>no-repeat</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        //创建图案</span><br><span class="line">        let ptrn = ctx.createPattern(img, &apos;repeat&apos;);</span><br><span class="line">        ctx.fillStyle = ptrn;</span><br><span class="line">        ctx.fillRect(0, 0, 150, 150)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img18.png" alt="图片"></p><h3 id="阴影-shadows"><a href="#阴影-shadows" class="headerlink" title="阴影 shadows"></a>阴影 shadows</h3><ul><li><code>shadowOffsetX=float</code></li><li><code>shadowOffsetY=float</code><br><code>shadowOffsetX</code> 和 <code>shadowOffsetY</code> 用来设定阴影在<code>X</code>和 <code>Y</code>轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li><li><code>shadowBlur=float</code><br>用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li><li><p><code>shadowColor=color</code><br>阴影颜色，默认是全透明的黑色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.shadowOffsetX = 2;</span><br><span class="line">    ctx.shadowOffsetY = 2;</span><br><span class="line">    ctx.shadowBlur = 2;</span><br><span class="line">    ctx.shadowColor = &quot;rgba(255,0,0,0.5)&quot;;</span><br><span class="line"></span><br><span class="line">    ctx.font = &apos;20px times New Roman&apos;;</span><br><span class="line">    ctx.fillStyle = &quot;black&quot;;</span><br><span class="line">    ctx.fillText(&apos;Sample String&apos;, 5, 50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/img19.png" alt="文字阴影"></p><h3 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h3><p>用<code>fill</code>,<code>clip</code>,<code>isPointinPath</code>填充，可以使用以下填充规则：</p><ul><li><code>nonzero</code>：non-zero winding rule,默认值</li><li><code>evenodd</code>：even-odd winding rule，颜色间隔出现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(50, 50, 50, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 30, 0, Math.PI * 2);</span><br><span class="line">    ctx.arc(50, 50, 10, 0, Math.PI * 2);</span><br><span class="line">    ctx.fill(&apos;evenodd&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img20.png" alt="填充规则"></p><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul><li><code>fillText(text,x,y[,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选。</li><li><p><code>strokeText(text, x, y [,maxWidth])</code><br>指定在<code>(x,y)</code>位置填充指定文本，绘制的最大宽度可选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.font = &apos;48px serif&apos;</span><br><span class="line">    ctx.fillText(&apos;fillText&apos;, 10, 50);</span><br><span class="line">    ctx.strokeText(&apos;strokeText&apos;, 10, 90)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img21.png" alt="文本"></p><p><strong>文本样式</strong></p><ul><li><code>font=value</code><br>与 css 属性相同，默认<code>10px sans-serif</code></li><li><p><code>textAlign=value</code> , 文本对齐方式</p><ul><li><code>start</code>默认</li><li><code>end</code></li><li><code>left</code></li><li><code>right</code></li><li><code>center</code></li></ul></li><li><p><code>textBaseline=value</code>，基线对齐选项</p><ul><li><code>top</code></li><li><code>hanging</code></li><li><code>middle</code></li><li><code>alphabetic</code>默认</li><li><code>ideographic</code></li><li><code>bottom</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">      ctx.strokeStyle = &apos;red&apos;;</span><br><span class="line">      ctx.font = &apos;28px serif&apos;</span><br><span class="line">      ctx.moveTo(0, 40);</span><br><span class="line">      ctx.lineTo(650, 40);</span><br><span class="line">      ctx.stroke();</span><br><span class="line">      ctx.textBaseline = &apos;top&apos;</span><br><span class="line">      ctx.fillText(&apos;top&apos;, 10, 40);</span><br><span class="line">      ctx.textBaseline = &apos;middle&apos;</span><br><span class="line">      ctx.fillText(&apos;middle&apos;, 60, 40)</span><br><span class="line">      ctx.textBaseline = &apos;hanging&apos;</span><br><span class="line">      ctx.fillText(&apos;hanging&apos;, 160, 40)</span><br><span class="line">      ctx.textBaseline = &apos;alphabetic&apos;</span><br><span class="line">      ctx.fillText(&apos;alphabetic&apos;, 270, 40)</span><br><span class="line">      ctx.textBaseline = &apos;ideographic&apos;</span><br><span class="line">      ctx.fillText(&apos;ideographic&apos;, 410, 40)</span><br><span class="line">      ctx.textBaseline = &apos;bottom&apos;</span><br><span class="line">      ctx.fillText(&apos;bottom&apos;, 560, 40)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img22.png" alt="基线"></p><ul><li><p><code>direction=value</code>,文本方向</p><ul><li><code>ltr</code></li><li><code>rtl</code></li><li><code>inherit</code> 默认</li></ul></li><li><p>预测量文本宽度</p></li></ul><p><code>measureText()</code><br>返回有个<code>TextMwtrics</code>对象的宽度、所在像素</p><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><h4 id="获取图像源"><a href="#获取图像源" class="headerlink" title="获取图像源"></a>获取图像源</h4><ul><li><p>获得需要绘制的图片</p><ul><li><code>HTMLImageElement</code><br>由<code>Image()</code>函数构造出来的元素，或者<code>&lt;img&gt;</code>元素</li><li><code>HTMLVideoElement</code><br><code>&lt;video&gt;&lt;/video&gt;</code>元素，从视频中抓取当前帧作为一个图像</li><li><code>HTMLCanvasElement</code><br>使用另外一个<code>&lt;canvas&gt;&lt;/canvas&gt;</code>元素作为图片源</li><li><code>ImageBitmap</code><br>高性能位图，可以低延迟的绘制。，它可以从上述的所有源以及其它几种源中生成。</li></ul></li><li><p>使用相同页面内的图片</p><p>获取当前页面的图片引用：</p><ul><li><code>document.images</code>集合</li><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementById()</code></li></ul></li><li><p>使用其他域名下的图片</p><p>如果图片允许跨域访问，可以正常渲染<code>canvas</code>，如果图片不允许跨域访问，会污染当前<code>canvas</code>.</p></li><li><p>使用其他 canvas 元素</p><p>获取 canvas 元素</p><ul><li><code>document.getElementsByTagName()</code></li><li><code>document.getElementById()</code></li></ul></li><li><p>由零开始创建图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.onload=function()&#123;</span><br><span class="line">    //执行drawImage语句</span><br><span class="line">&#125;</span><br><span class="line">img.src=&apos;img.png&apos;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>data.url</code>方式嵌入图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.src = &apos;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用视频帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getMyVideo() &#123;</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">if (canvas.getContext) &#123;</span><br><span class="line">    var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">    return document.getElementById(&apos;myvideo&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><ul><li><p><code>drawImage(image,x,y)</code></p><ul><li><code>image</code>就是用上面的方法获取的图片源，SVG 图像必须在 <code>&lt;svg&gt;</code> 根指定元素的宽度和高度。</li><li><code>x</code>,<code>y</code>，绘制图片左上角在画布中的起始坐标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 0, 0);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(30, 96);</span><br><span class="line">        ctx.lineTo(70, 66);</span><br><span class="line">        ctx.lineTo(102, 76);</span><br><span class="line">        ctx.lineTo(170, 15);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>drawImage(image,x,y,width,height)</code>;<br><code>width</code>和<code>height</code>用来控制当前<code>canvas</code>画入时应该缩放的大小</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                ctx.drawImage(img, j * 100, i * 80, 100, 80);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)</code><br>第一个参数同上还是图片源，<br>后面 8 个参数，前四个参数定义图像源的切片位置和大小，后四个定义切片的目标显示的位置和大小。<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img23.jpg" alt="切片"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">        ctx.drawImage(img, 300, 100, 1000, 1100, 10, 10, 200, 200)</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = &apos;bird.jpg&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染 frame</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Draw frame</span><br><span class="line">  ctx.drawImage(document.getElementById(&apos;frame&apos;),0,0);</span><br></pre></td></tr></table></figure><ul><li>控制图像的缩放行为<br><code>mozImageSmoothingEnabled</code>,默认为<code>true</code>，为<code>false</code>时图像不会平滑的缩放。<br><code>ctx.mozImageSmoothingEnabled = false;</code></li></ul><h3 id="变形-Transformation"><a href="#变形-Transformation" class="headerlink" title="变形 Transformation"></a>变形 Transformation</h3><h4 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h4><ul><li><strong><code>save()</code></strong> 保存画布的现在的状态</li><li><strong><code>restore()</code></strong><br>恢复<code>canvas</code>状态。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 500, 500);</span><br><span class="line">    ctx.save(); //存储黑色矩形</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = &quot;#09F&quot;</span><br><span class="line">    ctx.fillRect(50, 50, 400, 400)</span><br><span class="line"></span><br><span class="line">    ctx.save(); //存储蓝色矩形</span><br><span class="line">    ctx.fillStyle = &apos;white&apos;;</span><br><span class="line">    ctx.globalAlpha = 0.5;</span><br><span class="line">    ctx.fillRect(100, 100, 300, 300)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复蓝色矩形</span><br><span class="line">    ctx.fillRect(150, 150, 200, 200)</span><br><span class="line"></span><br><span class="line">    ctx.restore(); //恢复黑色矩形</span><br><span class="line">    ctx.fillRect(200, 200, 100, 100)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img24.png" alt="保存状态"></p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul><li><strong><code>translate(x, y)</code></strong><br><code>x</code>为左右偏移量，<code>y</code>为上下偏移量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">            ctx.save();</span><br><span class="line">            ctx.fillStyle = `rgb($&#123;51*i&#125;,$&#123;255-51*i&#125;,255)`;</span><br><span class="line">            ctx.translate(10 + j * 50, 10 + i * 50);</span><br><span class="line">            ctx.fillRect(0, 0, 25, 25);</span><br><span class="line">            ctx.restore()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img25.png" alt="移动"></p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul><li><strong><code>rotate(angle)</code></strong><br>角度<code>（angle）</code>是顺时针方向，以弧度为单位。<br>旋转的中心始终是<code>canvas</code>的原点<br><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img26.png" alt="旋转"></li></ul><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><strong><code>scale(x,y)</code></strong><br><code>x</code>为水平缩放，<code>y</code>为垂直缩放<br><code>x,y</code>都是实数，比 1 小会缩小图形，比 1 大会放大图片，默认为 1。<br>画布初始情况下， 是以左上角坐标为原点的第一象限。如果为负实数， <code>scale(-1,1)</code>以<code>y</code>轴作为对称轴镜像反转,<code>scale(1,-1)</code>以<code>x</code>轴作为对称轴镜像反转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    // //放大</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.scale(10, 3);</span><br><span class="line">    ctx.fillRect(1, 10, 10, 10);</span><br><span class="line">    ctx.restore();</span><br><span class="line"></span><br><span class="line">    // //镜像</span><br><span class="line">    ctx.scale(-1, 1);</span><br><span class="line">    ctx.font = &apos;48px serif&apos;;</span><br><span class="line">    ctx.fillText(&apos;MDN&apos;, -135, 120)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img27.png" alt="缩放"></p><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><ul><li><p><strong><code>transform(a,b,c,d,e,f)</code></strong><br>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：$\left[ \begin{array}{ccc} a &amp; c &amp; e \ b &amp; d &amp; f \ 0 &amp; 0 &amp; 1 \end{array} \right]$</p><ul><li><code>a(m11)</code>: 水平方向的缩放</li><li><code>b(m12)</code>: 水平方向的倾斜偏移</li><li><code>c(m21)</code>: 竖直方向的倾斜偏移</li><li><code>d(m22)</code>: 竖直方向的缩放</li><li><code>e(m31)</code>: 水平方向的移动</li><li><code>f(m32)</code>: 竖直方向的移动</li></ul></li><li><p><strong><code>setTransform(a,b,c,d,e,f)</code></strong><br>将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。该方法是取消了当前变形,然后设置为指定的变形,一步完成。</p></li><li><strong><code>resetTransform()</code></strong><br>重置当前变形为单位矩阵，它和调用以下语句是一样的：<code>ctx.setTransform(1, 0, 0, 1, 0, 0)</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    let sin = Math.sin(Math.PI / 6);</span><br><span class="line">    let cos = Math.cos(Math.PI / 6);</span><br><span class="line">    ctx.translate(100, 100);</span><br><span class="line">    let c = 0;</span><br><span class="line">    for (let i = 0; i &lt;= 12; i++) &#123;</span><br><span class="line">        c = Math.floor(255 / 12 * i);</span><br><span class="line">        ctx.fillStyle = `rgb($&#123;c&#125;,$&#123;c&#125;,$&#123;c&#125;)`;</span><br><span class="line">        ctx.fillRect(0, 0, 100, 10);</span><br><span class="line">        ctx.transform(cos, sin, -sin, cos, 0, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.setTransform(-1, 0, 0, 1, 100, 100);</span><br><span class="line">    ctx.fillStyle = &apos;rgba(255,128,255,.5)&apos;;</span><br><span class="line">    ctx.fillRect(0, 50, 100, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img28.png" alt="转换"></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>globalCompositeOperation=type</code><br>设定新绘制图形与原图形的遮盖方式。<br>目标画布-已有，新图像</p><ul><li><code>source-over</code>：默认，在现有画布上下文之上绘制新图形。</li><li><code>source-in</code>：新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。</li><li><code>source-out</code>： 在不与现有画布内容重叠的地方绘制新图形，重叠部分是透明的。</li><li><code>source-atop</code>： 新图形只在与现有画布内容重叠的地方绘制，原有画布非重叠部分不变。</li><li><code>destination-over</code>： 在现有的画布内容后面绘制新的图形。</li><li><code>destination-in</code>： 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。</li><li><code>destination-out</code>：现有内容保持在新图形不重叠的地方，其他地方透明。</li><li><code>destination-atop</code>：现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。</li><li><code>lighter</code>：两个重叠图形的颜色是通过颜色值相加来确定的。</li><li><code>copy</code>：只显示新图形。</li><li><code>xor</code>：图像中，那些重叠和正常绘制之外的其他地方是透明的。</li><li><code>multiply</code>：将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。</li><li><code>screen</code>：像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。</li><li><code>overlay</code>：<code>multiply</code>和<code>screen</code>的结合，原本暗的地方更暗，原本亮的地方更亮。</li><li><code>darken</code>：保留两个图层中最暗的像素。</li><li><code>lighten</code>：保留两个图层中最亮的像素。</li><li><code>color-dodge</code>：将底层除以顶层的反置。</li><li><code>color-burn</code>：将反置的底层除以顶层，然后将结果反过来。</li><li><code>hard-light</code>：屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。</li><li><code>soft-light</code>：用顶层减去底层或者相反来得到一个正值。</li><li><code>difference</code>：一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。</li><li><code>exclusion</code>：和 difference 相似，但对比度较低。<br>…</li></ul><h3 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h3><p><code>clip()</code>将当前正在构建的路径转换为当前的裁剪路径。<br>默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function draw(ctx) &#123;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line">    ctx.translate(75, 75);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(0, 0, 60, 0, Math.PI * 2, true);</span><br><span class="line">    ctx.clip();</span><br><span class="line">    //画圆形背景</span><br><span class="line">    let lingrad = ctx.createLinearGradient(0, -75, 0, 75);</span><br><span class="line">    lingrad.addColorStop(0, &quot;#232256&quot;);</span><br><span class="line">    lingrad.addColorStop(1, &quot;#143778&quot;);</span><br><span class="line">    ctx.fillStyle = lingrad;</span><br><span class="line">    ctx.fillRect(-75, -75, 150, 150);</span><br><span class="line">    //画星星</span><br><span class="line">    for (let j = 1; j &lt; 50; j++) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.fillStyle = &apos;#fff&apos;;</span><br><span class="line">        ctx.translate(75 - Math.floor(Math.random() * 150), 75 - Math.floor(Math.random() * 150));</span><br><span class="line">        drawStar(ctx, Math.floor(Math.random() * 4) + 2);</span><br><span class="line">        ctx.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drawStar(ctx, r) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(r, 0);</span><br><span class="line">        for (let i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">            ctx.rotate(Math.PI / 5);</span><br><span class="line">            if (i % 2 === 0) &#123;</span><br><span class="line">                ctx.lineTo((r / 0.525731) * 0.200811, 0)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ctx.lineTo(r, 0)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.closePath();</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/23/html5-canvas基础/_posts/html5-canvas基础/img29.png" alt="星星"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;canvas 用法&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-音视频处理</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-音视频处理/</id>
    <published>2020-07-23T07:06:29.000Z</published>
    <updated>2020-07-23T07:13:10.692Z</updated>
    
    <content type="html"><![CDATA[<p>html5 音视频标签使用</p><a id="more"></a><h3 id="音视频处理"><a href="#音视频处理" class="headerlink" title="音视频处理"></a>音视频处理</h3><ul><li><p>video</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">  &lt;source src=&apos;foo.ogg&apos; type=&apos;video/ogg&apos; /&gt;</span><br><span class="line">  &lt;source src=&apos;foo.mp4&apos; type=&apos;video/mp4&apos; /&gt;</span><br><span class="line">  浏览器不支持视频播放</span><br><span class="line">&lt;/video&gt;</span><br><span class="line">&lt;audio controls&gt;</span><br><span class="line">  &lt;source src=&quot;3.mp3&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.wav&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;3.ogg&quot;&gt;</span><br><span class="line">  浏览器不支持音频播放</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>width:宽度</li><li>height:高度</li><li>controls：播放控件</li><li>autoplay：视频加载完成后马上播放</li><li>loop：循环播放</li><li>muted：表示视频静音输出</li><li>poster：视频海报，用于在用户播放或跳帧之前展示，如果属性未指定，第一帧可用之前什么都不展示，之后第一帧就作为海报。</li><li>preload：预加载，<ul><li>none 不加载</li><li>auto (默认)自动（尽快加载完毕）</li><li>metadata 只加载除视频之外的信息（宽高）</li></ul></li></ul></li><li><p>audio<br>操作 DOM 方法</p><ul><li>play 开始播放</li><li>pause 暂停播放</li><li>error 媒体播放出错错误时触发</li><li>canPlayType(type)：查看浏览器是否支持这种文件格式的媒体文件。</li></ul></li></ul><p>操作 DOM 属性</p><ul><li>paused 是否处于暂停或者未播放状态</li><li>ended 是否已经结束播放</li><li>duration 返回媒体时长，秒为单位</li><li>currentTime 获取或设置媒体播放位置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;html5 音视频标签使用&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-语义化标签</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-语义化标签/</id>
    <published>2020-07-23T07:03:40.000Z</published>
    <updated>2020-07-23T07:06:03.372Z</updated>
    
    <content type="html"><![CDATA[<p>html 语义化标签<br><a id="more"></a></p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>元素分类：</p><ul><li><p>块级元素</p><ul><li>独占一行</li><li>可以设置宽高</li><li>不设置宽度时，继承父元素宽度</li><li><p>不设置高度时，就是本身内容的高度</p><p>常用：<code>div</code>,<code>p</code>,<code>h1...h6</code>,<code>ul</code>,<code>ol</code>,<code>dl</code>,<code>form</code>,<code>section</code>,<code>nav</code>,<code>aside</code><br>转换成块级元素：<code>display:block</code></p></li></ul></li><li><p>行内块元素</p><ul><li>和其他行内元素和行内块元素在一行</li><li><p>元素的 width，height，padding，margin 可以设置</p><p>常用：<code>img</code>,<code>input</code>,<br>转换成行内块元素：<code>display:inline-block</code>，<code>float:left/right</code>，<code>position:absolute/fixed</code></p></li></ul></li><li><p>行内元素</p><ul><li>和其他行内元素和行内块元素在一行</li><li>元素的宽度就是他包含的文字和图片的宽度，不可改变。</li><li>元素高度 height 设置无效，可以设置 line-height</li><li>margin,padding 的上下对布局无效，左右可以。</li><li><p>内联元素只能包含文本、内联元素、行内块元素</p><p>常用：<code>span</code>,<code>a</code>,<code>br</code>,<code>em</code>,<code>strong</code><br>转换成行内元素：<code>display:inline</code></p></li></ul></li></ul><h3 id="重学前端——语义化标签"><a href="#重学前端——语义化标签" class="headerlink" title="重学前端——语义化标签"></a>重学前端——语义化标签</h3><ul><li><p>缩写 abbr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;abbr title=&quot;World Wide Web&quot;&gt;WWW&lt;/abbr&gt;</span><br></pre></td></tr></table></figure></li><li><p>分隔线<br>hr - 表示故事走向的转变或话题的转变<br>border - 纯粹的视觉效果</p></li><li><p>注释<br>p 标签+class=’note’</p></li><li><p>加粗<br>strong 表示文本十分重要<br>em 表示强调，可以嵌套，越多层级 表示更大程度的强调</p></li><li><p>引用</p></li><li>blockquote 表示段落级引述内容，</li><li>q 表示行内的引述内容</li><li>cite 表示引述的作品名</li><li><p>时间 time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;time datetime=&apos;2019-01-25&apos;&gt;25 Jan 2019&lt;/time&gt;</span><br></pre></td></tr></table></figure></li><li><p>文章中的图像<br>figure 用于表示与主文章相关的图像、照片等流内容<br>figcaption 照片图片的描述文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">    &lt;img src=&apos;http://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E6%96%B0%E9%B2%9C%E4%BA%8B&amp;tn=SE_PclogoS_8whnvm25&amp;sa=ire_dl_gh_logo&amp;rsv_dl=igh_logo_pcs&apos;&gt;</span><br><span class="line">    &lt;figcaption&gt;百度logo&lt;/figcaption&gt;</span><br><span class="line">&lt;/figure&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义 ghh<br>dfn 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The &lt;dfn&gt;Internet&lt;/dfn&gt; is balalalal</span><br></pre></td></tr></table></figure></li><li><p>固定格式</p><p>samp 计算机输出<br>pre 格式不根据浏览变化<br>code 代码段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">    &lt;code&gt;&gt;</span><br><span class="line">        &amp;lt;html&amp;gt;</span><br><span class="line">            &amp;lt;head&amp;gt;</span><br><span class="line">            &amp;lt;/head&amp;gt;</span><br><span class="line">            &amp;lt;body&amp;gt;</span><br><span class="line">            &amp;lt;/body&amp;gt;</span><br><span class="line">        &amp;lt;/html&amp;gt;</span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;html 语义化标签&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>html5-表单元素</title>
    <link href="https://dorisfeng.github.io/2020/07/23/html5-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/"/>
    <id>https://dorisfeng.github.io/2020/07/23/html5-表单元素/</id>
    <published>2020-07-23T07:03:30.000Z</published>
    <updated>2020-07-23T08:45:31.614Z</updated>
    
    <content type="html"><![CDATA[<p>新增表单元素<br>兼容性存在问题，并且不同浏览器样式不同</p><a id="more"></a><h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><h3 id="新增输入类型"><a href="#新增输入类型" class="headerlink" title="新增输入类型"></a>新增输入类型</h3><p><strong><code>Input</code> 类型</strong></p><ul><li>email：电子邮件</li><li><p>tel：电话号码</p></li><li><p>url：网页的 url(需要 <code>http(s)://</code>)</p></li><li>search：搜索</li><li>range：数值控件。特定范围内的数值选择器</li><li>number：数字</li><li>date：日期，选取年、月、日</li><li>month：选取月、年</li><li>week：选取周和年</li><li>time：选取时间（小时和分钟）</li><li>datetime：选取时间、日、月、年（UTC 时间）</li><li>datetime-local：选取时间、日、月、年（本地时间）</li></ul><p>其中 range 和 number 还可以配合下面属性使用</p><ul><li>min：允许最小值</li><li>max：允许最大值</li><li>step：步数</li><li>value：默认值</li></ul><h3 id="新增表单元素"><a href="#新增表单元素" class="headerlink" title="新增表单元素"></a>新增表单元素</h3><ul><li><p>datalist<br>选择列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;url_list&quot;&gt;</span><br><span class="line">    &lt;option label=&quot;W3School&quot; value=&quot;http://www.W3School.com.cn&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;</span><br><span class="line">    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure></li><li><p>keygen<br>提供一种验证用户的可靠方法。<br>密钥对生成器，提价表单时，生成一个私钥和一个公钥。<br>私钥（private key）存储于客户端，公钥（public key）被发送到服务器，公钥用于之后验证用户的客户端证书。<br>目前浏览器不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;demo_form.asp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">  Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt;</span><br><span class="line">  Encryption: &lt;keygen name=&quot;security&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>output<br>用于不同类型的输出</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;output id=&apos;result&apos; onforminput=&apos;resCalc()&apos;&gt;&lt;/output&gt;</span><br></pre></td></tr></table></figure><h3 id="表单验证属性"><a href="#表单验证属性" class="headerlink" title="表单验证属性"></a>表单验证属性</h3><ol><li><p>pattern<br>属性确保值与正则表达式匹配<br>用于验证文本、链接、电话，邮件，密码等形式的输入元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">   &lt;label for=&quot;name&quot;&gt; Name: &lt;input type=&quot;text&quot; id=&quot;name&quot;</span><br><span class="line">     name=&quot;name&quot; pattern=&quot;^.* .*$&quot; /&gt;</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>确保用户输入两个名称，用空格分隔</p></li><li><p>min,max<br>适用范围、数字、日期、月、周、时间、本地时间等类型的输入元素</p></li></ol><ul><li>用于验范围或数字是否大于等于或小于等于设定值</li><li>用于验时间是否早于或晚于设定值</li></ul><ol start="3"><li>required<br>是否必填</li><li>formnovalidate<br>禁用原生验证</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://example.com/form&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;email&quot;&gt; Email: &lt;input type=&quot;email&quot;</span><br><span class="line">        placeholder=&quot;user@mydomain.com&quot; required pattern=&quot;.*@mydomain.com$&quot;</span><br><span class="line">        id=&quot;email&quot; name=&quot;email&quot; /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;input type=&quot;submit&quot;</span><br><span class="line">      value=&quot;Save&quot; formnovalidate /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新增表单元素&lt;br&gt;兼容性存在问题，并且不同浏览器样式不同&lt;/p&gt;
    
    </summary>
    
      <category term="html5" scheme="https://dorisfeng.github.io/categories/html5/"/>
    
    
  </entry>
  
  <entry>
    <title>LESS</title>
    <link href="https://dorisfeng.github.io/2020/07/21/LESS/"/>
    <id>https://dorisfeng.github.io/2020/07/21/LESS/</id>
    <published>2020-07-21T01:58:09.000Z</published>
    <updated>2020-07-21T14:05:17.381Z</updated>
    
    <content type="html"><![CDATA[<p>一些 less 的用法</p><a id="more"></a><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@link-color:#428bca;</span><br><span class="line">@link-color-hover:darken(@link-color, 10%);</span><br><span class="line">a&#123;</span><br><span class="line">    color:@link-color</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        color:@link-color-hover</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅可以使用变量存储属性值，还可以使用变量存储公用的 URL、选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.@(selector)&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    @&#123;property&#125;:#000;</span><br><span class="line">    background:url(&quot;@&#123;bgImg/test.png&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@selector:box;</span><br><span class="line">@bigImg:&quot;../img&quot;;</span><br><span class="line">@property:color</span><br></pre></td></tr></table></figure><h2 id="混合（Mixins）"><a href="#混合（Mixins）" class="headerlink" title="混合（Mixins）"></a>混合（<code>Mixins</code>）</h2><p><strong>1. 基本使用</strong><br>混合可以将一个定义好的<code>class A</code>轻松的引入到另一个<code>class B</code>中，从而简单实现<code>class B</code>继承 <code>class A</code>中的所有属性。我们还可以带参数地调用，就像使用函数一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是将<code>public</code>设定的样式属性复制一份到实际样式中。如果想要在编译完成后不输出<code>public</code>样式的结果，写法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//less</span><br><span class="line">.public()&#123;//-&gt;在选择器后面加上()就可以不编译这个样式了</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    .public; //如果public有子孙元素的样式，同样也会被复制过来</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. extend</strong><br>上面的方法是把<code>public</code>样式复制一遍，编译后的<code>CSS</code>还是会很大，可以使用<code>extend</code>避免这一点<br><strong>和原来的选择器共用一套样式，但要保证原来的选择器不加括号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> //-&gt;LESS代码</span><br><span class="line">.public &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    &amp;:extend(.public);</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">//-&gt;编译为CSS的结果</span><br><span class="line">.public, nav ul &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">nav ul &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><p>LESS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">    .navigation&#123;</span><br><span class="line">        font-size:12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .logo&#123;</span><br><span class="line">        width:300px;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            text-decoration:none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#header&#123;</span><br><span class="line">    color:black;</span><br><span class="line">&#125;</span><br><span class="line">#header .navigation&#123;</span><br><span class="line">    font-size:12px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo&#123;</span><br><span class="line">    width:300px</span><br><span class="line">&#125;</span><br><span class="line">#header .logo:hover&#123;</span><br><span class="line">    text-decoration:none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和运算"><a href="#函数和运算" class="headerlink" title="函数和运算"></a>函数和运算</h2><p>运算提供了加、减、乘、除操作。可以对属性值和颜色做运算，实现属性值之间的复杂关系。<br>任何数字、颜色或者变量都可以参与运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@base: 5%;</span><br><span class="line">@filter: @base * 2; //10%</span><br><span class="line">@other: @base + @filter; //15%</span><br><span class="line">color: #888/4; //#222</span><br><span class="line">@base-color:#111;</span><br><span class="line">background-color: @base-color+#111;//#222</span><br><span class="line">height: 100%/2 + @filter;//60%</span><br></pre></td></tr></table></figure><p>颜色运算函数，颜色会被转化为<code>HSL</code>色彩空间，然后在通道级别操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lighten(@color, 10%); //变亮10%</span><br><span class="line">darken(@color, 10%); //变暗10%</span><br></pre></td></tr></table></figure><p>数学函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round(1.67); //2</span><br><span class="line">ceil(2.3);//3</span><br><span class="line">floor(2.6); //2</span><br></pre></td></tr></table></figure><h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><p>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@var:red;</span><br><span class="line">#page&#123;</span><br><span class="line">    @var:white;</span><br><span class="line">    #header&#123;</span><br><span class="line">        color:@var; //white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#footer&#123;</span><br><span class="line">    color:@var; //red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些 less 的用法&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://dorisfeng.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>响应式布局</title>
    <link href="https://dorisfeng.github.io/2020/07/20/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://dorisfeng.github.io/2020/07/20/响应式布局/</id>
    <published>2020-07-20T08:25:08.000Z</published>
    <updated>2020-07-21T01:44:52.139Z</updated>
    
    <content type="html"><![CDATA[<p>一个页面适配多种设备和多个屏幕</p><a id="more"></a><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p><code>viewport</code>，浏览器中用于呈现网页的区域，视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下。<br>手机端与<code>PC</code>端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。<code>iOS</code>, <code>Android</code> 基本都将这个视口分辨率设置为 980px。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&apos;viewport&apos; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><code>width=device-width</code>：视口为设备宽度，手机厂商设置或默认 980px</li><li><code>initial-scale=1.0</code>：初始化的视口大小为 1.0 倍</li><li><code>maxmum-scale=1.0</code>：最大的倍数是 1.0 倍</li><li><code>user-scalable=no</code>：不允许缩放视口</li></ul><h2 id="手机浏览器内核"><a href="#手机浏览器内核" class="headerlink" title="手机浏览器内核"></a>手机浏览器内核</h2><ul><li>微软 <code>Trident</code></li><li>火狐 <code>Gecko</code></li><li>开源内核 <code>Webkit</code></li><li>Opera <code>Presto</code><br>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浏览器兼容前缀</span><br><span class="line">-ms-</span><br><span class="line">-moz-</span><br><span class="line">-o-</span><br><span class="line">-webkit-</span><br></pre></td></tr></table></figure><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>针对特定的设备或条件为网页应用特定的 css 样式。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>媒体查询外面写的第一条规则是基本的样式，适用于任何设备，然后为不同的视口，不同能力的设备，添加不同效果。<br>需要配合视口使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: grey;</span><br><span class="line"> &#125;</span><br><span class="line">@media screen and (min-width:1200px)&#123; //宽度大于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: pink;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> @media screen and (min-width:700px) and (max-width:1200px)&#123; //宽度大于700像素小于1200像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:700px)&#123;//宽度小于700像素</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>screen</code>表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号匹配可能性。</p><h2 id="rem-响应式布局"><a href="#rem-响应式布局" class="headerlink" title="rem 响应式布局"></a>rem 响应式布局</h2><p>rem:当前页面中元素的<code>REM</code>单位的样式值都是针对于<code>HTML</code>元素的<code>font-size</code>的值进行动态计算的。<br>em:表示当前父元素的字号的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div style=&apos;font-size:10px&apos;&gt;</span><br><span class="line">    &lt;span&gt;box1&lt;/span&gt;</span><br><span class="line">    &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">        &lt;span&gt;box2&lt;/span&gt;</span><br><span class="line">        &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">            &lt;span&gt;box3&lt;/span&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&apos;font-size:2em&apos;&gt;</span><br><span class="line">                    &lt;span&gt;box4&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/20/响应式布局/img1.png" alt="em"></p><p><code>rem</code> 可以和媒体查询配合实现响应式布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width: 320px) &#123;</span><br><span class="line">    html &#123;font-size: 14px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 360px) &#123;</span><br><span class="line">    html &#123;font-size: 16px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 400px) &#123;</span><br><span class="line">    html &#123;font-size: 18px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>分比布局也叫作流式布局、弹性盒布局。<br>使用百分比设置<code>width</code>，<code>height</code>，<code>padding</code>，<code>margin</code></p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>如果移动端和 PC 端公用一套代码，建议使用流式布局。<br><strong>如何做一个 REM 响应式布局</strong></p><ol><li>从 <code>UI</code> 设计师拿到<code>PSD</code>设计稿,然后在样式中给 HTML 设定一个<code>font-size</code>的值，我们一般都设置一个方便后面计算的值，例如：<code>100px</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px; //1rem=100px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>首先按照设计稿的尺寸来写样式，把得到的像素值除以<code>100</code>计算出对应的<code>REM</code>值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margin:0 0.2rem;</span><br><span class="line">height:3rem;</span><br></pre></td></tr></table></figure></li><li><p>根据当前屏幕宽度和设计稿的宽度来计算出<code>font-size</code>的值。<br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个<code>font-size</code>的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其<code>font-size</code>应该设置为多少。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">375/640*100-&gt;font-size=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure><p>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的<code>font-size</code>值应该是多少，如果<code>font-size</code>的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小。可以通过以下这段代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//html部分</span><br><span class="line">&lt;section id=&quot;main&quot;&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">//js部分</span><br><span class="line">&lt;script&gt;</span><br><span class="line">~function()&#123;</span><br><span class="line">    var desW=640,</span><br><span class="line">    winW=document.documentElement.clientwidth,</span><br><span class="line">    ratio=winW/desW;</span><br><span class="line">    var oMain=document.getElementById(main&quot;)；</span><br><span class="line">    if(winW&gt;desW)&#123;</span><br><span class="line">        oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">        oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个页面适配多种设备和多个屏幕&lt;/p&gt;
    
    </summary>
    
      <category term="布局" scheme="https://dorisfeng.github.io/categories/%E5%B8%83%E5%B1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>CORS-预检请求</title>
    <link href="https://dorisfeng.github.io/2020/07/17/CORS-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/"/>
    <id>https://dorisfeng.github.io/2020/07/17/CORS-预检请求/</id>
    <published>2020-07-17T05:44:23.000Z</published>
    <updated>2020-07-19T05:02:33.038Z</updated>
    
    <content type="html"><![CDATA[<p>CORS 的预检请求<br>CORS 跨域的前后端配置<br>简单请求和非简单请求</p><a id="more"></a><h2 id="CORS-预检请求"><a href="#CORS-预检请求" class="headerlink" title="CORS 预检请求"></a>CORS 预检请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p><strong>条件(同时满足)</strong><br>请求方法：HEAD,GET,POST<br>请求头：Accept,Accept-Language,Content-Language,Last-Event-ID,Content-Type:只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain</p><p><strong>验证过程</strong><br>客户端发送简单请求，会在请求头增加一个 Origin 头信息，指定该请求发送方的域，提交给服务器用于判断是否接受该跨域请求。<br>两种情况下服务器会接受该跨域:</p><ol><li><code>Access-Control-Allow-Origin:*</code><br>如果服务器同意该跨域访问，正常返回数据，并在响应头中携带添加<code>Access-Control-Allow-Origin</code> 头信息。</li><li><code>Access-Control-Allow-Origin</code>设置的允许跨域的地址中包含请求的<code>Origin</code>。</li></ol><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>不满足上面简单请求规则的请求都是非简单请求。比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。<br><strong>避免多次请求，axios 的 post 封装为简单请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import QS from &quot;qs&quot;;</span><br><span class="line">export function post(url: string, data: any) &#123;</span><br><span class="line">  return axios(&#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    url,</span><br><span class="line">    data: QS.stringify(data),</span><br><span class="line">    headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端通过 app.use(bodyParser())将 req.body 解析为对象</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>当浏览器检测到需要发送一个非简单的跨域请求时，浏览器会拦截该请求，发送一个预检请求到服务器，旨在询问服务器是否同意这个非简单的跨域请求，服务器通过返回指定内容表示是否同意。</p><ul><li><p>成功的预检请求响应<br><img src="/2020/07/17/CORS-预检请求/img4.jpg" alt="跨域请求成功3"></p><ul><li>Access-Control-Allow-Credentials:是否携带 cookie</li><li>Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支 持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li><li>Access-Control-Allow-Headers<br>如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li><li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</li></ul></li></ul><p>预检通过<br>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p><h3 id="完整的复杂请求例子"><a href="#完整的复杂请求例子" class="headerlink" title="完整的复杂请求例子"></a>完整的复杂请求例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">document.cookie = &apos;name=xiamen&apos; // cookie不能跨域</span><br><span class="line">xhr.withCredentials = true // 前端设置是否带cookie</span><br><span class="line">xhr.open(&apos;PUT&apos;, &apos;http://localhost:4000/getData&apos;, true)</span><br><span class="line">xhr.setRequestHeader(&apos;name&apos;, &apos;xiamen&apos;)</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(xhr.response)</span><br><span class="line">      //得到响应头，后台需设置Access-Control-Expose-Headers</span><br><span class="line">      console.log(xhr.getResponseHeader(&apos;name&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;)</span><br><span class="line">let app = express()</span><br><span class="line">let whitList = [&apos;http://localhost:3000&apos;] //设置白名单</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  let &#123;origin&#125; = req.headers;</span><br><span class="line">  if (whitList.includes(origin)) &#123;</span><br><span class="line">    // 设置哪个源可以访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, origin)</span><br><span class="line">    // 允许携带哪个头访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;)</span><br><span class="line">    // 允许哪个方法访问我</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class="line">    // 允许携带cookie</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true)</span><br><span class="line">    // 预检的存活时间</span><br><span class="line">    res.setHeader(&apos;Access-Control-Max-Age&apos;, 6)</span><br><span class="line">    // 允许返回的头</span><br><span class="line">    res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;)</span><br><span class="line">    if (req.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">      res.end() // OPTIONS请求不做任何处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(&apos;/getData&apos;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.setHeader(&apos;name&apos;, &apos;jw&apos;) //返回一个响应头，后台需设置</span><br><span class="line">  res.end(&apos;我不爱你&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&apos;/getData&apos;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&apos;我不爱你&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(4000)</span><br></pre></td></tr></table></figure><p>cookie 参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path：指定 cookie 影响到的路径</span><br><span class="line">expires: 指定时间格式</span><br><span class="line">maxAge：指定 cookie 什么时候过期</span><br><span class="line">secure：当 secure 值为 true 时，在 HTTPS 中才有效；反之，cookie 在 HTTP 中是有效。</span><br><span class="line">httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。设置为true可以避免被 xss 攻击拿到 cookie</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CORS 的预检请求&lt;br&gt;CORS 跨域的前后端配置&lt;br&gt;简单请求和非简单请求&lt;/p&gt;
    
    </summary>
    
      <category term="网络请求" scheme="https://dorisfeng.github.io/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域解决方案</title>
    <link href="https://dorisfeng.github.io/2020/07/17/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://dorisfeng.github.io/2020/07/17/跨域解决方案/</id>
    <published>2020-07-17T05:37:20.000Z</published>
    <updated>2020-07-19T04:35:34.783Z</updated>
    
    <content type="html"><![CDATA[<p>什么是跨域，以及有哪几种跨域方式<br><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">参考</a></p><a id="more"></a><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>浏览器同源策略，是浏览器最核心和最基本的安全功能，如果缺少同源策略，浏览器很容易受到<code>XSS</code>、<code>CSRF</code>等攻击。<br>同源：协议相同，域名相同，端口相同<br>即便是两个不同的域名指向同一 IP 地址，也是非同源的。<br><img src="/2020/07/17/跨域解决方案/img5.png" alt="同源"><br><strong>同源策略限制内容有：</strong></p><ul><li><code>Cookie</code>,<code>LocalStorage</code>,<code>indexDB</code> 等存储性内容</li><li><code>DOM</code>节点</li><li><code>AJAX</code>请求</li></ul><p><strong>允许跨域加载资源的三个标签：</strong></p><ul><li><code>&lt;img src=XXX/&gt;</code></li><li><code>&lt;link href=XXX/&gt;</code></li><li><code>&lt;script src=XXX/&gt;</code></li></ul><h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。</strong> 不同域之间相互请求资源，就算作“跨域”。</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code> <code>http://www.a.com/b.js</code></td><td>同一域名下</td><td>允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code> <code>http://www.a.com/script/b.js</code></td><td>同一域名，不同文件夹</td><td>允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code> <code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> <code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> <code>http://10.11.12/b.js</code></td><td>域名和域名对应的 IP</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> <code>http://script.a.com/b.js</code></td><td>一级域名相同，二级域名不同</td><td>不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> <code>http://a.com/b.js</code></td><td>一级域名相同，二级域名不同</td><td>不允许（cookie 也不会允许访问）</td></tr><tr><td><code>http://www.a.com/a.js</code> <code>http://www.b.com/b.js</code></td><td>不同主域名</td><td>不允许</td></tr></tbody></table><p><strong>特别说明</strong></p><ul><li>如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。</li></ul><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</strong><br>通过表单的方式可以发起跨域请求，为什么<code>Ajax</code>就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，<code>Ajax</code>可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 <code>CSRF</code>，因为请求毕竟是发出去了。</p><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。然后在 <code>src</code>中函数会立即执行。因此需要服务器的支持才可以。</p><h4 id="JSONP-和-AJAX-对比"><a href="#JSONP-和-AJAX-对比" class="headerlink" title="JSONP 和 AJAX 对比"></a>JSONP 和 AJAX 对比</h4><p>都是客户端向服务器端发送请求，从服务端获取数据。<br>AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优：兼容性好，可以用于解决主流浏览器的跨域数据访问的问题。<br>缺：仅支持<code>get</code>方法，具有局限性，不安全，可能会遭到<code>XSS</code>攻击。</p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ul><li>声明一个回调函数<code>callFun</code>，函数名作为参数传递给服务器，形参就是要获取的数据</li><li>创建一个<code>script</code>标签，把跨域的 API 接口地址赋值给<code>script</code>的<code>src</code>属性，还要在地址中向服务器传递上一步创建的函数参数，比如<code>&lt;script src=&#39;http://192.168.0.1:8001/get_data?callback=callFun&#39;&gt;&lt;/script&gt;</code>；</li><li>服务器接收到请求后，获取请求中的 callback 函数名（<code>callFun</code>）拼接上返回的数据，比如<code>callFun({msg:&#39;返回数据&#39;})</code>；</li><li>服务器把返回值通过 HTTP 协议返回给客户端，客户端调用执行声明的回调函数，对返回的数据进行操作。</li></ul><p>封装 JSONP 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">function jsonp(url, params, callback)&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        let script=document.createElement(&apos;script&apos;);</span><br><span class="line">        window[callback]=function(data)&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">            document.body.removeChild(script)</span><br><span class="line">        &#125;</span><br><span class="line">        params=&#123;...params,callback&#125;;</span><br><span class="line">        let arrs=[];</span><br><span class="line">        for(let key in params)&#123;</span><br><span class="line">            arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">        &#125;</span><br><span class="line">        script.src=`$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;)&#125;`</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jsonp(&#123;</span><br><span class="line">    url:&apos;http://localhost:8001/get_data&apos;,</span><br><span class="line">    params:&#123;msg:&apos;lalala&apos;&#125;,</span><br><span class="line">    callback:&apos;show&apos;</span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的请求相当于向<code>http://localhost:8001/get_data?msg=lalala&amp;callback=show</code></p><p>服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let express=require(&apos;express&apos;);</span><br><span class="line">let app= express();</span><br><span class="line">app.get(&apos;/get_data&apos;,function(req,res)&#123;</span><br><span class="line">    let &#123;msg,callback&#125;= req.query;</span><br><span class="line">    console.log(msg,callback); //&apos;lalala&apos; &apos;show&apos;</span><br><span class="line">    res.send(`$&#123;callback&#125;($&#123;msg&#125;)`)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(8001)</span><br></pre></td></tr></table></figure><h4 id="jQuery-的-jsonp-形式"><a href="#jQuery-的-jsonp-形式" class="headerlink" title="jQuery 的 jsonp 形式"></a>jQuery 的 jsonp 形式</h4><p>JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;http://localhost:8001/get_data&quot;,</span><br><span class="line">    dataType:&apos;jsonp&apos;,</span><br><span class="line">    type:&apos;get&apos;, //可省略</span><br><span class="line">    jsonCallback:&apos;show&apos;,//自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="line">    jsonp:&apos;callback&apos;,//传递函数名的形参callback=show,可省略</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>需要浏览器和后端同时支持，IE8 和 9 需要通过<code>XDomainRequest</code>来实现。<br>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。<br>服务端设置响应头 <code>Access-Control-Allow-Origin</code>配置：</p><ol><li><code>*</code>表示服务器设置任意域都同意<br><img src="/2020/07/17/跨域解决方案/img1.jpg" alt="跨域请求成功1"></li><li><p>设置允许一个跨域域名<br><strong>node</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:3000&apos;);</span><br></pre></td></tr></table></figure><p><strong>koa2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin: function(ctx) &#123; //设置允许来自指定域名请求</span><br><span class="line">    return &apos;http://localhost:3000&apos;; //只允许http://localhost:3000这个域名的请求</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="/2020/07/17/跨域解决方案/img2.jpg" alt="跨域请求成功2"></p></li><li><p>设置允许多个跨域域名<br><strong>node</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://weipxiu.com,http://localhost:8001,http://localhost:3000&apos;);</span><br></pre></td></tr></table></figure><p><strong>koa2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">origin: function (ctx) &#123;</span><br><span class="line">    //多个域</span><br><span class="line">    const whiteList = [&quot;http://weipxiu.com&quot;,&quot;http://localhost:8081&quot;,&quot;http://localhost:3000&quot;]; //可跨域白名单</span><br><span class="line">    let url = ctx.header.origin;</span><br><span class="line">    if (whiteList.includes(url)) &#123;</span><br><span class="line">    return url; //注意，这里域名末尾不能带/，否则不成功，所以在之前我把/通过substr干掉了</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;http://localhost:8001&quot;; //默认允许本地请求8001端口可跨域</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果服务器返回的信息中没有该字段信息，这个数据将会被浏览器拦截，无法到达请求方，浏览器并会报错。</p><p><img src="/2020/07/17/跨域解决方案/img3.png" alt="跨域请求成功3"></p></li></ol><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><p>解决以下问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间信息传递</li><li>页面与嵌套的<code>iframe</code>消息传递</li><li>上面三个场景的跨域数据传递</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrigin,[transfer]);</span><br></pre></td></tr></table></figure><ul><li>message：将要发送到其他 window 的数据</li><li>targetOrigin：通过窗口的<code>origin</code>属性来指定哪些窗口能接收到消息事件，可以是<code>*</code>（表示无限制）或一个<code>URL</code>。在发送消息的时候回，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，消息就不会被发送，只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：一串和<code>message</code>同时传递的<code>Transferable</code>对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p><strong>例子</strong><br>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。<br>a.html 运行在 localhost:3000<br>可以使用<code>express</code>创建服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function load() &#123;</span><br><span class="line">        let frame = document.getElementById(&apos;frame&apos;);</span><br><span class="line">        frame.contentWindow.postMessage(&apos;我爱你&apos;,&apos;http://localhost:4000&apos;);</span><br><span class="line">        window.onmessage = function (e) &#123;</span><br><span class="line">        console.log(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html 运行在 localhost:4000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onmessage = function (e) &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">    e.source.postMessage(&apos;我不爱你&apos;,e.origin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是 HTML5 的持久化的协议，实现浏览器和服务器的全双工通信，同时也是跨域的一种解决方案。<br><code>WebSocket</code>和<code>HTTP</code>都是应用层协议，都是基于<code>TCP</code>协议。但是<code>WebSocket</code>是一个双工通信协议，建立连接之后，<code>server</code>和<code>client</code>都能主动向对方发送或接收数据。<br><code>WebSocket</code>在建立连接时需要借助 <code>HTTP</code>协议，连接建立好了之后<code>client</code>与<code>server</code> 之间的双向通信就与<code>HTTP</code>无关。</p><p><code>Socket.io</code>很好地封装了<code>WebSocket</code>接口，提供了更简单、灵活的接口，也对不支持<code>WebSocket</code>的浏览器提供了向下兼容。<br>例子：本地文件 socket.html 向 localhost:8000 发生数据和接受数据<br>socket.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function WebSocketTest() &#123;</span><br><span class="line">  if (&quot;WebSocket&quot; in window) &#123;</span><br><span class="line">      // console.log(&apos;您的浏览器支持WebSocket!&apos;);</span><br><span class="line">      //打开一个web socket</span><br><span class="line">      var ws = new WebSocket(&apos;ws://localhost:8181&apos;)</span><br><span class="line">      ws.onopen = function () &#123;</span><br><span class="line">          //Web Socket已经连接上，使用send()发送数据</span><br><span class="line">          ws.send(&apos;发送数据&apos;);</span><br><span class="line">          console.log(&apos;数据发送中。。。&apos;)</span><br><span class="line">      &#125;;</span><br><span class="line">      ws.onmessage = function (evt) &#123;</span><br><span class="line">          var received_msg = evt.data;</span><br><span class="line">          console.log(&apos;数据已接收&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      ws.onclose = function () &#123;</span><br><span class="line">          //关闭</span><br><span class="line">          console.log(&apos;连接已关闭&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      //浏览器不支持WebSocket</span><br><span class="line">      console.log(&apos;浏览器不支持WebSocket&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">WebSocketTest()</span><br></pre></td></tr></table></figure><p>server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var WebSocketServer = require(&quot;ws&quot;).Server,</span><br><span class="line">wss = new WebSocketServer(&#123; port: 8181 &#125;);</span><br><span class="line">wss.on(&quot;connection&quot;, function(ws) &#123;</span><br><span class="line">    console.log(&quot;client connected&quot;);</span><br><span class="line">    ws.on(&quot;message&quot;, function(message) &#123;</span><br><span class="line">        console.log(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Node-中间件代理（两次跨域）"><a href="#Node-中间件代理（两次跨域）" class="headerlink" title="Node 中间件代理（两次跨域）"></a>Node 中间件代理（两次跨域）</h3><p>原理：同源策略是浏览器需要遵循的标准，而如果服务器向服务器请求就无需遵循同源策略。<br>代理服务器，需要以下步骤：</p><ul><li>接收客户端请求</li><li>将请求转给服务器</li><li>拿到服务器响应的数据</li><li>将数据转发给客户端<br><img src="/2020/07/17/跨域解决方案/img6.png" alt="中间件"></li></ul><p><strong>例子：本地 index.html 文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据</strong><br>index.html(<a href="http://127.0.0.1:5500" target="_blank" rel="noopener">http://127.0.0.1:5500</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    url: &apos;http://localhost:3000&apos;,</span><br><span class="line">    type: &apos;post&apos;,</span><br><span class="line">    data: &#123; name: &apos;xiamen&apos;, password: &apos;123456&apos; &#125;,</span><br><span class="line">    contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">    success: function(result) &#123;</span><br><span class="line">        console.log(&apos;result&apos;, result)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(msg) &#123;</span><br><span class="line">        console.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>server1.js 代理服务器（<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// server1.js 代理服务器(http://localhost:3000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">// 第一步：接受客户端请求</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br><span class="line">  response.writeHead(200, &#123;</span><br><span class="line">    &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Methods&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Headers&apos;: &apos;Content-Type&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 第二步：将请求转发给服务器</span><br><span class="line">  const proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: &apos;127.0.0.1&apos;,</span><br><span class="line">        port: 4000,</span><br><span class="line">        url: &apos;/&apos;,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        // 第三步：收到服务器的响应</span><br><span class="line">        var body = &apos;&apos;;</span><br><span class="line">        serverResponse.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">          body += chunk;</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">          console.log(&apos;The data is &apos; + body)</span><br><span class="line">          // 第四步：将响应结果转发给浏览器</span><br><span class="line">          response.end(body);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The proxyServer is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>server2.js(<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const data = &#123; title: &apos;fontend&apos;, password: &apos;123456&apos; &#125;</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    response.end(JSON.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(4000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The server is running at http://localhost:4000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在<code>index.html</code>文件打印出<code>{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;}</code></p><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a><code>nginx</code>反向代理</h3><p>实现原理类似于<code>Node</code>中间件代理，需要你搭建一个中转<code>nginx</code>服务器，用于转发请求。<br>使用<code>nginx</code>反向代理实现跨域，是最简单的跨域方式。只需要修改<code>nginx</code>的配置即可解决跨域问题，支持所有浏览器，支持 <code>session</code>，不需要修改任何代码，并且不会影响服务器性能。<br>实现思路：通过<code>nginx</code>配置一个代理服务器（域名与<code>domain1</code>相同，端口不同）做跳板机，反向代理访问<code>domain2</code>接口，并且可以顺便修改<code>cookie</code>中<code>domain</code>信息，方便当前域<code>cookie</code>写入，实现跨域登录。<br>先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name+iframe"></a><code>window.name+iframe</code></h3><p>window.name 属性的独特之处：在一个窗口(window)的生命周期内，name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br><strong>例子，页面 a.html<a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a>获取页面 b.html<a href="http://localhost:4000/b.html" target="_blank" rel="noopener">http://localhost:4000/b.html</a>的数据</strong><br>b.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &quot;&#123;&apos;name&apos;:&apos;lala&apos;&#125;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>a.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function getData(url) &#123;</span><br><span class="line">        var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        iframe.style.display = &quot;none&quot;;</span><br><span class="line">        var state = 0;</span><br><span class="line">        iframe.onload = function () &#123;</span><br><span class="line">            if (state === 1) &#123;</span><br><span class="line">                var data = iframe.contentWindow.name;</span><br><span class="line">                console.log(data);</span><br><span class="line">                // 获取到数据后将隐藏的iframe去除</span><br><span class="line">                iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">                iframe.contentWindow.close();</span><br><span class="line">                document.removeChild(iframe);</span><br><span class="line">            &#125; else if (state === 0) &#123;</span><br><span class="line">                state = 1;</span><br><span class="line">                iframe.contentWindow.location.href = window.location.href;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iframe.src = url;</span><br><span class="line">        document.body.appendChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">    getData(&apos;http://localhost:4000/c.html&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash+iframe"></a><code>location.hash+iframe</code></h3><p>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code>。<br>a.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 路径后面的hash值可以用来通信  --&gt;</span><br><span class="line">&lt;!-- 目的a想访问c --&gt;</span><br><span class="line">&lt;!-- a给c传一个hash值 c收到hash值后  c把hash值传递给b b将结果放到a的hash值中--&gt;</span><br><span class="line">&lt;iframe src=&quot;http://localhost:4000/c.html#howareyou&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        console.log(location.hash)//iamfine</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.parent.parent.location.hash = location.hash;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>c.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    console.log(location.hash);//howareyou</span><br><span class="line">    let iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.src = &apos;http://localhost:3000/b.html#iamfine&apos;;</span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a><code>document.domain+iframe</code></h3><p><strong>该方法只能用于二级域名相同的情况下，比如<code>a.test.com</code>和<code>b.test.com</code>适用于该方法。</strong><br>实现原理：两个页面都通过<code>js</code>强制设置<code>document.domain</code>为基础主域，就实现了同域。<br><strong>例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中的<code>a</code>的值</strong><br>a.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 域名 一级域名二级域名 --&gt;</span><br><span class="line">&lt;!-- www.baidu.com --&gt;</span><br><span class="line">&lt;!-- viode.baidu.com --&gt;</span><br><span class="line">&lt;!-- a是通过 http://a.zf1.cn:3000/a.html --&gt;</span><br><span class="line"> hello a</span><br><span class="line">  &lt;iframe src=&quot;http://b.zf1.cn:3000/b.html&quot; frameborder=&quot;0&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.domain = &apos;zf1.cn&apos;</span><br><span class="line">    function load() &#123;</span><br><span class="line">      console.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>b.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   hello b</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     document.domain = &apos;zf1.cn&apos;</span><br><span class="line">     var a = 100;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>CORS</code>支持所有类型的<code>HTTP</code>请求，是跨域<code>HTTP</code>请求的根本解决方案；</li><li><code>JSONP</code>只支持<code>GET</code>请求，<code>JSONP</code>的优势在于支持老式浏览器，以及可以向不支持<code>CORS</code> 的网址请求数据；</li><li>不管是<code>Node</code>中间件代理还是<code>nginx</code>反向代理，主要是通过同源策略对服务器不加限制；</li><li>日常工作中，用得比较多的跨域方案是<code>CORS</code>和<code>nginx</code>反向代理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是跨域，以及有哪几种跨域方式&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5c23993de51d457b8c1f4ee1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络请求" scheme="https://dorisfeng.github.io/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>JS-执行上下文和执行栈</title>
    <link href="https://dorisfeng.github.io/2020/07/16/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>https://dorisfeng.github.io/2020/07/16/JS-执行上下文和执行栈/</id>
    <published>2020-07-16T02:22:57.000Z</published>
    <updated>2020-07-16T05:56:16.389Z</updated>
    
    <content type="html"><![CDATA[<p>执行上下文和执行栈</p><a id="more"></a><p>执行上下文（<code>Execution Context</code>）：当前<code>JS</code>代码被解析和执行时所在环境的抽象概念。当前代码的执行环境，会形成一个作用域。<br><code>JavaScript</code>中的运行环境包括三种：</p><ul><li>全局环境：<code>JavaScript</code>代码运行起来会首先进入该环境；</li><li>函数环境：当函数被调用执行时，进入当前函数中执行代码；</li><li><code>eval</code>（不建议使用，可忽略）<br>JS 程序中，会产生多个执行上下文，JS 引擎会以函数调用栈（call stack）的方式来处理，栈底永远是全局上下文，栈顶是当前正在执行的上下文。<br>代码执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，处于栈顶的上下文执行完毕后，自动出栈，</li></ul><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var color = &apos;blue&apos;;</span><br><span class="line"></span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var anotherColor = &apos;red&apos;;</span><br><span class="line"></span><br><span class="line">  function swapColors() &#123;</span><br><span class="line">    var tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><ol><li><p>全局上下文入栈；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img1.png" alt="全局上下文入栈"></p></li><li><p>执行到<code>changeColor()</code>，创建当前函数的执行上下文；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img2.png" alt="函数执行栈"></p></li><li><p>执行<code>changeColor</code>中的可执行代码，遇到<code>swapColors()</code>,创建<code>swapColors</code>执行上下文；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img3.png" alt="函数执行栈"></p></li><li><code>swapColors</code>函数执行完成后，<code>swapColors EC</code>出栈；<br><img src="/2020/07/16/JS-执行上下文和执行栈/img2.png" alt="函数执行栈"></li><li>继续执行<code>changeColor</code>函数，执行完成后，<code>changeColor EC</code>出栈，只剩下全局执行上下文。<br><img src="/2020/07/16/JS-执行上下文和执行栈/img1.png" alt="全局上下文入栈"></li><li>全局上下文在浏览器窗口关闭后出栈。</li></ol><p><code>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</code><br><img src="/2020/07/16/JS-执行上下文和执行栈/img4.png" alt="全局上下文入栈"></p><p><strong>生命周期</strong>：创建阶段、执行阶段、回收阶段<br><img src="/2020/07/16/JS-执行上下文和执行栈/img5.png" alt="全局上下文入栈"></p><ol><li><p>创建阶段（函数创建，但未执行）</p><ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明</li><li>创建作用域链</li><li>确定 this 指向</li></ul></li><li><p>函数内部执行时，会形成新的私有作用域，然后依次执行</p><ul><li>如果有形参，先给形参赋值</li><li>进行私有作用域的预解释，函数声明优先级比变量声明高，但可以重新赋值，</li><li>私有作用域中的代码从上到下执行<br>每次调用函数创建一个新的执行上下文，JS 引擎创建了执行栈来管理执行上下文，执行栈是一个存储函数调用的栈结构，遵循先进后出的原则。</li></ul></li></ol><p>多个函数执行过程：</p><ul><li>JS 执行在单线程上，所有的代码都是排队执行</li><li>首先创建全局执行上下文，压入执行栈的底部</li><li>函数执行时就创建新的执行上下文，压入执行栈的底部。</li><li>函数执行完，该函数执行上下文出栈，等待垃圾回收</li><li>浏览器的 JS 执行引擎总是访问栈顶执行上下文</li><li>全局执行上下文只有唯一一个，它在浏览器关闭时出栈。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行上下文和执行栈&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS-闭包</title>
    <link href="https://dorisfeng.github.io/2020/07/14/JS-%E9%97%AD%E5%8C%85/"/>
    <id>https://dorisfeng.github.io/2020/07/14/JS-闭包/</id>
    <published>2020-07-14T14:00:51.000Z</published>
    <updated>2020-07-17T02:51:06.814Z</updated>
    
    <content type="html"><![CDATA[<p>闭包</p><a id="more"></a><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>外层函数包裹受保护的变量和内层函数量，外层函数将内层函数返回到外部。<br>优点： 重用变量，保护变量被污染<br>缺点：占用内层。滥用会造成内存泄漏<br>如何释放闭包：将引用内存函数对象的外部变量设置为 null<br>外层函数将内层函数返回到外部的方法：</p><ul><li>return</li><li>赋值给全局变量</li><li>将内层函数包裹在对象或数组内返回</li></ul><p>应用场景：</p><ul><li>函数作为参数传递（作用域的例子）</li><li>函数作为返回值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return function inner() &#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var func1 = outer()</span><br><span class="line">func1() //1</span><br><span class="line">func1() //2</span><br><span class="line">var func2 = outer()</span><br><span class="line">func2() //1</span><br><span class="line">func2() //2</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fn = null;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  function innerFoo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  fn = innerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  fn(); // 此处的保留的innerFoo的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); // 2</span><br></pre></td></tr></table></figure><p><img src="/2020/07/14/JS-闭包/img1.png" alt="闭包"></p><p><strong>总结</strong></p><ul><li>闭包是在函数被调用执行的时候才被确认创建的。</li><li>闭包的形成，与作用域链的访问顺序有直接关系。</li><li>只有内部函数访问了上层作用域中的变量对象，才会形成闭包。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>柯里化</li><li>模块化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://dorisfeng.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
